{
    "Additional shared libraries": {
        "value": ".\/plugin\/libsimpler_with_crust.so",
        "default_value": "",
        "documentation": "A list of names of additional shared libraries that should be loaded upon starting up the program. The names of these files can contain absolute or relative paths (relative to the directory in which you call ASPECT). In fact, file names that do not contain any directory information (i.e., only the name of a file such as <libmyplugin.so> will not be found if they are not located in one of the directories listed in the \\texttt{LD_LIBRARY_PATH} environment variable. In order to load a library in the current directory, use <.\/libmyplugin.so> instead.\n\nIf you specify <.\/libmyplugin.so>, ASPECT will open either <.\/libmyplugin.debug.so> or <.\/libmyplugin.release.so> depending on the current ASPECT build type.\n\nThe typical use of this parameter is so that you can implement additional plugins in your own directories, rather than in the ASPECT source directories. You can then simply compile these plugins into a shared library without having to re-compile all of ASPECT. See the section of the manual discussing writing extensions for more information on how to compile additional files into a shared library.",
        "pattern": "1",
        "pattern_description": "[List of <[FileName (Type: input)]> of length 0...4294967295 (inclusive)]"
    },
    "Adiabatic surface temperature": {
        "value": "0.",
        "default_value": "0.",
        "documentation": "In order to make the problem in the first time step easier to solve, we need a reasonable guess for the temperature and pressure. To obtain it, we use an adiabatic pressure and temperature field. This parameter describes what the `adiabatic' temperature would be at the surface of the domain (i.e. at depth zero). Note that this value need not coincide with the boundary condition posed at this point. Rather, the boundary condition may differ significantly from the adiabatic value, and then typically induce a thermal boundary layer.\n\nFor more information, see the section in the manual that discusses the general mathematical model.",
        "pattern": "17",
        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
    },
    "CFL number": {
        "value": "1.0",
        "default_value": "1.0",
        "documentation": "In computations, the time step $k$ is chosen according to $k = c \\min_K \\frac {h_K} {\\|u\\|_{\\infty,K} p_T}$ where $h_K$ is the diameter of cell $K$, and the denominator is the maximal magnitude of the velocity on cell $K$ times the polynomial degree $p_T$ of the temperature discretization. The dimensionless constant $c$ is called the CFL number in this program. For time discretizations that have explicit components, $c$ must be less than a constant that depends on the details of the time discretization and that is no larger than one. On the other hand, for implicit discretizations such as the one chosen here, one can choose the time step as large as one wants (in particular, one can choose $c>1$) though a CFL number significantly larger than one will yield rather diffusive solutions. Units: None.",
        "pattern": "8",
        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
    },
    "Dimension": {
        "value": "2",
        "default_value": "2",
        "documentation": "The number of space dimensions you want to run this program in. ASPECT can run in 2 and 3 space dimensions.",
        "pattern": "0",
        "pattern_description": "[Integer range 2...3 (inclusive)]"
    },
    "End time": {
        "value": "2e7",
        "default_value": "5.69e+300",
        "documentation": "The end time of the simulation. The default value is a number so that when converted from years to seconds it is approximately equal to the largest number representable in floating point arithmetic. For all practical purposes, this equals infinity. Units: Years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
        "pattern": "356",
        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
    },
    "Max nonlinear iterations": {
        "value": "10",
        "default_value": "10",
        "documentation": "The maximal number of nonlinear iterations to be performed.",
        "pattern": "3",
        "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
    },
    "Max nonlinear iterations in pre-refinement": {
        "value": "2147483647",
        "default_value": "2147483647",
        "documentation": "The maximal number of nonlinear iterations to be performed in the pre-refinement steps. This does not include the last refinement step before moving to timestep 1. When this parameter has a larger value than max nonlinear iterations, the latter is used.",
        "pattern": "4",
        "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
    },
    "Maximum first time step": {
        "value": "1e3",
        "default_value": "5.69e+300",
        "documentation": "Set a maximum time step size for only the first timestep. Generally the time step based on the CFL number should be sufficient, but for complicated models or benchmarking it may be useful to limit the first time step to some value, especially when using the free surface, which needs to settle to prevent instabilities. This should in that case be combined with a value set for ``Maximum relative increase in time step''. The default value is a value so that when converted from years into seconds it equals the largest number representable by a floating point number, implying an unlimited time step. Units: Years or seconds, depending on the ``Use years in output instead of seconds'' parameter.",
        "pattern": "10",
        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
    },
    "Maximum relative increase in time step": {
        "value": "30",
        "default_value": "91.0",
        "documentation": "Set a percentage with which the length of the time step is limited to increase. Generally the time step based on the CFL number should be sufficient, but for complicated models which may suddenly drastically change behavior, it may be useful to limit the increase in the time step, without limiting the time step size of the whole simulation to a particular number. For example, if this parameter is set to $50$, then that means that the length of a time step can at most increase by 50\\% from one time step to the next, or by a factor of 1.5. \n\nHere, the default value is set to be 91\\% because the best available step-size ratio bound guaranteeing stability in the PDE context seems to be 1.91, see \\cite{Denner:2014}. In that thesis, the bound was proved in the context of semilinear parabolic problem, but it appears reasonable to also use this value as an upper bound in the current context.\n\nUnits: \\%.",
        "pattern": "11",
        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
    },
    "Maximum time step": {
        "value": "5.69e+300",
        "default_value": "5.69e+300",
        "documentation": "Set a maximum time step size for the solver to use. Generally the time step based on the CFL number should be sufficient, but for complicated models or benchmarking it may be useful to limit the time step to some value. The default value is a value so that when converted from years into seconds it equals the largest number representable by a floating point number, implying an unlimited time step.Units: Years or seconds, depending on the ``Use years in output instead of seconds'' parameter.",
        "pattern": "9",
        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
    },
    "Nonlinear solver scheme": {
        "value": "single Advection, single Stokes",
        "default_value": "single Advection, single Stokes",
        "documentation": "The kind of scheme used to resolve the nonlinearity in the system. `single Advection, single Stokes' means that no nonlinear iterations are done, and the temperature, compositional fields and Stokes equations are solved exactly once per time step, one after the other. The `iterated Advection and Stokes' scheme iterates this decoupled approach by alternating the solution of the temperature, composition and Stokes systems. The `single Advection, iterated Stokes' scheme solves the temperature and composition equation once at the beginning of each time step and then iterates out the solution of the Stokes equation. The `no Advection, iterated Stokes' scheme only solves the Stokes system, iterating out the solution, and ignores compositions and the temperature equation (careful, the material model must not depend on the temperature or composition; this is mostly useful for Stokes benchmarks).  The `no Advection, single Stokes' scheme only solves the Stokes system once per timestep. This is also mostly useful for Stokes benchmarks. The `single Advection, no Stokes' scheme only solves the temperature and other advection systems once, and instead of solving for the Stokes system, a prescribed velocity and pressure is used. The `iterated Advection and Newton Stokes' scheme iterates by alternating the solution of the temperature, composition and Stokes equations, using Picard iterations for the temperature and composition, and Newton iterations for the Stokes system. The `single Advection, iterated Newton Stokes' scheme solves the temperature and composition equations once at the beginning of each time step and then iterates out the solution of the Stokes equation, using Newton iterations for the Stokes system. The `iterated Advection and defect correction Stokes' scheme iterates by alternating the solution of the temperature, composition and Stokes equations, using Picard iterations for the temperature and composition, and defect correction Picard iterations for the Stokes system. The `single Advection, iterated defect correction Stokes' scheme solves the temperature and composition equations once at the beginning of each time step and then iterates out the solution of the Stokes equation, using defect correction Picard iterations for the Stokes system. The `no Advection, iterated defect correction Stokes' scheme solves the temperature and composition equations once at the beginning of each time step and then iterates out the solution of the Stokes equation, using defect correction Picard iterations for the Stokes system. The `first timestep only, single Stokes' scheme solves the Stokes equations exactly once, at the first time step. No nonlinear iterations are done, and the temperature and composition systems are not solved. \n\nThe `IMPES' scheme is deprecated and only allowed for reasons of backwards compatibility. It is the same as `single Advection, single Stokes' .The `iterated IMPES' scheme is deprecated and only allowed for reasons of backwards compatibility. It is the same as `iterated Advection and Stokes'. The `iterated Stokes' scheme is deprecated and only allowed for reasons of backwards compatibility. It is the same as `single Advection, iterated Stokes'. The `Stokes only' scheme is deprecated and only allowed for reasons of backwards compatibility. It is the same as `no Advection, iterated Stokes'. The `Advection only' scheme is deprecated and only allowed for reasons of backwards compatibility. It is the same as `single Advection, no Stokes'. The `Newton Stokes' scheme is deprecated and only allowed for reasons of backwards compatibility. It is the same as `iterated Advection and Newton Stokes'.",
        "pattern": "13",
        "pattern_description": "[Selection single Advection, single Stokes|iterated Advection and Stokes|single Advection, iterated Stokes|no Advection, iterated Stokes|no Advection, single Stokes|no Advection, iterated defect correction Stokes|single Advection, iterated defect correction Stokes|iterated Advection and defect correction Stokes|iterated Advection and Newton Stokes|single Advection, iterated Newton Stokes|single Advection, no Stokes|IMPES|iterated IMPES|iterated Stokes|Newton Stokes|Stokes only|Advection only|first timestep only, single Stokes|no Advection, no Stokes ]"
    },
    "Nonlinear solver tolerance": {
        "value": "1e-5",
        "default_value": "1e-5",
        "documentation": "A relative tolerance up to which the nonlinear solver will iterate. This parameter is only relevant if the `Nonlinear solver scheme' does nonlinear iterations, in other words, if it is set to something other than `single Advection, single Stokes' or `single Advection, no Stokes'.",
        "pattern": "14",
        "pattern_description": "[Double 0...1 (inclusive)]"
    },
    "Output directory": {
        "value": "output-free_surface_with_crust",
        "default_value": "output",
        "documentation": "The name of the directory into which all output files should be placed. This may be an absolute or a relative path.",
        "pattern": "18",
        "pattern_description": "[DirectoryName]"
    },
    "Pressure normalization": {
        "value": "no",
        "default_value": "surface",
        "documentation": "If and how to normalize the pressure after the solution step. This is necessary because depending on boundary conditions, in many cases the pressure is only determined by the model up to a constant. On the other hand, we often would like to have a well-determined pressure, for example for table lookups of material properties in models or for comparing solutions. If the given value is `surface', then normalization at the end of each time steps adds a constant value to the pressure in such a way that the average pressure at the surface of the domain is what is set in the `Surface pressure' parameter; the surface of the domain is determined by asking the geometry model whether a particular face of the geometry has a zero or small `depth'. If the value of this parameter is `volume' then the pressure is normalized so that the domain average is zero. If `no' is given, the no pressure normalization is performed.",
        "pattern": "15",
        "pattern_description": "[Selection surface|volume|no ]"
    },
    "Resume computation": {
        "value": "false",
        "default_value": "false",
        "documentation": "A flag indicating whether the computation should be resumed from a previously saved state (if true) or start from scratch (if false). If auto is selected, models will be resumed if there is an existing checkpoint file, otherwise started from scratch.",
        "pattern": "2",
        "pattern_description": "[Selection true|false|auto ]"
    },
    "Start time": {
        "value": "0.",
        "default_value": "0.",
        "documentation": "The start time of the simulation. Units: Years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
        "pattern": "5",
        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
    },
    "Surface pressure": {
        "value": "0.",
        "default_value": "0.",
        "documentation": "The value the pressure is normalized to in each time step when `Pressure normalization' is set to `surface' with default value 0. This setting is ignored in all other cases.\n\nThe mathematical equations that describe thermal convection only determine the pressure up to an arbitrary constant. On the other hand, for comparison and for looking up material parameters it is important that the pressure be normalized somehow. We do this by enforcing a particular average pressure value at the surface of the domain, where the geometry model determines where the surface is. This parameter describes what this average surface pressure value is supposed to be. By default, it is set to zero, but one may want to choose a different value for example for simulating only the volume of the mantle below the lithosphere, in which case the surface pressure should be the lithostatic pressure at the bottom of the lithosphere.\n\nFor more information, see the section in the manual that discusses the general mathematical model.",
        "pattern": "16",
        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
    },
    "Timing output frequency": {
        "value": "100",
        "default_value": "100",
        "documentation": "How frequently in timesteps to output timing information. This is generally adjusted only for debugging and timing purposes. If the value is set to zero it will also output timing information at the initiation timesteps.",
        "pattern": "6",
        "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
    },
    "Use conduction timestep": {
        "value": "false",
        "default_value": "false",
        "documentation": "Mantle convection simulations are often focused on convection dominated systems. However, these codes can also be used to investigate systems where heat conduction plays a dominant role. This parameter indicates whether the simulator should also use heat conduction in determining the length of each time step.",
        "pattern": "12",
        "pattern_description": "[Bool]"
    },
    "Use operator splitting": {
        "value": "false",
        "default_value": "false",
        "documentation": "If set to true, the advection and reactions of compositional fields and temperature are solved separately, and can use different time steps. Note that this will only work if the material\/heating model fills the reaction\\_rates\/heating\\_reaction\\_rates structures. Operator splitting can be used with any existing solver schemes that solve the temperature\/composition equations.",
        "pattern": "19",
        "pattern_description": "[Bool]"
    },
    "Use years in output instead of seconds": {
        "value": "true",
        "default_value": "true",
        "documentation": "When computing results for mantle convection simulations, it is often difficult to judge the order of magnitude of results when they are stated in MKS units involving seconds. Rather, some kinds of results such as velocities are often stated in terms of meters per year (or, sometimes, centimeters per year). On the other hand, for non-dimensional computations, one wants results in their natural unit system as used inside the code. If this flag is set to `true' conversion to years happens; if it is `false', no such conversion happens.\n\nContrary to the word ``output'' in the name of this parameter, a number of plugins also use this parameter to determine how to interpret their \\textit{inputs}. For example, when `true', several of the boundary velocity models described in Section~\\ref{parameters:Boundary_20velocity_20model} interpret both specific times in years instead of seconds, and velocities in meters per year instead of meters per second.",
        "pattern": "7",
        "pattern_description": "[Bool]"
    },
    "World builder file": {
        "value": "",
        "default_value": "",
        "documentation": "Name of the world builder file. If empty, the world builder is not initialized.",
        "pattern": "20",
        "pattern_description": "[FileName (Type: input)]"
    },
    "Adiabatic conditions model": {
        "Model name": {
            "value": "compute profile",
            "default_value": "compute profile",
            "documentation": "Select one of the following models:\n\n`ascii data': A model in which the adiabatic profile is read from a file that describes the reference state. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of points in the reference state as for example `# POINTS: 3'. Following the comment lines there has to be a single line containing the names of all data columns, separated by arbitrarily many spaces. Column names are not allowed to contain spaces. The file can contain unnecessary columns, but for this plugin it needs to at least provide columns named `temperature', `pressure', and `density'. Note that the data lines in the file need to be sorted in order of increasing depth from 0 to the maximal depth in the model domain. Points in the model that are outside of the provided depth range will be assigned the maximum or minimum depth values, respectively. Points do not need to be equidistant, but the computation of properties is optimized in speed if they are.\n\n`compute entropy profile': A model in which the adiabatic profile is calculated by solving the hydrostatic equations for pressure and entropy in depth. Of course the entropy along an adiabat is constant. This plugin requires the material model to provide an additional output object of type PrescribedTemperatureOutputs. It also requires that there is a compositional field of type 'entropy' that represents the entropy of the material.\n\n`compute profile': A model in which the adiabatic profile is calculated by solving the hydrostatic equations for pressure and temperature in depth. The gravity is assumed to be in depth direction and the composition is either given by the initial composition at reference points or computed as a reference depth-function. All material parameters are computed by the material model plugin. The surface conditions are either constant or changing over time as prescribed by a user-provided function.\n\n`function': A model in which the adiabatic profile is specified by a user defined function. The supplied function has to contain temperature, pressure, and density as a function of depth in this order.",
            "pattern": "1279",
            "pattern_description": "[Selection ascii data|compute entropy profile|compute profile|function ]"
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/tests\/adiabatic-conditions\/ascii-data\/test\/",
                "default_value": "$ASPECT_SOURCE_DIR\/tests\/adiabatic-conditions\/ascii-data\/test\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1280",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "",
                "default_value": "",
                "documentation": "The file name of the model data.",
                "pattern": "1281",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1282",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Compute entropy profile": {
            "Number of points": {
                "value": "1000",
                "default_value": "1000",
                "documentation": "The number of points we use to compute the adiabatic profile. The higher the number of points, the more accurate the downward integration from the adiabatic surface conditions will be.",
                "pattern": "1283",
                "pattern_description": "[Integer range 5...2147483647 (inclusive)]"
            },
            "Surface entropy": {
                "value": "0",
                "default_value": "0",
                "documentation": "The surface entropy for the profile.",
                "pattern": "1284",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Compute profile": {
            "Composition reference profile": {
                "value": "initial composition",
                "default_value": "initial composition",
                "documentation": "Select how the reference profile for composition is computed. This profile is used to evaluate the material model, when computing the pressure and temperature profile.",
                "pattern": "1288",
                "pattern_description": "[Selection initial composition|function ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1287",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1286",
                "pattern_description": "[Anything]"
            },
            "Number of points": {
                "value": "1000",
                "default_value": "1000",
                "documentation": "The number of points we use to compute the adiabatic profile. The higher the number of points, the more accurate the downward integration from the adiabatic surface temperature will be.",
                "pattern": "1289",
                "pattern_description": "[Integer range 5...2147483647 (inclusive)]"
            },
            "Use surface condition function": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to use the 'Surface condition function' to determine surface conditions, or the 'Adiabatic surface temperature' and 'Surface pressure' parameters. If this is set to true the reference profile is updated every timestep. The function expression of the function should be independent of space, but can depend on time 't'. The function must return two components, the first one being reference surface pressure, the second one being reference surface temperature.",
                "pattern": "1290",
                "pattern_description": "[Bool]"
            },
            "Variable names": {
                "value": "x,t",
                "default_value": "x,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1285",
                "pattern_description": "[Anything]"
            },
            "Surface condition function": {
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "1293",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "0; 0",
                    "default_value": "0; 0",
                    "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                    "pattern": "1292",
                    "pattern_description": "[Anything]"
                },
                "Variable names": {
                    "value": "x,t",
                    "default_value": "x,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "1291",
                    "pattern_description": "[Anything]"
                }
            }
        },
        "Function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1296",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0.0; 0.0; 1.0",
                "default_value": "0.0; 0.0; 1.0",
                "documentation": "Expression for the adiabatic temperature, pressure, and density separated by semicolons as a function of `depth'.",
                "pattern": "1297",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "depth",
                "default_value": "depth",
                "documentation": "",
                "pattern": "1298",
                "pattern_description": "[Anything]"
            }
        }
    },
    "Boundary composition model": {
        "Allow fixed composition on outflow boundaries": {
            "value": "false for models without melt",
            "default_value": "false for models without melt",
            "documentation": "When the composition is fixed on a given boundary as determined by the list of 'Fixed composition boundary indicators', there might be parts of the boundary where material flows out and one may want to prescribe the composition only on those parts of the boundary where there is inflow. This parameter determines if compositions are only prescribed at these inflow parts of the boundary (if false) or everywhere on a given boundary, independent of the flow direction (if true). By default, this parameter is set to false, except in models with melt transport (see below). Note that in this context, `fixed' refers to the fact that these are the boundary indicators where Dirichlet boundary conditions are applied, and does not imply that the boundary composition is time-independent. \n\nMathematically speaking, the compositional fields satisfy an advection equation that has no diffusion. For this equation, one can only impose Dirichlet boundary conditions (i.e., prescribe a fixed compositional field value at the boundary) at those boundaries where material flows in. This would correspond to the ``false'' setting of this parameter, which is correspondingly the default. On the other hand, on a finite dimensional discretization such as the one one obtains from the finite element method, it is possible to also prescribe values on outflow boundaries, even though this may make no physical sense. This would then correspond to the ``true'' setting of this parameter. Note however that this parameter is only taken into account for the continuous field method and is not applied to the Discontinuous Galerkin (DG) field method. \n\nA warning for models with melt transport: In models with fluid flow, some compositional fields (in particular the porosity) might be transported with the fluid velocity, and would need to set the constraints based on the fluid velocity. However, this is currently not possible, because we reuse the same matrix for all compositional fields, and therefore can not use different constraints for different fields. Consequently, we set this parameter to true by default in models where melt transport is enabled. Be aware that if you change this default setting, you will not use the melt velocity, but the solid velocity to determine on which parts of the boundaries there is outflow.",
            "pattern": "1252",
            "pattern_description": "[Selection true|false|false for models without melt ]"
        },
        "Fixed composition boundary indicators": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list of names denoting those boundaries on which the composition is fixed and described by the boundary composition object selected in its own section of this input file. All boundary indicators used by the geometry but not explicitly listed here will end up with no-flux (insulating) boundary conditions.\n\nThe names of the boundaries listed here can either be numbers (in which case they correspond to the numerical boundary indicators assigned by the geometry object), or they can correspond to any of the symbolic names the geometry object may have provided for each part of the boundary. You may want to compare this with the documentation of the geometry model you use in your model.\n\nThis parameter only describes which boundaries have a fixed composition, but not what composition should hold on these boundaries. The latter piece of information needs to be implemented in a plugin in the BoundaryComposition group, unless an existing implementation in this group already provides what you want.",
            "pattern": "1251",
            "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
        },
        "List of model names": {
            "value": "",
            "default_value": "",
            "documentation": "A comma-separated list of boundary composition models that will be used to initialize the composition. These plugins are loaded in the order given, and modify the existing composition field via the operators listed in 'List of model operators'.\n\nThe following boundary composition models are available:\n\n`ascii data': Implementation of a model in which the boundary composition is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `composition1', `composition2', etc. in a 2d model and `x', `y', `composition1', `composition2', etc., in a 3d model, according to the number of compositional fields, which means that there has to be a single column for every composition in the model. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates.If you use a spherical model, then the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`box': A model in which the composition is chosen constant on the sides of a box which are selected by the parameters Left\/Right\/Top\/Bottom\/Front\/Back composition\n\n`box with lithosphere boundary indicators': A model in which the composition is chosen constant on all the sides of a box. Additional boundary indicators are added to the lithospheric parts of the vertical boundaries. This model is to be used with the 'Two Merged Boxes' Geometry Model.\n\n`function': Implementation of a model in which the boundary composition is given in terms of an explicit formula that is elaborated in the parameters in section ``Boundary composition model|Function''. \n\nSince the symbol $t$ indicating time may appear in the formulas for the prescribed composition, it is interpreted as having units seconds unless the global input parameter ``Use years in output instead of seconds'' is set, in which case we interpret the formula expressions as having units year.\n\nThe format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`initial composition': A model in which the composition at the boundary is chosen to be the same as given in the initial conditions.\n\nBecause this class simply takes what the initial composition had described, this class can not know certain pieces of information such as the minimal and maximal composition on the boundary. For operations that require this, for example in post-processing, this boundary composition model must therefore be told what the minimal and maximal values on the boundary are. This is done using parameters set in section ``Boundary composition model\/Initial composition''.\n\n`spherical constant': A model in which the composition is chosen constant on the inner and outer boundaries of a surface, spherical shell, chunk or ellipsoidal chunk. Parameters are read from subsection 'Spherical constant'.",
            "pattern": "1248",
            "pattern_description": "[MultipleSelection ascii data|box|box with lithosphere boundary indicators|function|initial composition|spherical constant ]"
        },
        "List of model operators": {
            "value": "add",
            "default_value": "add",
            "documentation": "A comma-separated list of operators that will be used to append the listed composition models onto the previous models. If only one operator is given, the same operator is applied to all models.",
            "pattern": "1249",
            "pattern_description": "[MultipleSelection add|subtract|minimum|maximum|replace if valid ]"
        },
        "Model name": {
            "value": "unspecified",
            "default_value": "unspecified",
            "documentation": "Select one of the following models:\n\n`ascii data': Implementation of a model in which the boundary composition is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `composition1', `composition2', etc. in a 2d model and `x', `y', `composition1', `composition2', etc., in a 3d model, according to the number of compositional fields, which means that there has to be a single column for every composition in the model. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates.If you use a spherical model, then the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`box': A model in which the composition is chosen constant on the sides of a box which are selected by the parameters Left\/Right\/Top\/Bottom\/Front\/Back composition\n\n`box with lithosphere boundary indicators': A model in which the composition is chosen constant on all the sides of a box. Additional boundary indicators are added to the lithospheric parts of the vertical boundaries. This model is to be used with the 'Two Merged Boxes' Geometry Model.\n\n`function': Implementation of a model in which the boundary composition is given in terms of an explicit formula that is elaborated in the parameters in section ``Boundary composition model|Function''. \n\nSince the symbol $t$ indicating time may appear in the formulas for the prescribed composition, it is interpreted as having units seconds unless the global input parameter ``Use years in output instead of seconds'' is set, in which case we interpret the formula expressions as having units year.\n\nThe format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`initial composition': A model in which the composition at the boundary is chosen to be the same as given in the initial conditions.\n\nBecause this class simply takes what the initial composition had described, this class can not know certain pieces of information such as the minimal and maximal composition on the boundary. For operations that require this, for example in post-processing, this boundary composition model must therefore be told what the minimal and maximal values on the boundary are. This is done using parameters set in section ``Boundary composition model\/Initial composition''.\n\n`spherical constant': A model in which the composition is chosen constant on the inner and outer boundaries of a surface, spherical shell, chunk or ellipsoidal chunk. Parameters are read from subsection 'Spherical constant'.\n\n\\textbf{Warning}: This parameter provides an old and deprecated way of specifying boundary composition models and shouldn't be used. Please use 'List of model names' instead.",
            "pattern": "1250",
            "pattern_description": "[Selection ascii data|box|box with lithosphere boundary indicators|function|initial composition|spherical constant|unspecified ]"
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/boundary-composition\/ascii-data\/test\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/boundary-composition\/ascii-data\/test\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1263",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "box_2d_%s.%d.txt",
                "default_value": "box_2d_%s.%d.txt",
                "documentation": "The file name of the model data. Provide file in format: (File name).\\%s\\%d, where \\%s is a string specifying the boundary of the model according to the names of the boundary indicators (of the chosen geometry model), and \\%d is any sprintf integer qualifier specifying the format of the current file number.",
                "pattern": "1266",
                "pattern_description": "[Anything]"
            },
            "Data file time step": {
                "value": "1e6",
                "default_value": "1e6",
                "documentation": "Time step between following data files. Depending on the setting of the global `Use years in output instead of seconds' flag in the input file, this number is either interpreted as seconds or as years. The default is one million, i.e., either one million seconds or one million years.",
                "pattern": "1267",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Decreasing file order": {
                "value": "false",
                "default_value": "false",
                "documentation": "In some cases the boundary files are not numbered in increasing but in decreasing order (e.g. `Ma BP'). If this flag is set to `True' the plugin will first load the file with the number `First data file number' and decrease the file number during the model run.",
                "pattern": "1270",
                "pattern_description": "[Bool]"
            },
            "First data file model time": {
                "value": "0",
                "default_value": "0",
                "documentation": "The `First data file model time' parameter has been deactivated and will be removed in a future release. Do not use this parameter and instead provide data files starting from the model start time.",
                "pattern": "1268",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "First data file number": {
                "value": "0",
                "default_value": "0",
                "documentation": "Number of the first velocity file to be loaded when the model time is larger than `First velocity file model time'.",
                "pattern": "1269",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1265",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Box": {
            "Bottom composition": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the bottom boundary (at minimal $y$-value in 2d, or minimal $z$-value in 3d). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1273",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Left composition": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the left boundary (at minimal $x$-value). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1271",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Right composition": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the right boundary (at maximal $x$-value). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1272",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Top composition": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the top boundary (at maximal $y$-value in 2d, or maximal $z$-value in 3d). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1274",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Box with lithosphere boundary indicators": {
            "Bottom composition": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the bottom boundary (at minimal $y$-value in 2d, or minimal $z$-value in 3d). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1261",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Left composition": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the left boundary (at minimal $x$-value). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1257",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Left composition lithosphere": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the left boundary (at minimal $x$-value). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1259",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Right composition": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the right boundary (at maximal $x$-value). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1258",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Right composition lithosphere": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the right boundary (at maximal $x$-value). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1260",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Top composition": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of composition boundary values at the top boundary (at maximal $y$-value in 2d, or maximal $z$-value in 3d). This list must have as many entries as there are compositional fields. Units: none.",
                "pattern": "1262",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Function": {
            "Coordinate system": {
                "value": "cartesian",
                "default_value": "cartesian",
                "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are 'cartesian', 'spherical', and 'depth'. 'spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. 'depth' will create a function, in which only the first parameter is non-zero, which is interpreted to be the depth of the point.",
                "pattern": "1275",
                "pattern_description": "[Selection cartesian|spherical|depth ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1278",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1277",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1276",
                "pattern_description": "[Anything]"
            }
        },
        "Initial composition": {
            "Maximal composition": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Maximal composition. Units: none.",
                "pattern": "1254",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Minimal composition": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Minimal composition. Units: none.",
                "pattern": "1253",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Spherical constant": {
            "Inner composition": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Composition at the inner boundary (core mantle boundary). Units: none.",
                "pattern": "1256",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Outer composition": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Composition at the outer boundary (lithosphere water\/air). For a spherical geometry model, this is the only boundary. Units: none.",
                "pattern": "1255",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        }
    },
    "Boundary fluid pressure model": {
        "Plugin name": {
            "value": "density",
            "default_value": "density",
            "documentation": "Select one of the following plugins:\n\n`density': A plugin that prescribes the fluid pressure gradient at the boundary based on fluid\/solid density from the material model.",
            "pattern": "103",
            "pattern_description": "[Selection density ]"
        },
        "Density": {
            "Density formulation": {
                "value": "solid density",
                "default_value": "solid density",
                "documentation": "The density formulation used to compute the fluid pressure gradient at the model boundary.\n\n`solid density' prescribes the gradient of the fluid pressure as solid density times gravity (which is the lithostatic pressure) and leads to approximately the same pressure in the melt as in the solid, so that fluid is only flowing in or out due to differences in dynamic pressure.\n\n`fluid density' prescribes the gradient of the fluid pressure as fluid density times gravity and causes melt to flow in with the same velocity as inflowing solid material, or no melt flowing in or out if the solid velocity normal to the boundary is zero.\n\n'average density' prescribes the gradient of the fluid pressure as the averaged fluid and solid density times gravity (which is a better approximation for the lithostatic pressure than just the solid density) and leads to approximately the same pressure in the melt as in the solid, so that fluid is only flowing in or out due to differences in dynamic pressure.",
                "pattern": "104",
                "pattern_description": "[Selection solid density|fluid density|average density ]"
            }
        }
    },
    "Boundary heat flux model": {
        "Fixed heat flux boundary indicators": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list of names denoting those boundaries on which the heat flux is fixed and described by the boundary heat flux object selected in the 'Model name' parameter. All boundary indicators used by the geometry but not explicitly listed here or in the list of 'Fixed temperature boundary indicators' in the 'Boundary temperature model' will end up with no-flux (insulating) boundary conditions.\n\nThe names of the boundaries listed here can either be numbers (in which case they correspond to the numerical boundary indicators assigned by the geometry object), or they can correspond to any of the symbolic names the geometry object may have provided for each part of the boundary. You may want to compare this with the documentation of the geometry model you use in your model.\n\nThis parameter only describes which boundaries have a fixed heat flux, but not what heat flux should hold on these boundaries. The latter piece of information needs to be implemented in a plugin in the BoundaryHeatFlux group, unless an existing implementation in this group already provides what you want.",
            "pattern": "50",
            "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
        },
        "Model name": {
            "value": "function",
            "default_value": "function",
            "documentation": "Select one of the following plugins:\n\n`function': Implementation of a model in which the boundary heat flux is given in terms of an explicit formula that is elaborated in the parameters in section ``Boundary heat flux model|Function''. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\nThe formula you describe in the mentioned section is a scalar value for the heat flux that is assumed to be the flux normal to the boundary, and that has the unit W\/(m$^2$) (in 3d) or W\/m (in 2d). Negative fluxes are interpreted as the flow of heat into the domain, and positive fluxes are interpreted as heat flowing out of the domain.\n\nThe symbol $t$ indicating time that may appear in the formulas for the prescribed heat flux is interpreted as having units seconds unless the global parameter ``Use years in output instead of seconds'' has been set.",
            "pattern": "1342",
            "pattern_description": "[Selection function ]"
        },
        "Function": {
            "Coordinate system": {
                "value": "cartesian",
                "default_value": "cartesian",
                "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `cartesian', `spherical', and `depth'. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. `depth' will create a function, in which only the first parameter is non-zero, which is interpreted to be the depth of the point.",
                "pattern": "1343",
                "pattern_description": "[Selection cartesian|spherical|depth ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1346",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1345",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1344",
                "pattern_description": "[Anything]"
            }
        }
    },
    "Boundary temperature model": {
        "Allow fixed temperature on outflow boundaries": {
            "value": "true",
            "default_value": "true",
            "documentation": "When the temperature is fixed on a given boundary as determined by the list of 'Fixed temperature boundary indicators', there might be parts of the boundary where material flows out and one may want to prescribe the temperature only on the parts of the boundary where there is inflow. This parameter determines if temperatures are only prescribed at these inflow parts of the boundary (if false) or everywhere on a given boundary, independent of the flow direction (if true).Note that in this context, `fixed' refers to the fact that these are the boundary indicators where Dirichlet boundary conditions are applied, and does not imply that the boundary temperature is time-independent. \n\nMathematically speaking, the temperature satisfies an advection-diffusion equation. For this type of equation, one can prescribe the temperature even on outflow boundaries as long as the diffusion coefficient is nonzero. This would correspond to the ``true'' setting of this parameter, which is correspondingly the default. In practice, however, this would only make physical sense if the diffusion coefficient is actually quite large to prevent the creation of a boundary layer. In addition, if there is no diffusion, one can only impose Dirichlet boundary conditions (i.e., prescribe a fixed temperature value at the boundary) at those boundaries where material flows in. This would correspond to the ``false'' setting of this parameter.",
            "pattern": "1188",
            "pattern_description": "[Bool]"
        },
        "Fixed temperature boundary indicators": {
            "value": "left, right, bottom, top",
            "default_value": "",
            "documentation": "A comma separated list of names denoting those boundaries on which the temperature is fixed and described by the boundary temperature object selected in the 'List of model names' parameter. All boundary indicators used by the geometry but not explicitly listed here will end up with no-flux (insulating) boundary conditions, or, if they are listed in the 'Fixed heat flux boundary indicators', with Neumann boundary conditions.\n\nThe names of the boundaries listed here can either be numbers (in which case they correspond to the numerical boundary indicators assigned by the geometry object), or they can correspond to any of the symbolic names the geometry object may have provided for each part of the boundary. You may want to compare this with the documentation of the geometry model you use in your model.\n\nThis parameter only describes which boundaries have a fixed temperature, but not what temperature should hold on these boundaries. The latter piece of information needs to be implemented in a plugin in the BoundaryTemperature group, unless an existing implementation in this group already provides what you want.",
            "pattern": "1187",
            "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
        },
        "List of model names": {
            "value": "constant",
            "default_value": "",
            "documentation": "A comma-separated list of boundary temperature models that will be used to initialize the temperature. These plugins are loaded in the order given, and modify the existing temperature field via the operators listed in 'List of model operators'.\n\nThe following boundary temperature models are available:\n\n`ascii data': Implementation of a model in which the boundary data is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `Temperature [K]' in a 2d model and  `x', `y', `Temperature [K]' in a 3d model, which means that there has to be a single column containing the temperature. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`box': A model in which the temperature is chosen constant on the sides of a box which are selected by the parameters Left\/Right\/Top\/Bottom\/Front\/Back temperature\n\n`box with lithosphere boundary indicators': A model in which the temperature is chosen constant on all the sides of a box. Additional boundary indicators are added to the lithospheric parts of the vertical boundaries. This model is to be used with the 'Two Merged Boxes' Geometry Model.\n\n`constant': A model in which the temperature is chosen constant on a given boundary indicator.  Parameters are read from the subsection 'Constant'.\n\n`dynamic core': This is a boundary temperature model working only with spherical shell geometry and core statistics postprocessor. The temperature at the top is constant, and the core mantle boundary temperature is dynamically evolving through time by calculating the heat flux into the core and solving the core energy balance. The formulation is mainly following \\cite{NPB+04}, and the plugin is used in Zhang et al. [2016]. The energy of core cooling and freeing of the inner core is included in the plugin. However, current plugin can not deal with the energy balance if the core is in the `snowing core' regime (i.e., the core solidifies from the top instead of bottom).\n\n`function': Implementation of a model in which the boundary temperature is given in terms of an explicit formula that is elaborated in the parameters in section ``Boundary temperature model|Function''. \n\nSince the symbol $t$ indicating time may appear in the formulas for the prescribed temperatures, it is interpreted as having units seconds unless the global input parameter ``Use years in output instead of seconds'' is set, in which case we interpret the formula expressions as having units year.\n\nBecause this class simply takes what the function calculates, this class can not know certain pieces of information such as the minimal and maximal temperature on the boundary. For operations that require this, for example in post-processing, this boundary temperature model must therefore be told what the minimal and maximal values on the boundary are. This is done using parameters set in section ``Boundary temperature model\/Initial temperature''.\n\nThe format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`initial temperature': A model in which the temperature at the boundary is chosen to be the same as given in the initial conditions.\n\nBecause this class simply takes what the initial temperature had described, this class can not know certain pieces of information such as the minimal and maximal temperature on the boundary. For operations that require this, for example in post-processing, this boundary temperature model must therefore be told what the minimal and maximal values on the boundary are. This is done using parameters set in section ``Boundary temperature model\/Initial temperature''.\n\n`spherical constant': A model in which the temperature is chosen constant on the inner and outer boundaries of a spherical shell, ellipsoidal chunk or chunk. Parameters are read from subsection 'Spherical constant'.",
            "pattern": "1184",
            "pattern_description": "[MultipleSelection ascii data|box|box with lithosphere boundary indicators|constant|dynamic core|function|initial temperature|spherical constant ]"
        },
        "List of model operators": {
            "value": "add",
            "default_value": "add",
            "documentation": "A comma-separated list of operators that will be used to append the listed temperature models onto the previous models. If only one operator is given, the same operator is applied to all models.",
            "pattern": "1185",
            "pattern_description": "[MultipleSelection add|subtract|minimum|maximum|replace if valid ]"
        },
        "Model name": {
            "value": "unspecified",
            "default_value": "unspecified",
            "documentation": "Select one of the following models:\n\n`ascii data': Implementation of a model in which the boundary data is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `Temperature [K]' in a 2d model and  `x', `y', `Temperature [K]' in a 3d model, which means that there has to be a single column containing the temperature. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`box': A model in which the temperature is chosen constant on the sides of a box which are selected by the parameters Left\/Right\/Top\/Bottom\/Front\/Back temperature\n\n`box with lithosphere boundary indicators': A model in which the temperature is chosen constant on all the sides of a box. Additional boundary indicators are added to the lithospheric parts of the vertical boundaries. This model is to be used with the 'Two Merged Boxes' Geometry Model.\n\n`constant': A model in which the temperature is chosen constant on a given boundary indicator.  Parameters are read from the subsection 'Constant'.\n\n`dynamic core': This is a boundary temperature model working only with spherical shell geometry and core statistics postprocessor. The temperature at the top is constant, and the core mantle boundary temperature is dynamically evolving through time by calculating the heat flux into the core and solving the core energy balance. The formulation is mainly following \\cite{NPB+04}, and the plugin is used in Zhang et al. [2016]. The energy of core cooling and freeing of the inner core is included in the plugin. However, current plugin can not deal with the energy balance if the core is in the `snowing core' regime (i.e., the core solidifies from the top instead of bottom).\n\n`function': Implementation of a model in which the boundary temperature is given in terms of an explicit formula that is elaborated in the parameters in section ``Boundary temperature model|Function''. \n\nSince the symbol $t$ indicating time may appear in the formulas for the prescribed temperatures, it is interpreted as having units seconds unless the global input parameter ``Use years in output instead of seconds'' is set, in which case we interpret the formula expressions as having units year.\n\nBecause this class simply takes what the function calculates, this class can not know certain pieces of information such as the minimal and maximal temperature on the boundary. For operations that require this, for example in post-processing, this boundary temperature model must therefore be told what the minimal and maximal values on the boundary are. This is done using parameters set in section ``Boundary temperature model\/Initial temperature''.\n\nThe format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`initial temperature': A model in which the temperature at the boundary is chosen to be the same as given in the initial conditions.\n\nBecause this class simply takes what the initial temperature had described, this class can not know certain pieces of information such as the minimal and maximal temperature on the boundary. For operations that require this, for example in post-processing, this boundary temperature model must therefore be told what the minimal and maximal values on the boundary are. This is done using parameters set in section ``Boundary temperature model\/Initial temperature''.\n\n`spherical constant': A model in which the temperature is chosen constant on the inner and outer boundaries of a spherical shell, ellipsoidal chunk or chunk. Parameters are read from subsection 'Spherical constant'.\n\n\\textbf{Warning}: This parameter provides an old and deprecated way of specifying boundary temperature models and shouldn't be used. Please use 'List of model names' instead.",
            "pattern": "1186",
            "pattern_description": "[Selection ascii data|box|box with lithosphere boundary indicators|constant|dynamic core|function|initial temperature|spherical constant|unspecified ]"
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/boundary-temperature\/ascii-data\/test\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/boundary-temperature\/ascii-data\/test\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1195",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "box_2d_%s.%d.txt",
                "default_value": "box_2d_%s.%d.txt",
                "documentation": "The file name of the model data. Provide file in format: (File name).\\%s\\%d, where \\%s is a string specifying the boundary of the model according to the names of the boundary indicators (of the chosen geometry model), and \\%d is any sprintf integer qualifier specifying the format of the current file number.",
                "pattern": "1198",
                "pattern_description": "[Anything]"
            },
            "Data file time step": {
                "value": "1e6",
                "default_value": "1e6",
                "documentation": "Time step between following data files. Depending on the setting of the global `Use years in output instead of seconds' flag in the input file, this number is either interpreted as seconds or as years. The default is one million, i.e., either one million seconds or one million years.",
                "pattern": "1199",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Decreasing file order": {
                "value": "false",
                "default_value": "false",
                "documentation": "In some cases the boundary files are not numbered in increasing but in decreasing order (e.g. `Ma BP'). If this flag is set to `True' the plugin will first load the file with the number `First data file number' and decrease the file number during the model run.",
                "pattern": "1202",
                "pattern_description": "[Bool]"
            },
            "First data file model time": {
                "value": "0",
                "default_value": "0",
                "documentation": "The `First data file model time' parameter has been deactivated and will be removed in a future release. Do not use this parameter and instead provide data files starting from the model start time.",
                "pattern": "1200",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "First data file number": {
                "value": "0",
                "default_value": "0",
                "documentation": "Number of the first velocity file to be loaded when the model time is larger than `First velocity file model time'.",
                "pattern": "1201",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1197",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Box": {
            "Bottom temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the bottom boundary (at minimal $z$-value). Units: \\si{\\kelvin}.",
                "pattern": "1205",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Left temperature": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Temperature at the left boundary (at minimal $x$-value). Units: \\si{\\kelvin}.",
                "pattern": "1203",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Right temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the right boundary (at maximal $x$-value). Units: \\si{\\kelvin}.",
                "pattern": "1204",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Top temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the top boundary (at maximal $x$-value). Units: \\si{\\kelvin}.",
                "pattern": "1206",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Box with lithosphere boundary indicators": {
            "Bottom temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the bottom boundary (at minimal $z$-value). Units: \\si{\\kelvin}.",
                "pattern": "1191",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Left temperature": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Temperature at the left boundary (at minimal $x$-value). Units: \\si{\\kelvin}.",
                "pattern": "1189",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Left temperature lithosphere": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the additional left lithosphere boundary (specified by user in Geometry Model). Units: \\si{\\kelvin}.",
                "pattern": "1193",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Right temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the right boundary (at maximal $x$-value). Units: \\si{\\kelvin}.",
                "pattern": "1190",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Right temperature lithosphere": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the additional right lithosphere boundary (specified by user in Geometry Model). Units: \\si{\\kelvin}.",
                "pattern": "1194",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Top temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the top boundary (at maximal $x$-value). Units: \\si{\\kelvin}.",
                "pattern": "1192",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Constant": {
            "Boundary indicator to temperature mappings": {
                "value": "left:0, right:0, bottom:0, top:0",
                "default_value": "",
                "documentation": "A comma separated list of mappings between boundary indicators and the temperature associated with the boundary indicators. The format for this list is ``indicator1 : value1, indicator2 : value2, ...'', where each indicator is a valid boundary indicator (either a number or the symbolic name of a boundary as provided by the geometry model) and each value is the temperature of that boundary.",
                "pattern": "1207",
                "pattern_description": "[Map of <[Anything]>:<[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Dynamic core": {
            "Alpha": {
                "value": "1.35e-5",
                "default_value": "1.35e-5",
                "documentation": "Core thermal expansivity. Units: \\si{\\per\\kelvin}.",
                "pattern": "1221",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Beta composition": {
                "value": "1.1",
                "default_value": "1.1",
                "documentation": "Compositional expansion coefficient $Beta_c$. See \\cite{NPB+04} for more details.",
                "pattern": "1224",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "CMB pressure": {
                "value": "0.14e12",
                "default_value": "0.14e12",
                "documentation": "Pressure at CMB. Units: \\si{\\pascal}.",
                "pattern": "1215",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Core conductivity": {
                "value": "60.",
                "default_value": "60.",
                "documentation": "Core heat conductivity $k_c$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "1226",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Core density": {
                "value": "12.5e3",
                "default_value": "12.5e3",
                "documentation": "Density of the core. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "1213",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Core heat capacity": {
                "value": "840.",
                "default_value": "840.",
                "documentation": "Heat capacity of the core. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "1218",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Delta": {
                "value": "0.5",
                "default_value": "0.5",
                "documentation": "Partition coefficient of the light element.",
                "pattern": "1225",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "Gravity acceleration": {
                "value": "9.8",
                "default_value": "9.8",
                "documentation": "Gravitation acceleration at CMB. Units: \\si{\\meter\\per\\second\\squared}.",
                "pattern": "1214",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Initial light composition": {
                "value": "0.01",
                "default_value": "0.01",
                "documentation": "Initial light composition (eg. S,O) concentration in weight fraction.",
                "pattern": "1216",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Inner temperature": {
                "value": "6000.",
                "default_value": "6000.",
                "documentation": "Temperature at the inner boundary (core mantle boundary) at the beginning. Units: \\si{\\kelvin}.",
                "pattern": "1209",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "K0": {
                "value": "4.111e11",
                "default_value": "4.111e11",
                "documentation": "Core compressibility at zero pressure. See \\cite{NPB+04} for more details.",
                "pattern": "1219",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Lh": {
                "value": "750e3",
                "default_value": "750e3",
                "documentation": "The latent heat of core freeze. Units: \\si{\\joule\\per\\kilogram}.",
                "pattern": "1222",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Max iteration": {
                "value": "30000",
                "default_value": "30000",
                "documentation": "The max iterations for nonlinear core energy solver.",
                "pattern": "1217",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Outer temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the outer boundary (lithosphere water\/air). Units: \\si{\\kelvin}.",
                "pattern": "1208",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Rh": {
                "value": "-27.7e6",
                "default_value": "-27.7e6",
                "documentation": "The heat of reaction. Units: \\si{\\joule\\per\\kilogram}.",
                "pattern": "1223",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Rho0": {
                "value": "7.019e3",
                "default_value": "7.019e3",
                "documentation": "Core density at zero pressure. Units: \\si{\\kilogram\\per\\meter\\cubed}. See \\cite{NPB+04} for more details.",
                "pattern": "1220",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "dR over dt": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Initial inner core radius changing rate. Units: \\si{\\kilo\\meter}\/year.",
                "pattern": "1211",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "dT over dt": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Initial CMB temperature changing rate. Units: \\si{\\kelvin}\/year.",
                "pattern": "1210",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "dX over dt": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Initial light composition changing rate. Units: 1\/year.",
                "pattern": "1212",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Geotherm parameters": {
                "Composition dependency": {
                    "value": "true",
                    "default_value": "true",
                    "documentation": "If melting curve dependent on composition.",
                    "pattern": "1231",
                    "pattern_description": "[Bool]"
                },
                "Theta": {
                    "value": "0.11",
                    "default_value": "0.11",
                    "documentation": "Melting curve (\\cite{NPB+04} eq. (40)) parameter Theta.",
                    "pattern": "1230",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "Tm0": {
                    "value": "1695.",
                    "default_value": "1695.",
                    "documentation": "Melting curve (\\cite{NPB+04} eq. (40)) parameter Tm0. Units: \\si{\\kelvin}.",
                    "pattern": "1227",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Tm1": {
                    "value": "10.9",
                    "default_value": "10.9",
                    "documentation": "Melting curve (\\cite{NPB+04} eq. (40)) parameter Tm1. Units: \\si{\\per\\tera\\pascal}.",
                    "pattern": "1228",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "Tm2": {
                    "value": "-8.0",
                    "default_value": "-8.0",
                    "documentation": "Melting curve (\\cite{NPB+04} eq. (40)) parameter Tm2. Units: \\si{\\per\\tera\\pascal\\squared}.",
                    "pattern": "1229",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "Use BW11": {
                    "value": "false",
                    "default_value": "false",
                    "documentation": "If using the Fe-FeS system solidus from Buono \\& Walker (2011) instead.",
                    "pattern": "1232",
                    "pattern_description": "[Bool]"
                }
            },
            "Other energy source": {
                "File name": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Data file name for other energy source into the core. The 'other energy source' is used for external core energy source.For example if someone want to test the early lunar core powered by precession (Dwyer, C. A., et al. (2011). A long-lived lunar dynamo driven by continuous mechanical stirring. Nature 479(7372): 212-214.)Format [Time(Gyr)   Energy rate(W)]",
                    "pattern": "1237",
                    "pattern_description": "[Anything]"
                }
            },
            "Radioactive heat source": {
                "Half life times": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Half decay times of different elements (Ga)",
                    "pattern": "1235",
                    "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
                },
                "Heating rates": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Heating rates of different elements (W\/kg)",
                    "pattern": "1234",
                    "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
                },
                "Initial concentrations": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Initial concentrations of different elements (ppm)",
                    "pattern": "1236",
                    "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
                },
                "Number of radioactive heating elements": {
                    "value": "0",
                    "default_value": "0",
                    "documentation": "Number of different radioactive heating elements in core",
                    "pattern": "1233",
                    "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
                }
            }
        },
        "Function": {
            "Coordinate system": {
                "value": "cartesian",
                "default_value": "cartesian",
                "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `cartesian', `spherical', and `depth'. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. `depth' will create a function, in which only the first parameter is non-zero, which is interpreted to be the depth of the point.",
                "pattern": "1238",
                "pattern_description": "[Selection cartesian|spherical|depth ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1241",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1240",
                "pattern_description": "[Anything]"
            },
            "Maximal temperature": {
                "value": "3773.",
                "default_value": "3773.",
                "documentation": "Maximal temperature. Units: \\si{\\kelvin}.",
                "pattern": "1243",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Minimal temperature": {
                "value": "273.",
                "default_value": "273.",
                "documentation": "Minimal temperature. Units: \\si{\\kelvin}.",
                "pattern": "1242",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1239",
                "pattern_description": "[Anything]"
            }
        },
        "Initial temperature": {
            "Maximal temperature": {
                "value": "3773.",
                "default_value": "3773.",
                "documentation": "Maximal temperature. Units: \\si{\\kelvin}.",
                "pattern": "1245",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Minimal temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Minimal temperature. Units: \\si{\\kelvin}.",
                "pattern": "1244",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Spherical constant": {
            "Inner temperature": {
                "value": "6000.",
                "default_value": "6000.",
                "documentation": "Temperature at the inner boundary (core mantle boundary). Units: \\si{\\kelvin}.",
                "pattern": "1247",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Outer temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Temperature at the outer boundary (lithosphere water\/air). Units: \\si{\\kelvin}.",
                "pattern": "1246",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        }
    },
    "Boundary traction model": {
        "Prescribed traction boundary indicators": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list denoting those boundaries on which the traction is prescribed, i.e., where unknown external forces act to prescribe a particular traction. This is often used to prescribe a traction that equals that of overlying plates.\n\nThe format of valid entries for this parameter is that of a map given as ``key1 [selector]: value1, key2 [selector]: value2, key3: value3, ...'' where each key must be a valid boundary indicator (which is either an integer or the symbolic name the geometry model in use may have provided for this part of the boundary) and each value must be one of the currently implemented boundary traction models. ``selector'' is an optional string given as a subset of the letters `xyz' that allows you to apply the boundary conditions only to the components listed. As an example, '1 y: function' applies the type `function' to the y component on boundary 1. Without a selector it will affect all components of the traction.\n\nNote that traction should be given in N\/m^2. The following boundary traction models are available:\n\n`ascii data': Implementation of a model in which the boundary traction is derived from files containing pressure data in ascii format. The pressure given in the data file is applied as traction normal to the surface of a given boundary, pointing inwards. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `Pressure [Pa]' in a 2d model and  `x', `y', `Pressure [Pa]' in a 3d model, which means that there has to be a single column containing the pressure. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the data will still be handled as Cartesian, however the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`function': Implementation of a model in which the boundary traction is given in terms of an explicit formula that is elaborated in the parameters in section ``Boundary traction model|Function''. \n\nThe formula you describe in the mentioned section is a semicolon separated list of traction components for each of the $d$ components of the traction vector. These $d$ formulas are interpreted as having units Pa.\n\n`initial lithostatic pressure': Implementation of a model in which the boundary traction is given in terms of a normal traction component set to the lithostatic pressure calculated according to the parameters in section ``Boundary traction model|Lithostatic pressure''. \n\nThe lithostatic pressure is calculated by integrating the pressure downward based on the initial composition and temperature along the user-specified depth profile. The user-specified profile is given in terms of a point in cartesian coordinates for box geometries and in spherical coordinates for all other geometries (radius, longitude, latitude), and the number of integration points. The lateral coordinates of the point are used to calculate the lithostatic pressure profile with depth. This means that the depth coordinate is not used. Note that when initial topography is included, the initial topography at the user-provided representative point is used to compute the profile. If at other points the (initial) topography is higher, the behavior of this plugin at later timesteps depends on the domain geometry. The depth returned by the geometry model does (box geometries) or does not (spherical geometries) include the initial topography. This depth is used to interpolate between the points of the reference pressure profile. Depths outside the reference profile get returned the pressure value of the closest profile depth. \n\nGravity is expected to point along the depth direction. \n\n`zero traction': Implementation of a model in which the boundary traction is zero. This is commonly referred to as an ``open boundary condition'', indicating that the material experiences no forces in response to what might exist on the other side of the boundary. However, this is only true in the case where hydrostatic pressure is not relevant. If hydrostatic pressure is not negligible, for example at the sides of a regional model, the material at the other side of the boundary does exceed a force, namely the force normal to the boundary induced by the hydrostatic pressure.",
            "pattern": "1326",
            "pattern_description": "[Map of <[Anything]>:<[Selection ascii data|function|initial lithostatic pressure|zero traction ]> of length 0...4294967295 (inclusive)]"
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/boundary-traction\/ascii-data\/test\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/boundary-traction\/ascii-data\/test\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1327",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "box_2d_%s.%d.txt",
                "default_value": "box_2d_%s.%d.txt",
                "documentation": "The file name of the model data. Provide file in format: (File name).\\%s\\%d, where \\%s is a string specifying the boundary of the model according to the names of the boundary indicators (of the chosen geometry model), and \\%d is any sprintf integer qualifier specifying the format of the current file number.",
                "pattern": "1330",
                "pattern_description": "[Anything]"
            },
            "Data file time step": {
                "value": "1e6",
                "default_value": "1e6",
                "documentation": "Time step between following data files. Depending on the setting of the global `Use years in output instead of seconds' flag in the input file, this number is either interpreted as seconds or as years. The default is one million, i.e., either one million seconds or one million years.",
                "pattern": "1331",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Decreasing file order": {
                "value": "false",
                "default_value": "false",
                "documentation": "In some cases the boundary files are not numbered in increasing but in decreasing order (e.g. `Ma BP'). If this flag is set to `True' the plugin will first load the file with the number `First data file number' and decrease the file number during the model run.",
                "pattern": "1334",
                "pattern_description": "[Bool]"
            },
            "First data file model time": {
                "value": "0",
                "default_value": "0",
                "documentation": "The `First data file model time' parameter has been deactivated and will be removed in a future release. Do not use this parameter and instead provide data files starting from the model start time.",
                "pattern": "1332",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "First data file number": {
                "value": "0",
                "default_value": "0",
                "documentation": "Number of the first velocity file to be loaded when the model time is larger than `First velocity file model time'.",
                "pattern": "1333",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1329",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Function": {
            "Coordinate system": {
                "value": "cartesian",
                "default_value": "cartesian",
                "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `cartesian', `spherical', and `depth'. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. `depth' will create a function, in which only the first parameter is non-zero, which is interpreted to be the depth of the point.",
                "pattern": "1335",
                "pattern_description": "[Selection cartesian|spherical|depth ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1339",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0; 0",
                "default_value": "0; 0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1338",
                "pattern_description": "[Anything]"
            },
            "Use spherical unit vectors": {
                "value": "false",
                "default_value": "false",
                "documentation": "Specify traction as $r$, $\\phi$, and $\\theta$ components instead of $x$, $y$, and $z$. Positive tractions point up, east, and north (in 3d) or out and clockwise (in 2d). This setting only makes sense for spherical geometries.",
                "pattern": "1336",
                "pattern_description": "[Bool]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1337",
                "pattern_description": "[Anything]"
            }
        },
        "Initial lithostatic pressure": {
            "Number of integration points": {
                "value": "1000",
                "default_value": "1000",
                "documentation": "The number of integration points over which we integrate the lithostatic pressure downwards.",
                "pattern": "1341",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Representative point": {
                "value": "",
                "default_value": "",
                "documentation": "The point where the pressure profile will be calculated. Cartesian coordinates $(x,y,z)$ when geometry is a box, otherwise enter radius, longitude, and in 3d latitude. Note that the coordinate related to the depth ($y$ in 2d cartesian, $z$ in 3d cartesian and radius in spherical coordinates) is not used. Units: \\si{\\meter} or degrees.",
                "pattern": "1340",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        }
    },
    "Boundary velocity model": {
        "Prescribed velocity boundary indicators": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list denoting those boundaries on which the velocity is prescribed, i.e., where unknown external forces act to prescribe a particular velocity. This is often used to prescribe a velocity that equals that of overlying plates.\n\nThe format of valid entries for this parameter is that of a map given as ``key1 [selector]: value1, key2 [selector]: value2, key3: value3, ...'' where each key must be a valid boundary indicator (which is either an integer or the symbolic name the geometry model in use may have provided for this part of the boundary) and each value must be one of the currently implemented boundary velocity models. ``selector'' is an optional string given as a subset of the letters `xyz' that allows you to apply the boundary conditions only to the components listed. As an example, '1 y: function' applies the type `function' to the y component on boundary 1. Without a selector it will affect all components of the velocity.\n\nNote that the no-slip boundary condition is a special case of the current one where the prescribed velocity happens to be zero. It can thus be implemented by indicating that a particular boundary is part of the ones selected using the current parameter and using ``zero velocity'' as the boundary values. Alternatively, you can simply list the part of the boundary on which the velocity is to be zero with the parameter ``Zero velocity boundary indicator'' in the current parameter section.\n\nNote that when ``Use years in output instead of seconds'' is set to true, velocity should be given in m\/yr. The following boundary velocity models are available:\n\n`ascii data': Implementation of a model in which the boundary velocity is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `velocity${}_x$', `velocity${}_y$' in a 2d model or `x', `y', `velocity${}_x$', `velocity${}_y$', `velocity${}_z$' in a 3d model. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates.If you use a spherical model, then the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions. Velocities can be specified using cartesian (by default) or spherical unit vectors. No matter which geometry model is chosen, the unit of the velocities is assumed to be m\/s or m\/yr depending on the `Use years in output instead of seconds' flag. If you provide velocities in cm\/yr, set the `Scale factor' option to 0.01.\n\n`function': Implementation of a model in which the boundary velocity is given in terms of an explicit formula that is elaborated in the parameters in section ``Boundary velocity model|Function''. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\nThe formula you describe in the mentioned section is a semicolon separated list of velocities for each of the $d$ components of the velocity vector. These $d$ formulas are interpreted as having units m\/s, unless the global input parameter ``Use years in output instead of seconds'' is set, in which case we interpret the formula expressions as having units m\/year.\n\nLikewise, since the symbol $t$ indicating time may appear in the formulas for the prescribed velocities, it is interpreted as having units seconds unless the global parameter above has been set.\n\n`gplates': Implementation of a model in which the boundary velocity is derived from files that are generated by the GPlates program.\n\n`zero velocity': Implementation of a model in which the boundary velocity is zero. This is commonly referred to as a ``stick boundary condition'', indicating that the material ``sticks'' to the material on the other side of the boundary.",
            "pattern": "1299",
            "pattern_description": "[Map of <[Anything]>:<[Selection ascii data|function|gplates|zero velocity ]> of length 0...4294967295 (inclusive)]"
        },
        "Tangential velocity boundary indicators": {
            "value": "left, right, bottom",
            "default_value": "",
            "documentation": "A comma separated list of names denoting those boundaries on which the velocity is tangential and unrestrained, i.e., free-slip where no external forces act to prescribe a particular tangential velocity (although there is a force that requires the flow to be tangential).\n\nThe names of the boundaries listed here can either by numbers (in which case they correspond to the numerical boundary indicators assigned by the geometry object), or they can correspond to any of the symbolic names the geometry object may have provided for each part of the boundary. You may want to compare this with the documentation of the geometry model you use in your model.",
            "pattern": "1301",
            "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
        },
        "Zero velocity boundary indicators": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list of names denoting those boundaries on which the velocity is zero.\n\nThe names of the boundaries listed here can either by numbers (in which case they correspond to the numerical boundary indicators assigned by the geometry object), or they can correspond to any of the symbolic names the geometry object may have provided for each part of the boundary. You may want to compare this with the documentation of the geometry model you use in your model.",
            "pattern": "1300",
            "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/boundary-velocity\/ascii-data\/test\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/boundary-velocity\/ascii-data\/test\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1312",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "box_2d_%s.%d.txt",
                "default_value": "box_2d_%s.%d.txt",
                "documentation": "The file name of the model data. Provide file in format: (File name).\\%s\\%d, where \\%s is a string specifying the boundary of the model according to the names of the boundary indicators (of the chosen geometry model), and \\%d is any sprintf integer qualifier specifying the format of the current file number.",
                "pattern": "1315",
                "pattern_description": "[Anything]"
            },
            "Data file time step": {
                "value": "1e6",
                "default_value": "1e6",
                "documentation": "Time step between following data files. Depending on the setting of the global `Use years in output instead of seconds' flag in the input file, this number is either interpreted as seconds or as years. The default is one million, i.e., either one million seconds or one million years.",
                "pattern": "1316",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Decreasing file order": {
                "value": "false",
                "default_value": "false",
                "documentation": "In some cases the boundary files are not numbered in increasing but in decreasing order (e.g. `Ma BP'). If this flag is set to `True' the plugin will first load the file with the number `First data file number' and decrease the file number during the model run.",
                "pattern": "1319",
                "pattern_description": "[Bool]"
            },
            "First data file model time": {
                "value": "0",
                "default_value": "0",
                "documentation": "The `First data file model time' parameter has been deactivated and will be removed in a future release. Do not use this parameter and instead provide data files starting from the model start time.",
                "pattern": "1317",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "First data file number": {
                "value": "0",
                "default_value": "0",
                "documentation": "Number of the first velocity file to be loaded when the model time is larger than `First velocity file model time'.",
                "pattern": "1318",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1314",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Use spherical unit vectors": {
                "value": "false",
                "default_value": "false",
                "documentation": "Specify velocity as r, phi, and theta components instead of x, y, and z. Positive velocities point up, east, and north (in 3d) or out and clockwise (in 2d). This setting only makes sense for spherical geometries.",
                "pattern": "1320",
                "pattern_description": "[Bool]"
            }
        },
        "Function": {
            "Coordinate system": {
                "value": "cartesian",
                "default_value": "cartesian",
                "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `cartesian', `spherical', and `depth'. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. `depth' will create a function, in which only the first parameter is non-zero, which is interpreted to be the depth of the point.",
                "pattern": "1321",
                "pattern_description": "[Selection cartesian|spherical|depth ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1325",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0; 0",
                "default_value": "0; 0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1324",
                "pattern_description": "[Anything]"
            },
            "Use spherical unit vectors": {
                "value": "false",
                "default_value": "false",
                "documentation": "Specify velocity as $r$, $\\phi$, and $\\theta$ components instead of $x$, $y$, and $z$. Positive velocities point up, east, and north (in 3d) or out and clockwise (in 2d). This setting only makes sense for spherical geometries.",
                "pattern": "1322",
                "pattern_description": "[Bool]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1323",
                "pattern_description": "[Anything]"
            }
        },
        "GPlates model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/boundary-velocity\/gplates\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/boundary-velocity\/gplates\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a '\/') or relative to the current directory. The path may also include the special text '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT. ",
                "pattern": "1302",
                "pattern_description": "[DirectoryName]"
            },
            "Data file time step": {
                "value": "1e6",
                "default_value": "1e6",
                "documentation": "Time step between following velocity files. Depending on the setting of the global 'Use years in output instead of seconds' flag in the input file, this number is either interpreted as seconds or as years. The default is one million, i.e., either one million seconds or one million years.",
                "pattern": "1307",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Decreasing file order": {
                "value": "false",
                "default_value": "false",
                "documentation": "In some cases the boundary files are not numbered in increasing but in decreasing order (e.g. 'Ma BP'). If this flag is set to 'True' the plugin will first load the file with the number 'First velocity file number' and decrease the file number during the model run.",
                "pattern": "1306",
                "pattern_description": "[Bool]"
            },
            "First data file model time": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Time from which on the velocity file with number 'First velocity file number' is used as boundary condition. Previous to this time, a no-slip boundary condition is assumed. Depending on the setting of the global 'Use years in output instead of seconds' flag in the input file, this number is either interpreted as seconds or as years.",
                "pattern": "1304",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "First data file number": {
                "value": "0",
                "default_value": "0",
                "documentation": "Number of the first velocity file to be loaded when the model time is larger than 'First velocity file model time'.",
                "pattern": "1305",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            },
            "Lithosphere thickness": {
                "value": "100000.",
                "default_value": "100000.",
                "documentation": "Determines the depth of the lithosphere, so that the GPlates velocities can be applied at the sides of the model as well as at the surface.",
                "pattern": "1311",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Point one": {
                "value": "1.570796,0.0",
                "default_value": "1.570796,0.0",
                "documentation": "Point that determines the plane in which a 2d model lies in. Has to be in the format `a,b' where a and b are theta (polar angle) and phi in radians. This value is not utilized in 3d geometries, and can therefore be set to the default or any user-defined quantity.",
                "pattern": "1309",
                "pattern_description": "[Anything]"
            },
            "Point two": {
                "value": "1.570796,1.570796",
                "default_value": "1.570796,1.570796",
                "documentation": "Point that determines the plane in which a 2d model lies in. Has to be in the format `a,b' where a and b are theta (polar angle) and phi in radians. This value is not utilized in 3d geometries, and can therefore be set to the default or any user-defined quantity.",
                "pattern": "1310",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the boundary velocity. You might want to use this to scale the velocities to a reference model (e.g. with free-slip boundary) or another plate reconstruction.",
                "pattern": "1308",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Velocity file name": {
                "value": "phi.%d",
                "default_value": "phi.%d",
                "documentation": "The file name of the material data. Provide file in format: (Velocity file name).\\%d.gpml where \\%d is any sprintf integer qualifier, specifying the format of the current file number.",
                "pattern": "1303",
                "pattern_description": "[Anything]"
            }
        }
    },
    "Checkpointing": {
        "Steps between checkpoint": {
            "value": "0",
            "default_value": "0",
            "documentation": "The number of timesteps between performing checkpoints. If 0 and time between checkpoint is not specified, checkpointing will not be performed. Units: None.",
            "pattern": "65",
            "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
        },
        "Time between checkpoint": {
            "value": "0",
            "default_value": "0",
            "documentation": "The wall time between performing checkpoints. If 0, will use the checkpoint step frequency instead. Units: Seconds.",
            "pattern": "64",
            "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
        }
    },
    "Compositional fields": {
        "Compositional field methods": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list denoting the solution method of each compositional field. Each entry of the list must be one of the currently implemented field methods.\n\nThese choices correspond to the following methods by which compositional fields gain their values:\\begin{itemize}\\item ``field'': If a compositional field is marked with this method, then its values are computed in each time step by advecting along the values of the previous time step using the velocity field, and applying reaction rates to it. In other words, this corresponds to the usual notion of a composition field as mentioned in Section~\\ref{sec:compositional}. \n\\item ``particles'': If a compositional field is marked with this method, then its values are obtained in each time step by interpolating the corresponding properties from the particles located on each cell. The time evolution therefore happens because particles move along with the velocity field, and particle properties can react with each other as well. See Section~\\ref{sec:particles} for more information about how particles behave.\n\\item ``volume of fluid``: If a compositional field is marked with this method, then its values are obtained in each timestep by reconstructing a polynomial finite element approximation on each cell from a volume of fluid interface tracking method, which is used to compute the advection updates.\n\\item ``static'': If a compositional field is marked this way, then it does not evolve at all. Its values are simply set to the initial conditions, and will then never change.\n\\item ``melt field'': If a compositional field is marked with this method, then its values are computed in each time step by advecting along the values of the previous time step using the melt velocity, and applying reaction rates to it. In other words, this corresponds to the usual notion of a composition field as mentioned in Section~\\ref{sec:compositional}, except that it is advected with the melt velocity instead of the solid velocity. This method can only be chosen if melt transport is active in the model.\n\\item ``darcy field'': If a compositional field is marked with this method, then its values are computed in each time step by advecting along the values of the previous time step using the fluid velocity prescribed by Darcy's Law, and applying reaction rates to it. In other words this corresponds to the usual notion of a composition field as mentioned in Section~\\ref{sec:compositional}, except that it is advected with the Darcy velocity instead of the solid velocity. This method requires there to be a compositional field named porosity that is advected the darcy field method. We calculate the fluid velocity $u_f$ using an approximation of Darcy's Law: $u_f = u_s - K_D \/ \\phi * (rho_s * g - rho_f * g)$.\n\\item ``prescribed field'': The value of these fields is determined in each time step from the material model. If a compositional field is marked with this method, then the value of a specific additional material model output, called the `PrescribedFieldOutputs' is interpolated onto the field. This field does not change otherwise, it is not advected with the flow.\n\\item ``prescribed field with diffusion'': If a compositional field is marked this way, the value of a specific additional material model output, called the `PrescribedFieldOutputs' is interpolated onto the field, as in the ``prescribed field'' method. Afterwards, the field is diffused based on a solver parameter, the diffusion length scale, smoothing the field. Specifically, the field is updated by solving the equation $(I-l^2 \\Delta) C_\\text{smoothed} = C_\\text{prescribed}$, where $l$ is the diffusion length scale. Note that this means that the amount of diffusion is independent of the time step size, and that the field is not advected with the flow.\\end{itemize}",
            "pattern": "91",
            "pattern_description": "[List of <[Selection field|particles|volume of fluid|static|melt field|darcy field|prescribed field|prescribed field with diffusion ]> of length 0...4294967295 (inclusive)]"
        },
        "List of normalized fields": {
            "value": "",
            "default_value": "",
            "documentation": "A list of integers smaller than or equal to the number of compositional fields. All compositional fields in this list will be normalized before the first timestep. The normalization is implemented in the following way: First, the sum of the fields to be normalized is calculated at every point and the global maximum is determined. Second, the compositional fields to be normalized are divided by this maximum.",
            "pattern": "93",
            "pattern_description": "[List of <[Integer range 0...2147483647 (inclusive)]> of length 0...4294967295 (inclusive)]"
        },
        "Mapped particle properties": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list denoting the particle properties that will be projected to those compositional fields that are of the ``particles'' field type.\n\nThe format of valid entries for this parameter is that of a map given as ``key1: value1, key2: value2 [component2], key3: value3 [component4], ...'' where each key must be a valid field name of the ``particles'' type, and each value must be one of the currently selected particle properties. Component is a component index of the particle property that is 0 by default, but can be set up to n-1, where n is the number of vector components of this particle property. The component indicator only needs to be set if not the first component of the particle property should be mapped (e.g. the $y$-component of the velocity at the particle positions).",
            "pattern": "92",
            "pattern_description": "[Map of <[Anything]>:<[Anything]> of length 0...4294967295 (inclusive)]"
        },
        "Names of fields": {
            "value": "",
            "default_value": "",
            "documentation": "A user-defined name for each of the compositional fields requested.",
            "pattern": "89",
            "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
        },
        "Number of fields": {
            "value": "0",
            "default_value": "0",
            "documentation": "The number of fields that will be advected along with the flow field, excluding velocity, pressure and temperature.",
            "pattern": "88",
            "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
        },
        "Types of fields": {
            "value": "unspecified",
            "default_value": "unspecified",
            "documentation": "A type for each of the compositional fields requested. Each entry of the list must be one of several recognized types: chemical composition, stress, strain, grain size, porosity, density, entropy, general and unspecified. The generic type is intended to be a placeholder type that has no effect on the running of any material model, while the unspecified type is intended to tell ASPECT that the user has not explicitly indicated the type of field (facilitating parameter file checking). Plugins such as material models can use these types to affect how that plugin functions.",
            "pattern": "90",
            "pattern_description": "[List of <[Selection chemical composition|stress|strain|grain size|porosity|density|entropy|generic|unspecified ]> of length 0...4294967295 (inclusive)]"
        }
    },
    "Discretization": {
        "Composition polynomial degree": {
            "value": "2",
            "default_value": "2",
            "documentation": "The polynomial degree to use for the composition variable(s). As an example, a value of 2 for this parameter will yield either the element $Q_2$ or $DGQ_2$ for the compositional field(s), depending on whether we use continuous or discontinuous field(s). \n\nFor continuous elements, the value needs to be 1 or larger as $Q_1$ is the lowest order element, while $DGQ_0$ is a valid choice. Units: None.",
            "pattern": "68",
            "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
        },
        "Stokes velocity polynomial degree": {
            "value": "2",
            "default_value": "2",
            "documentation": "The polynomial degree to use for the velocity variables in the Stokes system. The polynomial degree for the pressure variable will then be one less in order to make the velocity\/pressure pair conform with the usual LBB (Babu{\\v s}ka-Brezzi) condition. In other words, we are using a Taylor-Hood element for the Stokes equations and this parameter indicates the polynomial degree of it. As an example, a value of 2 for this parameter will yield the element $Q_2^d \\times Q_1$ for the $d$ velocity components and the pressure, respectively (unless the `Use locally conservative discretization' parameter is set, which modifies the pressure element). \n\nBe careful if you choose 1 as the degree. The resulting element is not stable and it may lead to artifacts in the solution. Units: None.",
            "pattern": "66",
            "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
        },
        "Temperature polynomial degree": {
            "value": "2",
            "default_value": "2",
            "documentation": "The polynomial degree to use for the temperature variable. As an example, a value of 2 for this parameter will yield either the element $Q_2$ or $DGQ_2$ for the temperature field, depending on whether we use a continuous or discontinuous field. Units: None.",
            "pattern": "67",
            "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
        },
        "Use discontinuous composition discretization": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether to use a composition discretization that is discontinuous as opposed to continuous. This then requires the assembly of face terms between cells, and weak imposition of boundary terms for the composition field via the discontinuous Galerkin method.",
            "pattern": "72",
            "pattern_description": "[Bool]"
        },
        "Use discontinuous temperature discretization": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether to use a temperature discretization that is discontinuous as opposed to continuous. This then requires the assembly of face terms between cells, and weak imposition of boundary terms for the temperature field via the interior-penalty discontinuous Galerkin method.",
            "pattern": "71",
            "pattern_description": "[Bool]"
        },
        "Use equal order interpolation for Stokes": {
            "value": "false",
            "default_value": "false",
            "documentation": "By default (i.e., when this parameter is set to its default value `false') \\aspect{} uses finite element combinations in which the pressure shape functions are polynomials one degree lower than the shape functions for the velocity. An example is the Taylor-Hood element that uses $Q_k$ elements for the velocity and $Q_{k-1}$ for the pressure. This is because using the \\textit{same} polynomial degree for both the velocity and the pressure turns out to violate some mathematical properties necessary to make the problem solvable. (In particular, thecondition in question goes by the name ``inf-sup'' or Babu{\\v s}ka-Brezzi or LBB condition.) A consequence of violating this condition is that the pressure may show oscillations and not converge to the correct pressure.\n\nThat said, people have often used $Q_1$ elements for both the velocity and pressure anyway. This is commonly referred to as using the $Q_1-Q_1$ method. It is, by default, not stable as mentioned above, but it can be made stable by adding a small amount of compressibility to the model. There are numerous ways to do that. Today, the way that is generally considered to be the best approach is the one by Dohrmann and Bochev \\cite{DohrmannBochev2004}.\n\nWhen this parameter is set to ``true'', then \\aspect{} will use this method by using $Q_k\\times Q_k$ elements for velocity and pressure, respectively, where $k$ is the value provided for the parameter ``Stokes velocity polynomial degree''.\n\n\\note{While \\aspect{} \\textit{allows} you to use this   method, it is generally understood that this is not a   great idea as it leads to rather low accuracy in   general as documented in \\cite{thba22}.   It also leads to substantial problems when   using free surfaces. As a consequence, the presence   of this parameter should not be seen as an   endorsement of the method, or a suggestion to   actually use it. It simply makes the method available.}",
            "pattern": "70",
            "pattern_description": "[Bool]"
        },
        "Use locally conservative discretization": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether to use a Stokes discretization that is locally conservative at the expense of a larger number of degrees of freedom (true), or to go with a cheaper discretization that does not locally conserve mass, although it is globally conservative (false).\n\nWhen using a locally conservative discretization, the finite element space for the pressure is discontinuous between cells and is the polynomial space $P_{-(k-1)}$ of polynomials of degree $k-1$ in each variable separately. Here, $k$ is the value given in the parameter ``Stokes velocity polynomial degree'', and consequently the polynomial degree for the pressure, $k-1$, is one lower than that for the velocity.\n\nAs a consequence of choosing this element for the pressure rather than the more commonly used $Q_{k-1}$ element that is continuous, it can be shown that if the medium is considered incompressible then the computed discrete velocity field $\\mathbf u_h$ satisfies the property $\\int_ {\\partial K} \\mathbf u_h \\cdot \\mathbf n = 0$ for every cell $K$, i.e., for each cell inflow and outflow exactly balance each other as one would expect for an incompressible medium. In other words, the velocity field is \\textit{locally conservative}.\n\nOn the other hand, if this parameter is set to ``false''(the default), then the finite element space is chosen as $Q_{k-1}$. This choice does not yield the local conservation property but has the advantage of requiring fewer degrees of freedom. Furthermore, the error is generally smaller with this choice.\n\nFor an in-depth discussion of these issues and a quantitative evaluation of the different choices, see \\cite{KHB12}.",
            "pattern": "69",
            "pattern_description": "[Bool]"
        },
        "Stabilization parameters": {
            "Discontinuous penalty": {
                "value": "10.",
                "default_value": "10.",
                "documentation": "The value used to penalize discontinuities in the discontinuous Galerkin method. This is used only for the temperature field, and not for the composition field, as pure advection does not use the interior penalty method. This is largely empirically decided -- it must be large enough to ensure the bilinear form is coercive, but not so large as to penalize discontinuity at all costs.",
                "pattern": "80",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Global composition maximum": {
                "value": "1.7976931348623157e+308",
                "default_value": "1.7976931348623157e+308",
                "documentation": "The maximum global composition values that will be used in the bound preserving limiter for the discontinuous solutions from composition advection fields. The number of the input 'Global composition maximum' values separated by ',' has to be one or the same as the number of the compositional fields. When only one value is supplied, this same value is assumed for all compositional fields.",
                "pattern": "85",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Global composition minimum": {
                "value": "-1.7976931348623157e+308",
                "default_value": "-1.7976931348623157e+308",
                "documentation": "The minimum global composition value that will be used in the bound preserving limiter for the discontinuous solutions from composition advection fields. The number of the input 'Global composition minimum' values separated by ',' has to be one or the same as the number of the compositional fields. When only one value is supplied, this same value is assumed for all compositional fields.",
                "pattern": "86",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Global temperature maximum": {
                "value": "1.7976931348623157e+308",
                "default_value": "1.7976931348623157e+308",
                "documentation": "The maximum global temperature value that will be used in the bound preserving limiter for the discontinuous solutions from temperature advection fields.",
                "pattern": "83",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Global temperature minimum": {
                "value": "-1.7976931348623157e+308",
                "default_value": "-1.7976931348623157e+308",
                "documentation": "The minimum global temperature value that will be used in the bound preserving limiter for the discontinuous solutions from temperature advection fields.",
                "pattern": "84",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "List of compositional fields with disabled boundary entropy viscosity": {
                "value": "",
                "default_value": "",
                "documentation": "Select for which compositional fields to skip the entropy viscosity stabilization at dirichlet boundaries. This is only advisable for compositional fieldsthat have intrinsic physical diffusion terms, otherwise oscillations may develop. The parameter should contain a list of compositional field names.",
                "pattern": "74",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "Stabilization method": {
                "value": "entropy viscosity",
                "default_value": "entropy viscosity",
                "documentation": "Select the method for stabilizing the advection equation. The original method implemented is 'entropy viscosity' as described in \\cite {KHB12}. SUPG is currently experimental.",
                "pattern": "73",
                "pattern_description": "[Selection entropy viscosity|SUPG ]"
            },
            "Use artificial viscosity smoothing": {
                "value": "false",
                "default_value": "false",
                "documentation": "If set to false, the artificial viscosity of a cell is computed and is computed on every cell separately as discussed in \\cite{KHB12}. If set to true, the maximum of the artificial viscosity in the cell as well as the neighbors of the cell is computed and used instead.",
                "pattern": "75",
                "pattern_description": "[Bool]"
            },
            "Use limiter for discontinuous composition solution": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to apply the bound preserving limiter as a correction after having the discontinuous composition solution. Currently we apply this only to the compositional solution if the 'Global composition maximum' and 'Global composition minimum' are already defined in the .prm file. This limiter keeps the discontinuous solution in the range given by Global composition maximum' and 'Global composition minimum'.",
                "pattern": "82",
                "pattern_description": "[Bool]"
            },
            "Use limiter for discontinuous temperature solution": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to apply the bound preserving limiter as a correction after computing the discontinuous temperature solution. Currently we apply this only to the temperature solution if the 'Global temperature maximum' and 'Global temperature minimum' are already defined in the .prm file. This limiter keeps the discontinuous solution in the range given by 'Global temperature maximum' and 'Global temperature minimum'.",
                "pattern": "81",
                "pattern_description": "[Bool]"
            },
            "alpha": {
                "value": "2",
                "default_value": "2",
                "documentation": "The exponent $\\alpha$ in the entropy viscosity stabilization. Valid options are 1 or 2. The recommended setting is 2. (This parameter does not correspond to any variable in the 2012 paper by Kronbichler, Heister and Bangerth that describes ASPECT, see \\cite{KHB12}. Rather, the paper always uses 2 as the exponent in the definition of the entropy, following equation (15) of the paper. The full approach is discussed in \\cite{GPP11}.) Note that this is not the thermal expansion coefficient, also commonly referred to as $\\alpha$.Units: None.",
                "pattern": "76",
                "pattern_description": "[Integer range 1...2 (inclusive)]"
            },
            "beta": {
                "value": "0.052",
                "default_value": "0.052",
                "documentation": "The $\\beta$ factor in the artificial viscosity stabilization. This parameter controls the maximum dissipation of the entropy viscosity, which is the part that only scales with the cell diameter and the maximum velocity in the cell, but does not depend on the solution field itself or its residual. An appropriate value for 2d is 0.052 and 0.78 for 3d. (For historical reasons, the name used here is different from the one used in the 2012 paper by Kronbichler, Heister and Bangerth that describes ASPECT, see \\cite{KHB12}. This parameter can be given as a single value or as a list with as many entries as one plus the number of compositional fields. In the former case all advection fields use the same stabilization parameters, in the latter case each field (temperature first, then all compositions) use individual parameters. This can be useful to reduce the stabilization for the temperature, which already has some physical diffusion. This parameter corresponds to the factor $\\alpha_{\\text{max}}$ in the formulas following equation (15) of the paper.) Units: None.",
                "pattern": "78",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "cR": {
                "value": "0.11",
                "default_value": "0.11",
                "documentation": "The $c_R$ factor in the entropy viscosity stabilization. This parameter controls the part of the entropy viscosity that depends on the solution field itself and its residual in addition to the cell diameter and the maximum velocity in the cell. This parameter can be given as a single value or as a list with as many entries as one plus the number of compositional fields. In the former case all advection fields use the same stabilization parameters, in the latter case each field (temperature first, then all compositions) use individual parameters. This can be useful to reduce the stabilization for the temperature, which already has some physical diffusion. (For historical reasons, the name used here is different from the one used in the 2012 paper by Kronbichler, Heister and Bangerth that describes ASPECT, see \\cite{KHB12}. This parameter corresponds to the factor $\\alpha_E$ in the formulas following equation (15) of the paper.) Units: None.",
                "pattern": "77",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "gamma": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The strain rate scaling factor in the artificial viscosity stabilization. This parameter determines how much the strain rate (in addition to the velocity) should influence the stabilization. (This parameter does not correspond to any variable in the 2012 paper by Kronbichler, Heister and Bangerth that describes ASPECT, see \\cite{KHB12}. Rather, the paper always uses 0, i.e. they specify the maximum dissipation $\\nu_h^\\text{max}$ as $\\nu_h^\\text{max}\\vert_K = \\alpha_{\\text{max}} h_K \\|\\mathbf u\\|_{\\infty,K}$. Here, we use $\\|\\lvert\\mathbf u\\rvert + \\gamma h_K \\lvert\\varepsilon (\\mathbf u)\\rvert\\|_{\\infty,K}$ instead of $\\|\\mathbf u\\|_{\\infty,K}$. Units: None.",
                "pattern": "79",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        }
    },
    "Formulation": {
        "Enable additional Stokes RHS": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether to ask the material model for additional terms for the right-hand side of the Stokes equation. This feature is likely only used when implementing force vectors for manufactured solution problems and requires filling additional outputs of type AdditionalMaterialOutputsStokesRHS.",
            "pattern": "45",
            "pattern_description": "[Bool]"
        },
        "Enable elasticity": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether to include the additional elastic terms on the right-hand side of the Stokes equation.",
            "pattern": "46",
            "pattern_description": "[Bool]"
        },
        "Enable prescribed dilation": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether to include additional terms on the right-hand side of the Stokes equation to set a given compression term specified in the MaterialModel output PrescribedPlasticDilation.",
            "pattern": "47",
            "pattern_description": "[Bool]"
        },
        "Formulation": {
            "value": "custom",
            "default_value": "custom",
            "documentation": "Select a formulation for the basic equations. Different published formulations are available in ASPECT (see the list of possible values for this parameter in the manual for available options). Two ASPECT specific options are\n  * `isentropic compression': ASPECT's original formulation, using the explicit compressible mass equation, and the full density for the temperature equation.\n  * `custom': A custom selection of `Mass conservation' and `Temperature equation'.\n:::{warning}\nThe `custom' option is implemented for advanced users that want full control over the equations solved. It is possible to choose inconsistent formulations and no error checking is performed on the consistency of the resulting equations.\n:::\n\n:::{warning}\nThe `anelastic liquid approximation' option here can also be used to set up the `truncated anelastic liquid approximation' as long as this option is chosen together with a material model that defines a density that depends on temperature and depth and not on the pressure.\n:::",
            "pattern": "42",
            "pattern_description": "[Selection isentropic compression|custom|anelastic liquid approximation|Boussinesq approximation ]"
        },
        "Mass conservation": {
            "value": "ask material model",
            "default_value": "ask material model",
            "documentation": "Possible approximations for the density derivatives in the mass conservation equation. Note that this parameter is only evaluated if `Formulation' is set to `custom'. Other formulations ignore the value of this parameter.",
            "pattern": "43",
            "pattern_description": "[Selection incompressible|isentropic compression|hydrostatic compression|reference density profile|implicit reference density profile|projected density field|ask material model ]"
        },
        "Temperature equation": {
            "value": "real density",
            "default_value": "real density",
            "documentation": "Possible approximations for the density in the temperature equation. Possible approximations are `real density' and `reference density profile'. Note that this parameter is only evaluated if `Formulation' is set to `custom'. Other formulations ignore the value of this parameter.",
            "pattern": "44",
            "pattern_description": "[Selection real density|reference density profile ]"
        }
    },
    "Geometry model": {
        "Model name": {
            "value": "box",
            "default_value": "unspecified",
            "documentation": "Select one of the following models:\n\n`box': A box geometry parallel to the coordinate directions. The extent of the box in each coordinate direction is set in the parameter file. The box geometry labels its 2*dim sides as follows: in 2d, boundary indicators 0 through 3 denote the left, right, bottom and top boundaries; in 3d, boundary indicators 0 through 5 indicate left, right, front, back, bottom and top boundaries (see also the documentation of the deal.II class ``ReferenceCell''). You can also use symbolic names ``left'', ``right'', etc., to refer to these boundaries in input files. It is also possible to add initial topography to the box model. Note however that this is done after the last initial adaptive refinement cycle. Also, initial topography is supposed to be small, as it is not taken into account when depth or a representative point is computed. \n\n`box with lithosphere boundary indicators': A box geometry parallel to the coordinate directions. The extent of the box in each coordinate direction is set in the parameter file. This geometry model labels its sides with 2*dim+2*(dim-1) boundary indicators: in 2d, boundary indicators 0 through 3 denote the left, right, bottom and top boundaries, while indicators4 and 5 denote the upper part of the left and right vertical boundary, respectively. In 3d, boundary indicators 0 through 5 indicate left, right, front, back, bottom and top boundaries (see also the documentation of the deal.II class ``ReferenceCell''), while indicators 6, 7, 8 and 9 denote the left, right, front and back upper parts of the vertical boundaries, respectively. You can also use symbolic names ``left'', ``right'', ``left lithosphere'', etc., to refer to these boundaries in input files.\n\nNote that for a given ``Global refinement level'' and no user-specified ``Repetitions'', the lithosphere part of the mesh will be more refined. \n\nThe additional boundary indicators for the lithosphere allow for selecting boundary conditions for the lithosphere different from those for the underlying mantle. An example application of this geometry is to prescribe a velocity on the lithospheric plates, but use open boundary conditions underneath. \n\n`chunk': A geometry which can be described as a chunk of a spherical shell, bounded by lines of longitude, latitude and radius. The minimum and maximum longitude, latitude (if in 3d) and depth of the chunk is set in the parameter file. The chunk geometry labels its 2*dim sides as follows: ``west'' and ``east'': minimum and maximum longitude, ``south'' and ``north'': minimum and maximum latitude, ``inner'' and ``outer'': minimum and maximum radii. \n\nThe dimensions of the model are specified by parameters of the following form: Chunk (minimum || maximum) (longitude || latitude): edges of geographical quadrangle (in degrees)Chunk (inner || outer) radius: Radii at bottom and top of chunk(Longitude || Latitude || Radius) repetitions: number of cells in each coordinate direction.\n\nWhen used in 2d, this geometry does not imply the use of a spherical coordinate system. Indeed, in 2d the geometry is simply a sector of an annulus in a Cartesian coordinate system and consequently would correspond to a sector of a cross section of the fluid filled space between two infinite cylinders where one has made the assumption that the velocity in direction of the cylinder axes is zero. This is consistent with the definition of what we consider the two-dimension case given in Section~\\ref{sec:meaning-of-2d}. It is also possible to add initial topography to the chunk geometry, based on an ascii data file. \n\n`chunk with lithosphere boundary indicators': A geometry which can be described as a chunk of a spherical shell, bounded by lines of longitude, latitude and radius. The side boundaries have two boundary indicators, so the user can prescribe different boundary conditions on these boundaries. The minimum and maximum longitude, (latitude) and depth of the chunk are set in the parameter file. The chunk geometry labels its 2*dim+2*(dim-1) sides as follows: ``lowerwest'' and ``lowereast'': minimum and maximum longitude of the lower part of the east and west side boundaries, ``upperwest'' and ``uppereast'': minimum and maximum longitude of the upper part of the east and west side boundaries, ``lowersouth'' and ``lowernorth'': minimum and maximum latitude of the lower part of the south and north side boundaries, ``uppersouth'' and ``uppernorth'': minimum and maximum latitude of the upper part of the south and north side boundaries, \n\nThe dimensions of the model are specified by parameters of the following form: Chunk (minimum | maximum) (longitude | latitude): edges of geographical quadrangle (in degrees). Chunk (inner | outer | middle boundary) radius: Radii at bottom and top of chunk and the radius at which the lower boundary indicator along a side boundary transitions into the upper boundary indicator. (Longitude | Latitude) repetitions: number of cells in each coordinate direction.(Inner | Outer) chunk radius repetitions: number of cells in the radial coordinate direction for the lower part of the domain (up to the Middle boundary radius) and for the upper part of the domain. \n\nWhen used in 2d, this geometry does not imply the use of a spherical coordinate system. Indeed, in 2d the geometry is simply a sector of an annulus in a Cartesian coordinate system and consequently would correspond to a sector of a cross section of the fluid filled space between two infinite cylinders where one has made the assumption that the velocity in direction of the cylinder axes is zero. This is consistent with the definition of what we consider the two-dimension case given in Section~\\ref{sec:meaning-of-2d}. It is also possible to add initial topography to the chunk geometry, based on an ascii data file. \n\n`ellipsoidal chunk': A 3d chunk geometry that accounts for Earth's ellipticity (default assuming the WGS84 ellipsoid definition) which can be defined in non-coordinate directions. In the description of the ellipsoidal chunk, two of the ellipsoidal axes have the same length so that there is only a semi-major axis and a semi-minor axis. The user has two options for creating an ellipsoidal chunk geometry: 1) by defining two opposing points (SW and NE or NW and SE) a coordinate parallel ellipsoidal chunk geometry will be created. 2) by defining three points a non-coordinate parallel ellipsoidal chunk will be created. The points are defined in the input file by longitude:latitude. It is also possible to define additional subdivisions of the mesh in each direction. The boundary of the domain is formed by linear interpolation in longitude-latitude space between adjacent points (i.e. $[lon, lat](f) = [lon1 \\cdot f + lon2 \\cdot(1-f), lat1 \\cdot f + lat2 \\cdot (1-f)]$, where f is a value between 0 and 1). Faces of the model are defined as 0, west; 1,east; 2, south; 3, north; 4, inner; 5, outer.\n\nThis geometry model supports initial topography for deforming the initial mesh.\n\n`sphere': A geometry model for a sphere with a user specified radius. This geometry has only a single boundary, so the only valid boundary indicator to specify in input files is ``0''. It can also be referenced by the symbolic name ``surface'' in input files.\n\nDespite the name, this geometry does not imply the use of a spherical coordinate system when used in 2d. Indeed, in 2d the geometry is simply a circle in a Cartesian coordinate system and consequently would correspond to a cross section of the fluid filled interior of an infinite cylinder where one has made the assumption that the velocity in direction of the cylinder axes is zero. This is consistent with the definition of what we consider the two-dimension case given in Section~\\ref{sec:meaning-of-2d}.\n\n`spherical shell': A geometry representing a spherical shell or a piece of it. Inner and outer radii are read from the parameter file in subsection 'Spherical shell'.\n\nThe spherical shell may be generated as per the original code (with respect to the inner and outer radius, and an initial number of cells along circumference) or following a custom mesh scheme: list of radial values or number of slices. A surface mesh is first generated and refined as desired, before it is extruded radially. A list of radial values subdivides the spherical shell at specified radii. The number of slices subdivides the spherical shell into N slices of equal thickness. The custom spherical shell only works with an opening angle of 360 degrees.\n\nDespite the name, this geometry does not imply the use of a spherical coordinate system when used in 2d. Indeed, in 2d the geometry is simply an annulus in a Cartesian coordinate system and consequently would correspond to a cross section of the fluid filled space between two infinite cylinders where one has made the assumption that the velocity in direction of the cylinder axes is zero. This is consistent with the definition of what we consider the two-dimension case given in Section~\\ref{sec:meaning-of-2d}.\n\nThe model assigns boundary indicators as follows: In 2d, inner and outer boundaries get boundary indicators zero and one, and if the opening angle set in the input file is less than 360, then left and right boundaries are assigned indicators two and three. These boundaries can also be referenced using the symbolic names `inner', `outer' and (if applicable) `left', `right'.\n\nIn 3d, inner and outer indicators are treated as in 2d. If the opening angle is chosen as 90 degrees, i.e., the domain is the intersection of a spherical shell and the first octant, then indicator 2 is at the face $x=0$, 3 at $y=0$, and 4 at $z=0$. These last three boundaries can then also be referred to as `east', `west' and `south' symbolically in input files.",
            "pattern": "928",
            "pattern_description": "[Selection box|box with lithosphere boundary indicators|chunk|chunk with lithosphere boundary indicators|ellipsoidal chunk|sphere|spherical shell|unspecified ]"
        },
        "Box": {
            "Box origin X coordinate": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "X coordinate of box origin. Units: \\si{\\meter}.",
                "pattern": "972",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Box origin Y coordinate": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Y coordinate of box origin. Units: \\si{\\meter}.",
                "pattern": "973",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Box origin Z coordinate": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Z coordinate of box origin. This value is ignored if the simulation is in 2d. Units: \\si{\\meter}.",
                "pattern": "974",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "X extent": {
                "value": "500.e3",
                "default_value": "1.",
                "documentation": "Extent of the box in x-direction. Units: \\si{\\meter}.",
                "pattern": "969",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "X periodic": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the box should be periodic in X direction",
                "pattern": "978",
                "pattern_description": "[Bool]"
            },
            "X repetitions": {
                "value": "5",
                "default_value": "1",
                "documentation": "Number of cells in X direction.",
                "pattern": "975",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Y extent": {
                "value": "200.e3",
                "default_value": "1.",
                "documentation": "Extent of the box in y-direction. Units: \\si{\\meter}.",
                "pattern": "970",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Y periodic": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the box should be periodic in Y direction",
                "pattern": "979",
                "pattern_description": "[Bool]"
            },
            "Y repetitions": {
                "value": "2",
                "default_value": "1",
                "documentation": "Number of cells in Y direction.",
                "pattern": "976",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Z extent": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Extent of the box in z-direction. This value is ignored if the simulation is in 2d. Units: \\si{\\meter}.",
                "pattern": "971",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Z periodic": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the box should be periodic in Z direction",
                "pattern": "980",
                "pattern_description": "[Bool]"
            },
            "Z repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in Z direction.",
                "pattern": "977",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            }
        },
        "Box with lithosphere boundary indicators": {
            "Box origin X coordinate": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "X coordinate of box origin. Units: \\si{\\meter}.",
                "pattern": "933",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Box origin Y coordinate": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Y coordinate of box origin. Units: \\si{\\meter}.",
                "pattern": "934",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Box origin Z coordinate": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Z coordinate of box origin. This value is ignored if the simulation is in 2d. Units: \\si{\\meter}.",
                "pattern": "935",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Lithospheric thickness": {
                "value": "0.2",
                "default_value": "0.2",
                "documentation": "The thickness of the lithosphere used to create additional boundary indicators to set specific boundary conditions for the lithosphere. ",
                "pattern": "929",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Use merged grids": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to make the grid by gluing together two boxes, or just use one chunk to make the grid. Using two grids glued together is a safer option, since it forces the boundary conditions to be always applied to the same depth, but using one grid allows for a more flexible usage of the adaptive refinement. Note that if there is no cell boundary exactly on the boundary between the lithosphere and the mantle, the velocity boundary will not be exactly at that depth. Therefore, using a merged grid is generally recommended over using one grid.When using one grid, the parameter for lower repetitions is used and the upper repetitions are ignored.",
                "pattern": "946",
                "pattern_description": "[Bool]"
            },
            "X extent": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Extent of the box in x-direction. Units: \\si{\\meter}.",
                "pattern": "930",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "X periodic": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the box should be periodic in X direction.",
                "pattern": "941",
                "pattern_description": "[Bool]"
            },
            "X periodic lithosphere": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the box should be periodic in X direction in the lithosphere.",
                "pattern": "944",
                "pattern_description": "[Bool]"
            },
            "X repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in X direction of the lower box. The same number of repetitions will be used in the upper box.",
                "pattern": "936",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Y extent": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Extent of the box in y-direction. Units: \\si{\\meter}.",
                "pattern": "931",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Y periodic": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the box should be periodic in Y direction.",
                "pattern": "942",
                "pattern_description": "[Bool]"
            },
            "Y periodic lithosphere": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the box should be periodic in Y direction in the lithosphere. This value is ignored if the simulation is in 2d. ",
                "pattern": "945",
                "pattern_description": "[Bool]"
            },
            "Y repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in Y direction of the lower box. If the simulation is in 3d, the same number of repetitions will be used in the upper box.",
                "pattern": "937",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Y repetitions lithosphere": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in Y direction in the lithosphere. This value is ignored if the simulation is in 3d.",
                "pattern": "939",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Z extent": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Extent of the box in z-direction. This value is ignored if the simulation is in 2d. Units: \\si{\\meter}.",
                "pattern": "932",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Z periodic": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the box should be periodic in Z direction. This value is ignored if the simulation is in 2d.",
                "pattern": "943",
                "pattern_description": "[Bool]"
            },
            "Z repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in Z direction of the lower box. This value is ignored if the simulation is in 2d.",
                "pattern": "938",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Z repetitions lithosphere": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in Z direction in the lithosphere. This value is ignored if the simulation is in 2d.",
                "pattern": "940",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            }
        },
        "Chunk": {
            "Chunk inner radius": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Radius at the bottom surface of the chunk. Units: \\si{\\meter}.",
                "pattern": "981",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Chunk maximum latitude": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Maximum latitude of the chunk. This value is ignored if the simulation is in 2d. Units: degrees.",
                "pattern": "986",
                "pattern_description": "[Double -90...90 (inclusive)]"
            },
            "Chunk maximum longitude": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Maximum longitude of the chunk. Units: degrees.",
                "pattern": "984",
                "pattern_description": "[Double -180...360 (inclusive)]"
            },
            "Chunk minimum latitude": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Minimum latitude of the chunk. This value is ignored if the simulation is in 2d. Units: degrees.",
                "pattern": "985",
                "pattern_description": "[Double -90...90 (inclusive)]"
            },
            "Chunk minimum longitude": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Minimum longitude of the chunk. Units: degrees.",
                "pattern": "983",
                "pattern_description": "[Double -180...360 (inclusive)]"
            },
            "Chunk outer radius": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Radius at the top surface of the chunk. Units: \\si{\\meter}.",
                "pattern": "982",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Latitude repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in latitude. This value is ignored if the simulation is in 2d",
                "pattern": "989",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Longitude repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in longitude.",
                "pattern": "988",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Radius repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in radius.",
                "pattern": "987",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            }
        },
        "Chunk with lithosphere boundary indicators": {
            "Chunk inner radius": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Radius at the bottom surface of the chunk. Units: \\si{\\meter}.",
                "pattern": "947",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Chunk maximum latitude": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Maximum latitude of the chunk. This value is ignored if the simulation is in 2d. Units: degrees.",
                "pattern": "953",
                "pattern_description": "[Double -90...90 (inclusive)]"
            },
            "Chunk maximum longitude": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Maximum longitude of the chunk. Units: degrees.",
                "pattern": "951",
                "pattern_description": "[Double -180...360 (inclusive)]"
            },
            "Chunk middle boundary radius": {
                "value": "1",
                "default_value": "1",
                "documentation": "Radius at the top surface of the lower chunk, where it merges with the upper chunk. Units: \\si{\\meter}.",
                "pattern": "949",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Chunk minimum latitude": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Minimum latitude of the chunk. This value is ignored if the simulation is in 2d. Units: degrees.",
                "pattern": "952",
                "pattern_description": "[Double -90...90 (inclusive)]"
            },
            "Chunk minimum longitude": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Minimum longitude of the chunk. Units: degrees.",
                "pattern": "950",
                "pattern_description": "[Double -180...360 (inclusive)]"
            },
            "Chunk outer radius": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Radius at the top surface of the chunk. Units: \\si{\\meter}.",
                "pattern": "948",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Inner chunk radius repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in radial direction for the lower chunk.",
                "pattern": "955",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Latitude repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in latitude. This value is ignored if the simulation is in 2d",
                "pattern": "957",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Longitude repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in longitude.",
                "pattern": "956",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Outer chunk radius repetitions": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of cells in radial direction for the upper chunk.",
                "pattern": "954",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Use merged grids": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to make the grid by gluing together two boxes, or just use one chunk to make the grid. Using two grids glued together is a safer option, since it forces the boundary conditions to be always applied to the same depth, but using one grid allows for a more flexible usage of the adaptive refinement. Note that if there is no cell boundary exactly on the boundary between the lithosphere and the mantle, the velocity boundary will not be exactly at that depth. Therefore, using a merged grid is generally recommended over using one grid. When using one grid, the parameter for lower repetitions is used and the upper repetitions are ignored.",
                "pattern": "958",
                "pattern_description": "[Bool]"
            }
        },
        "Ellipsoidal chunk": {
            "Depth": {
                "value": "500000.0",
                "default_value": "500000.0",
                "documentation": "Bottom depth of model region.",
                "pattern": "994",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Depth subdivisions": {
                "value": "1",
                "default_value": "1",
                "documentation": "The number of subdivisions of the coarse (initial) mesh in depth.",
                "pattern": "999",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "East-West subdivisions": {
                "value": "1",
                "default_value": "1",
                "documentation": "The number of subdivisions of the coarse (initial) mesh in the East-West direction.",
                "pattern": "997",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Eccentricity": {
                "value": "8.1819190842622e-2",
                "default_value": "8.1819190842622e-2",
                "documentation": "Eccentricity of the ellipsoid. Zero is a perfect sphere, default (8.1819190842622e-2) is WGS84.",
                "pattern": "996",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "NE corner": {
                "value": "",
                "default_value": "",
                "documentation": "Longitude:latitude in degrees of the North-East corner point of model region.The North-East direction is positive. If one of the three corners is not provided the missing corner value will be calculated so all faces are parallel.",
                "pattern": "990",
                "pattern_description": "[Anything]"
            },
            "NW corner": {
                "value": "",
                "default_value": "",
                "documentation": "Longitude:latitude in degrees of the North-West corner point of model region. The North-East direction is positive. If one of the three corners is not provided the missing corner value will be calculated so all faces are parallel.",
                "pattern": "991",
                "pattern_description": "[Anything]"
            },
            "North-South subdivisions": {
                "value": "1",
                "default_value": "1",
                "documentation": "The number of subdivisions of the coarse (initial) mesh in the North-South direction.",
                "pattern": "998",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "SE corner": {
                "value": "",
                "default_value": "",
                "documentation": "Longitude:latitude in degrees of the South-East corner point of model region. The North-East direction is positive. If one of the three corners is not provided the missing corner value will be calculated so all faces are parallel.",
                "pattern": "993",
                "pattern_description": "[Anything]"
            },
            "SW corner": {
                "value": "",
                "default_value": "",
                "documentation": "Longitude:latitude in degrees of the South-West corner point of model region. The North-East direction is positive. If one of the three corners is not provided the missing corner value will be calculated so all faces are parallel.",
                "pattern": "992",
                "pattern_description": "[Anything]"
            },
            "Semi-major axis": {
                "value": "6378137.0",
                "default_value": "6378137.0",
                "documentation": "The semi-major axis (a) of an ellipsoid. This is the radius for a sphere (eccentricity=0). Default WGS84 semi-major axis.",
                "pattern": "995",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Initial topography model": {
            "Model name": {
                "value": "zero topography",
                "default_value": "zero topography",
                "documentation": "Select one of the following models:\n\n`ascii data': Implementation of a model in which the surface topography is derived from a file containing data in ascii format. The following geometry models are currently supported: box, chunk. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `Topography [m]' in a 2d model and  `x', `y', `Topography [m]' in a 3d model, which means that there has to be a single column containing the topography. Note that the data in the input file needs to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the azimuth angle in radians (between $-\\pi$ and $\\pi$) and `y' by the polar angle in radians (between $0$ and $\\pi$) measured positive from the north pole. The grid will be assumed to be a longitude-colatitude grid. Note that the order of spherical coordinates is `phi', `theta' and not `theta', `phi', since this allows for dimension independent expressions.\n\n`function': Implementation of a model in which the initial topography is described by a function in cartesian or spherical coordinates. \n\n`prm polygon': An initial topography model that defines the initial topography as constant inside each of a set of polygonal parts of the surface. The polygons, and their associated surface elevation, are defined in the `Geometry model\/Initial topography\/Prm polygon' section.\n\n`zero topography': Implementation of a model in which the initial topography is zero. ",
                "pattern": "1000",
                "pattern_description": "[Selection ascii data|function|prm polygon|zero topography ]"
            },
            "Ascii data model": {
                "Data directory": {
                    "value": "$ASPECT_SOURCE_DIR\/data\/geometry-model\/initial-topography-model\/ascii-data\/test\/",
                    "default_value": "$ASPECT_SOURCE_DIR\/data\/geometry-model\/initial-topography-model\/ascii-data\/test\/",
                    "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                    "pattern": "1001",
                    "pattern_description": "[DirectoryName]"
                },
                "Data file name": {
                    "value": "box_2d_%s.0.txt",
                    "default_value": "box_2d_%s.0.txt",
                    "documentation": "The file name of the model data.",
                    "pattern": "1002",
                    "pattern_description": "[Anything]"
                },
                "Scale factor": {
                    "value": "1.",
                    "default_value": "1.",
                    "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                    "pattern": "1003",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                }
            },
            "Function": {
                "Coordinate system": {
                    "value": "cartesian",
                    "default_value": "cartesian",
                    "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `cartesian' and `spherical'. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. ",
                    "pattern": "1005",
                    "pattern_description": "[Selection cartesian|spherical ]"
                },
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "1008",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "0",
                    "default_value": "0",
                    "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                    "pattern": "1007",
                    "pattern_description": "[Anything]"
                },
                "Maximum topography value": {
                    "value": "2000.",
                    "default_value": "2000.",
                    "documentation": "The maximum value the topography given by the function can take. ",
                    "pattern": "1004",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Variable names": {
                    "value": "x,y,t",
                    "default_value": "x,y,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "1006",
                    "pattern_description": "[Anything]"
                }
            },
            "Prm polygon": {
                "Topography parameters": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Set the topography height and the polygon which should be set to that height. The format is : \"The topography height \textgreater The point list describing a polygon \\& The next topography height \textgreater the next point list describing a polygon.\" The format for the point list describing the polygon is \"x1,y1;x2,y2\". For example for two triangular areas of 100 and -100 meters high set: '100 \textgreater 0,0;5,5;0,10 \\& -100 \textgreater 10,10;10,15;20,15'. Units of the height are always in meters. The units of the coordinates are dependent on the geometry model. In the box model they are in meters, in the chunks they are in degrees, etc. Please refer to the manual of the individual geometry model to so see how the topography is implemented.",
                    "pattern": "1009",
                    "pattern_description": "[Anything]"
                }
            }
        },
        "Sphere": {
            "Radius": {
                "value": "6371000.",
                "default_value": "6371000.",
                "documentation": "Radius of the sphere. Units: \\si{\\meter}.",
                "pattern": "959",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Spherical shell": {
            "Cells along circumference": {
                "value": "0",
                "default_value": "0",
                "documentation": "The number of cells in circumferential direction that are created in the coarse mesh in 2d. If zero, this number is chosen automatically in a way that produces meshes in which cells have a reasonable aspect ratio for models in which the depth of the mantle is roughly that of the Earth. For planets with much shallower mantles and larger cores, you may want to chose a larger number to avoid cells that are elongated in tangential and compressed in radial direction.\n\nIn 3d, the number of cells is computed differently and does not have an easy interpretation. Valid values for this parameter in 3d are 0 (let this class choose), 6, 12 and 96. Other possible values may be discussed in the documentation of the deal.II function GridGenerator::hyper_shell. The parameter is best left at its default in 3d.\n\nIn either case, this parameter is ignored unless the opening angle of the domain is 360 degrees. This parameter is also ignored when using a custom mesh subdivision scheme.",
                "pattern": "967",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Custom mesh subdivision": {
                "value": "none",
                "default_value": "none",
                "documentation": "Choose how the spherical shell mesh is generated. By default, a coarse mesh is generated with respect to the inner and outer radius, and an initial number of cells along circumference. In the other cases, a surface mesh is first generated and refined as desired, before it is extruded radially following the specified subdivision scheme.",
                "pattern": "960",
                "pattern_description": "[Selection none|list of radial values|number of slices ]"
            },
            "Initial lateral refinement": {
                "value": "0",
                "default_value": "0",
                "documentation": "Initial lateral refinement for the custom mesh subdivision schemes.The number of refinement steps performed on the initial coarse surface mesh, before the surface is extruded radially. This parameter allows the user more control over the ratio between radial and lateral refinement of the mesh.",
                "pattern": "963",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Inner radius": {
                "value": "3481000.",
                "default_value": "3481000.",
                "documentation": "Inner radius of the spherical shell. Units: \\si{\\meter}.\n\n\\note{The default value of 3,481,000 m equals the radius of a sphere with equal volume as Earth (i.e., 6371 km) minus the average depth of the core-mantle boundary (i.e., 2890 km).}",
                "pattern": "964",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "List of radial values": {
                "value": "",
                "default_value": "",
                "documentation": "List of radial values for the custom mesh scheme. Units: $\\si{m}$. A list of radial values subdivides the spherical shell at specified radii. The list must be strictly ascending, and the first value must be greater than the inner radius while the last must be less than the outer radius.",
                "pattern": "961",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Number of slices": {
                "value": "1",
                "default_value": "1",
                "documentation": "Number of slices for the custom mesh subdivision scheme. The number of slices subdivides the spherical shell into N slices of equal thickness. Must be greater than 0.",
                "pattern": "962",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Opening angle": {
                "value": "360.",
                "default_value": "360.",
                "documentation": "Opening angle in degrees of the section of the shell that we want to build. The only opening angles that are allowed for this geometry are 90, 180, and 360 in 2d; and 90 and 360 in 3d. Units: degrees.",
                "pattern": "966",
                "pattern_description": "[Double 0...360 (inclusive)]"
            },
            "Outer radius": {
                "value": "6336000.",
                "default_value": "6336000.",
                "documentation": "Outer radius of the spherical shell. Units: \\si{\\meter}.\n\n\\note{The default value of 6,336,000 m equals the radius of a sphere with equal volume as Earth (i.e., 6371 km) minus the average depth of the mantle-crust interface (i.e., 35 km).}",
                "pattern": "965",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Phi periodic": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the shell should be periodic in the phi direction.",
                "pattern": "968",
                "pattern_description": "[Bool]"
            }
        }
    },
    "Gravity model": {
        "Model name": {
            "value": "vertical",
            "default_value": "unspecified",
            "documentation": "Select one of the following models:\n\n`ascii data': Gravity is read from a file that describes the reference state. The default profile follows the preliminary reference Earth model (PREM, Dziewonski and Anderson, 1981). Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of points in the reference state as for example `# POINTS: 3'. Following the comment lines there has to be a single line containing the names of all data columns, separated by arbitrarily many spaces. Column names are not allowed to contain spaces. The file can contain unnecessary columns, but for this plugin it needs to at least provide a column named `gravity'. Note that the data lines in the file need to be sorted in order of increasing depth from 0 to the maximal depth in the model domain. Points in the model that are outside of the provided depth range will be assigned the maximum or minimum depth values, respectively. Points do not need to be equidistant, but the computation of properties is optimized in speed if they are.\n\n`function': Gravity is given in terms of an explicit formula that is elaborated in the parameters in section ``Gravity model|Function''. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`radial constant': A gravity model in which the gravity has a constant magnitude and the direction is radial (pointing inward if the value is positive). The magnitude is read from the parameter file in subsection 'Radial constant'.\n\n`radial earth-like': This plugin has been removed due to its misleading name. The included profile was hard-coded and was less earth-like than the `ascii data' plugin, which uses the profile of the Preliminary Reference Earth Model (PREM). Use `ascii data' instead of `radial earth-like'.\n\n`radial linear': A gravity model which is radial (pointing inward if the gravity is positive) and the magnitude changes linearly with depth. The magnitude of gravity at the surface and bottom is read from the input file in a section ``Gravity model\/Radial linear''.\n\n`vertical': A gravity model in which the gravity direction is vertical (pointing downward for positive values) and at a constant magnitude by default equal to one.",
            "pattern": "1010",
            "pattern_description": "[Selection ascii data|function|radial constant|radial earth-like|radial linear|vertical|unspecified ]"
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/gravity-model\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/gravity-model\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1011",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "prem.txt",
                "default_value": "prem.txt",
                "documentation": "The file name of the model data.",
                "pattern": "1012",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1013",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1016",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0; 0",
                "default_value": "0; 0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1015",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1014",
                "pattern_description": "[Anything]"
            }
        },
        "Radial constant": {
            "Magnitude": {
                "value": "9.81",
                "default_value": "9.81",
                "documentation": "Magnitude of the gravity vector in $m\/s^2$. For positive values the direction is radially inward towards the center of the earth.",
                "pattern": "1017",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Radial linear": {
            "Magnitude at bottom": {
                "value": "10.7",
                "default_value": "10.7",
                "documentation": "Magnitude of the radial gravity vector at the bottom of the domain. `Bottom' means themaximum depth in the chosen geometry, and for example represents the core-mantle boundary in the case of the `spherical shell' geometry model, and the center in the case of the `sphere' geometry model. Units: \\si{\\meter\\per\\second\\squared}.",
                "pattern": "1019",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Magnitude at surface": {
                "value": "9.8",
                "default_value": "9.8",
                "documentation": "Magnitude of the radial gravity vector at the surface of the domain. Units: \\si{\\meter\\per\\second\\squared}.",
                "pattern": "1018",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Vertical": {
            "Magnitude": {
                "value": "10.0",
                "default_value": "1.",
                "documentation": "Value of the gravity vector in $m\/s^2$ directed along negative y (2d) or z (3d) axis (if the magnitude is positive.",
                "pattern": "1020",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        }
    },
    "Heating model": {
        "List of model names": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list of heating models that will be used to calculate the heating terms in the energy equation. The results of each of these criteria, i.e., the heating source terms and the latent heat terms for the left hand side will be added.\n\nThe following heating models are available:\n\n`adiabatic heating': Implementation of a standard and a simplified model of adiabatic heating.\n\n`adiabatic heating of melt': Implementation of a standard and a simplified model of adiabatic heating of melt. The full model implements the heating term \n$\\alpha T (-\\phi \\mathbf u_s \\cdot \\nabla p) + \\alpha T (\\phi \\mathbf u_f \\cdot \\nabla p)$.\nFor full adiabatic heating, this has to be used in combination with the heating model `adiabatic heating' to also include adiabatic heating for the solid part, and the full heating term is then $\\alpha T ((1-\\phi) \\mathbf u_s \\cdot \\nabla p) + \\alpha T (\\phi \\mathbf u_f \\cdot \\nabla p)$.\n\n`compositional heating': Implementation of a model in which magnitude of internal heat production is determined from fixed values assigned to each compositional field. These values are interpreted as having units \\si{\\watt\\per\\meter\\cubed}.\n\n`constant heating': Implementation of a model in which the heating rate is constant.\n\n`function': Implementation of a model in which the heating rate is given in terms of an explicit formula that is elaborated in the parameters in section ``Heating model|Function''. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\nThe formula is interpreted as having units W\/kg.\n\nSince the symbol $t$ indicating time may appear in the formulas for the heating rate, it is interpreted as having units seconds unless the global parameter ``Use years in output instead of seconds'' is set.\n\n`latent heat': Implementation of a standard model for latent heat.\n\n`latent heat melt': Implementation of a standard model for latent heat of melting. This assumes that there is a compositional field called porosity, and it uses the reaction term of this field (the fraction of material that melted in the current time step) multiplied by a constant entropy change for melting all of the material as source term of the heating model.\nIf there is no field called porosity, the heating terms are 0.\n\n`radioactive decay': Implementation of a model in which the internal heating rate is radioactive decaying in the following rule:\n\\[(\\text{initial concentration})\\cdot 0.5^{\\text{time}\/(\\text{half life})}\\]\nThe crust and mantle can have different concentrations, and the crust can be defined either by depth or by a certain compositional field.\nThe formula is interpreted as having units W\/kg.\n\n`shear heating': Implementation of a standard model for shear heating. Adds the term: $  2 \\eta \\left( \\varepsilon - \\frac{1}{3} \\text{tr} \\varepsilon \\mathbf 1 \\right) : \\left( \\varepsilon - \\frac{1}{3} \\text{tr} \\varepsilon \\mathbf 1 \\right)$ to the right-hand side of the temperature equation.\n\n`shear heating with melt': Implementation of a standard model for shear heating of migrating melt, including bulk (compression) heating $\\xi \\left( \\nabla \\cdot \\mathbf u_s \\right)^2 $ and heating due to melt segregation $\\frac{\\eta_f \\phi^2}{k} \\left( \\mathbf u_f - \\mathbf u_s \\right)^2 $. For full shear heating, this has to be used in combination with the heating model shear heating to also include shear heating for the solid part.",
            "pattern": "906",
            "pattern_description": "[MultipleSelection adiabatic heating|adiabatic heating of melt|compositional heating|constant heating|function|latent heat|latent heat melt|radioactive decay|shear heating|shear heating with melt ]"
        },
        "Adiabatic heating": {
            "Use simplified adiabatic heating": {
                "value": "false",
                "default_value": "false",
                "documentation": "A flag indicating whether the adiabatic heating should be simplified from $\\alpha T (\\mathbf u \\cdot \\nabla p)$ to $ \\alpha \\rho T (\\mathbf u \\cdot \\mathbf g) $.",
                "pattern": "918",
                "pattern_description": "[Bool]"
            }
        },
        "Adiabatic heating of melt": {
            "Use simplified adiabatic heating": {
                "value": "false",
                "default_value": "false",
                "documentation": "A flag indicating whether the adiabatic heating should be simplified from $\\alpha T (\\mathbf u \\cdot \\nabla p)$ to $ \\alpha \\rho T (\\mathbf u \\cdot \\mathbf g) $.",
                "pattern": "919",
                "pattern_description": "[Bool]"
            }
        },
        "Compositional heating": {
            "Compositional heating values": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "List of heat production per unit volume values for background and compositional fields, for a total of N+1 values, where the first value corresponds to the background material, and N is the number of compositional fields. Units: \\si{\\watt\\per\\meter\\cubed}.",
                "pattern": "920",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Use compositional field for heat production averaging": {
                "value": "1",
                "default_value": "1",
                "documentation": "A list of integers with as many entries as compositional fields plus one. The first entry corresponds to the background material, each following entry corresponds to a particular compositional field. If the entry for a field is '1' this field is considered during the computation of volume fractions, if it is '0' the field is ignored. This is useful if some compositional fields are used to track properties like finite strain that should not contribute to heat production. The first entry determines whether the background field contributes to heat production or not (essentially similar to setting its 'Compositional heating values' to zero, but included for consistency in the length of the input lists).",
                "pattern": "921",
                "pattern_description": "[List of <[Integer range 0...1 (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Constant heating": {
            "Radiogenic heating rate": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The specific rate of heating due to radioactive decay (or other bulk sources you may want to describe). This parameter corresponds to the variable $H$ in the temperature equation stated in the manual, and the heating term is $\rho H$. Units: W\/kg.",
                "pattern": "922",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "925",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "924",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "923",
                "pattern_description": "[Anything]"
            }
        },
        "Latent heat melt": {
            "Melting entropy change": {
                "value": "-300.",
                "default_value": "-300.",
                "documentation": "The entropy change for the phase transition from solid to melt. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "926",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Retrieve entropy change from material model": {
                "value": "false",
                "default_value": "false",
                "documentation": "Instead of using the entropy change given in the 'Melting entropy change' query the EnthalpyAdditionalOutputs in the material model to compute the entropy change for the phase transition from solid to melt.Units: $J\/(kg K)$.",
                "pattern": "927",
                "pattern_description": "[Bool]"
            }
        },
        "Radioactive decay": {
            "Crust composition number": {
                "value": "0",
                "default_value": "0",
                "documentation": "Which composition field should be treated as crust",
                "pattern": "914",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Crust defined by composition": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether crust defined by composition or depth",
                "pattern": "912",
                "pattern_description": "[Bool]"
            },
            "Crust depth": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Depth of the crust when crust if defined by depth. Units: \\si{\\meter}.",
                "pattern": "913",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Half decay times": {
                "value": "",
                "default_value": "",
                "documentation": "Half decay times. Units: (Seconds), or (Years) if set `use years instead of seconds'.",
                "pattern": "909",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Heating rates": {
                "value": "",
                "default_value": "",
                "documentation": "Heating rates of different elements (W\/kg)",
                "pattern": "908",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Initial concentrations crust": {
                "value": "",
                "default_value": "",
                "documentation": "Initial concentrations of different elements (ppm)",
                "pattern": "910",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Initial concentrations mantle": {
                "value": "",
                "default_value": "",
                "documentation": "Initial concentrations of different elements (ppm)",
                "pattern": "911",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Number of elements": {
                "value": "0",
                "default_value": "0",
                "documentation": "Number of radioactive elements",
                "pattern": "907",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            }
        },
        "Shear heating": {
            "Cohesion for maximum shear stress": {
                "value": "2e7",
                "default_value": "2e7",
                "documentation": "Cohesion for maximum shear stress that should be used for the computation of shear heating. It can be useful to limit the shear stress in models where velocities are prescribed, and actual stresses in the Earth would be lower than the stresses introduced by the boundary conditions. Only used if 'Limit stress contribution to shear heating' is true. Units: Pa.",
                "pattern": "916",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Friction angle for maximum shear stress": {
                "value": "0",
                "default_value": "0",
                "documentation": "Friction angle for maximum shear stress that should be used for the computation of shear heating. It can be useful to limit the shear stress in models where velocities are prescribed, and actual stresses in the Earth would be lower than the stresses introduced by the boundary conditions. Only used if 'Limit stress contribution to shear heating' is true. Units: none.",
                "pattern": "917",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Limit stress contribution to shear heating": {
                "value": "false",
                "default_value": "false",
                "documentation": "In models with prescribed boundary velocities, stresses can become unrealistically large. Using these large stresses when calculating the amount of shear heating would then lead to an unreasonable increase in temperature. This parameter indicates if the stress being used to compute the amount of shear heating should be limited based on a Drucker-Prager yield criterion with the cohesion given by the 'Cohesion for maximum shear stress' parameter and the friction angle given by the 'Friction angle for maximum shear stress' parameter.",
                "pattern": "915",
                "pattern_description": "[Bool]"
            }
        }
    },
    "Initial composition model": {
        "List of model names": {
            "value": "",
            "default_value": "",
            "documentation": "A comma-separated list of initial composition models that together describe the initial composition field. These plugins are loaded in the order given, and modify the existing composition field via the operators listed in 'List of model operators'.\n\nThe following composition models are available:\n\n`adiabatic density': Specify the initial composition as the adiabatic reference density at each position. Note that only the field of the type 'density' will be filled. For all other fields this plugin returns 0.0.\n\n`ascii data': Implementation of a model in which the initial composition is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `y', `composition1', `composition2', etc. in a 2d model and `x', `y', `z', `composition1', `composition2', etc. in a 3d model, according to the number of compositional fields, which means that there has to be a single column for every composition in the model.Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second and the third at last in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`ascii data layered': Implementation of a model in which the initial composition is derived from files containing data in ascii format. Each file defines a surface on which compositional fields are defined. Between the surfaces, the fields can be chosen to be constant (with a value defined by the nearest shallower surface), or linearly interpolated between surfaces. Note the required format of the input ascii data file: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `y', `composition1', `composition2' etc. in a 2d model and `x', `y', `z', `composition1', `composition2' etc. in a 3d model; i.e. the columns before the compositional field always contains the position of the surface along the vertical direction. The first column needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the azimuth angle and `y' (if 3d) by the polar angle measured positive from the north pole. The last column will be the distance of the point from the origin (i.e. radial position). The grid in this case will be a latitude-longitude grid. Note that the order of spherical coordinates in 3d is `phi', `theta', `r', `T'and not `theta', `phi', `r', `T' as this is more consistent with other ASPECT plugins. Outside of the region defined by the grid, the plugin will use the value at the edge of the region.\n\n`entropy table lookup': A class that implements initial conditions for the entropy field by converting the initial temperature field through a look up table. Note that this plugin only works if there is a compositional field called `entropy', and an additional look up table that can convert pressure and temperature to entropy. For all compositional fields except entropy this plugin returns 0.0, and they are therefore not changed as long as the default `add' operator is selected for this plugin.\n\n`function': Specify the composition in terms of an explicit formula. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`porosity': A class that implements initial conditions for the porosity field by computing the equilibrium melt fraction for the given initial condition and reference pressure profile. Note that this plugin only works if there is a compositional field called `porosity', and the used material model implements the 'MeltFractionModel' interface. For all compositional fields except porosity this plugin returns 0.0, and they are therefore not changed as long as the default `add' operator is selected for this plugin.\n\n`slab model': An initial composition model that implements subducted slab geometries as a compositional field determined from an input file. The file defines the depth to the top of the slab and the slab thickness. The computed compositional value is 1 within the slabs and zero elsewhere. An example model that is included is Slab2 described in Hayes, G. P., Moore, G. L., Portner, D. E., Hearne, M., Flamme, H., Furtney, M., \\& Smoczyk, G. M. (2018). Slab2, a comprehensive subduction zone geometry model. Science, 362(6410), 58-61. The script to convert the Slab2 model into an aspect input data file is available in the directory data\/initial-composition\/slab-model\/. Please note that Slab2 and the example data file assume spherical geometry (latitude, longitude coordinates), however, that is not necessary for this plugin, data files in cartesian coordinates will work with box geometries.\n\n`world builder': Specify the initial composition through the World Builder. More information on the World Builder can be found at \\url{https:\/\/geodynamicworldbuilder.github.io}. Make sure to specify the location of the World Builder file in the parameter 'World builder file'. It is possible to use the World Builder only for selected compositional fields by specifying the parameter 'List of relevant compositions'.",
            "pattern": "1136",
            "pattern_description": "[MultipleSelection adiabatic density|ascii data|ascii data layered|entropy table lookup|function|porosity|slab model|world builder ]"
        },
        "List of model operators": {
            "value": "add",
            "default_value": "add",
            "documentation": "A comma-separated list of operators that will be used to append the listed composition models onto the previous models. If only one operator is given, the same operator is applied to all models.",
            "pattern": "1137",
            "pattern_description": "[MultipleSelection add|subtract|minimum|maximum|replace if valid ]"
        },
        "Model name": {
            "value": "unspecified",
            "default_value": "unspecified",
            "documentation": "Select one of the following models:\n\n`adiabatic density': Specify the initial composition as the adiabatic reference density at each position. Note that only the field of the type 'density' will be filled. For all other fields this plugin returns 0.0.\n\n`ascii data': Implementation of a model in which the initial composition is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `y', `composition1', `composition2', etc. in a 2d model and `x', `y', `z', `composition1', `composition2', etc. in a 3d model, according to the number of compositional fields, which means that there has to be a single column for every composition in the model.Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second and the third at last in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`ascii data layered': Implementation of a model in which the initial composition is derived from files containing data in ascii format. Each file defines a surface on which compositional fields are defined. Between the surfaces, the fields can be chosen to be constant (with a value defined by the nearest shallower surface), or linearly interpolated between surfaces. Note the required format of the input ascii data file: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `y', `composition1', `composition2' etc. in a 2d model and `x', `y', `z', `composition1', `composition2' etc. in a 3d model; i.e. the columns before the compositional field always contains the position of the surface along the vertical direction. The first column needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the azimuth angle and `y' (if 3d) by the polar angle measured positive from the north pole. The last column will be the distance of the point from the origin (i.e. radial position). The grid in this case will be a latitude-longitude grid. Note that the order of spherical coordinates in 3d is `phi', `theta', `r', `T'and not `theta', `phi', `r', `T' as this is more consistent with other ASPECT plugins. Outside of the region defined by the grid, the plugin will use the value at the edge of the region.\n\n`entropy table lookup': A class that implements initial conditions for the entropy field by converting the initial temperature field through a look up table. Note that this plugin only works if there is a compositional field called `entropy', and an additional look up table that can convert pressure and temperature to entropy. For all compositional fields except entropy this plugin returns 0.0, and they are therefore not changed as long as the default `add' operator is selected for this plugin.\n\n`function': Specify the composition in terms of an explicit formula. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`porosity': A class that implements initial conditions for the porosity field by computing the equilibrium melt fraction for the given initial condition and reference pressure profile. Note that this plugin only works if there is a compositional field called `porosity', and the used material model implements the 'MeltFractionModel' interface. For all compositional fields except porosity this plugin returns 0.0, and they are therefore not changed as long as the default `add' operator is selected for this plugin.\n\n`slab model': An initial composition model that implements subducted slab geometries as a compositional field determined from an input file. The file defines the depth to the top of the slab and the slab thickness. The computed compositional value is 1 within the slabs and zero elsewhere. An example model that is included is Slab2 described in Hayes, G. P., Moore, G. L., Portner, D. E., Hearne, M., Flamme, H., Furtney, M., \\& Smoczyk, G. M. (2018). Slab2, a comprehensive subduction zone geometry model. Science, 362(6410), 58-61. The script to convert the Slab2 model into an aspect input data file is available in the directory data\/initial-composition\/slab-model\/. Please note that Slab2 and the example data file assume spherical geometry (latitude, longitude coordinates), however, that is not necessary for this plugin, data files in cartesian coordinates will work with box geometries.\n\n`world builder': Specify the initial composition through the World Builder. More information on the World Builder can be found at \\url{https:\/\/geodynamicworldbuilder.github.io}. Make sure to specify the location of the World Builder file in the parameter 'World builder file'. It is possible to use the World Builder only for selected compositional fields by specifying the parameter 'List of relevant compositions'.\n\n\\textbf{Warning}: This parameter provides an old and deprecated way of specifying initial composition models and shouldn't be used. Please use 'List of model names' instead.",
            "pattern": "1138",
            "pattern_description": "[Selection adiabatic density|ascii data|ascii data layered|entropy table lookup|function|porosity|slab model|world builder|unspecified ]"
        },
        "Volume of fluid initialization type": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list denoting the method to be used to initialize a composition field specified to be advected using the volume of fluid method.\n\nThe format of valid entries for this parameter is that of a map given as ``key1:value1, key2:value2`` where each key must be the name of a compositional field using the volume of fluid advection method, and the value is one of ``composition`` or ``level set``. ``composition`` is the default\n\nWhen ``composition is specified, the initial model is treated as a standard composition field with bounds between 0 and 1 assumed, The initial fluid fractions are then based on an iterated midpoint quadrature. Resultant volume fractions outside of the bounds will be coerced to the nearest valid value (ie 0 or 1). If ``level set`` is specified, the initial data will be assumed to be in the form of a signed distance level set function (i.e. a function which is positive when in the fluid, negative outside, and zero on the interface and the magnitude is always the distance to the interface so the gradient is one everywhere).",
            "pattern": "98",
            "pattern_description": "[Map of <[Anything]>:<[Selection composition|level set ]> of length 0...4294967295 (inclusive)]"
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-composition\/ascii-data\/test\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-composition\/ascii-data\/test\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT. ",
                "pattern": "1153",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "initial_composition_top_mantle_box_3d.txt",
                "default_value": "initial_composition_top_mantle_box_3d.txt",
                "documentation": "The file name of the model data.",
                "pattern": "1151",
                "pattern_description": "[Anything]"
            },
            "Data file names": {
                "value": "initial_composition_top_mantle_box_3d.txt",
                "default_value": "initial_composition_top_mantle_box_3d.txt",
                "documentation": "The file names of the model data (comma separated). ",
                "pattern": "1154",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "First point on slice": {
                "value": "0.0,1.0,0.0",
                "default_value": "0.0,1.0,0.0",
                "documentation": "Point that determines the plane in which the 2d slice lies in. This variable is only used if 'Slice dataset in 2d plane' is true. The slice will go through this point, the point defined by the parameter 'Second point on slice', and the center of the model domain. After the rotation, this first point will lie along the (0,1,0) axis of the coordinate system. The coordinates of the point have to be given in Cartesian coordinates.",
                "pattern": "1148",
                "pattern_description": "[Anything]"
            },
            "Interpolation scheme": {
                "value": "linear",
                "default_value": "linear",
                "documentation": "Method to interpolate between layer boundaries. Select from piecewise constant or linear. Piecewise constant takes the value from the nearest layer boundary above the data point. The linear option interpolates linearly between layer boundaries. Above and below the domain given by the layer boundaries, the values aregiven by the top and bottom layer boundary.",
                "pattern": "1155",
                "pattern_description": "[Selection piecewise constant|linear ]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1152",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Second point on slice": {
                "value": "1.0,0.0,0.0",
                "default_value": "1.0,0.0,0.0",
                "documentation": "Second point that determines the plane in which the 2d slice lies in. This variable is only used if 'Slice dataset in 2d plane' is true. The slice will go through this point, the point defined by the parameter 'First point on slice', and the center of the model domain. The coordinates of the point have to be given in Cartesian coordinates.",
                "pattern": "1149",
                "pattern_description": "[Anything]"
            },
            "Slice dataset in 2D plane": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to use a 2d data slice of a 3d data file or the entire data file. Slicing a 3d dataset is only supported for 2d models.",
                "pattern": "1147",
                "pattern_description": "[Bool]"
            }
        },
        "Entropy table lookup": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/material-model\/entropy-table\/pyrtable\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/material-model\/entropy-table\/pyrtable\/",
                "documentation": "The path to the model data. The path may also include the special text '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1156",
                "pattern_description": "[DirectoryName]"
            },
            "Material file name": {
                "value": "material_table_temperature_pressure.txt",
                "default_value": "material_table_temperature_pressure.txt",
                "documentation": "The file name of the material data.",
                "pattern": "1157",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Function": {
            "Coordinate system": {
                "value": "cartesian",
                "default_value": "cartesian",
                "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `cartesian', `spherical', and `depth'. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. `depth' will create a function, in which only the first parameter is non-zero, which is interpreted to be the depth of the point.",
                "pattern": "1158",
                "pattern_description": "[Selection cartesian|spherical|depth ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1161",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1160",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1159",
                "pattern_description": "[Anything]"
            }
        },
        "Slab model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-composition\/slab-model\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-composition\/slab-model\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1139",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "shell_3d.txt",
                "default_value": "shell_3d.txt",
                "documentation": "The file name of the model data. Provide file in format: (File name).\\%s, where \\%s is a string specifying the boundary of the model according to the names of the boundary indicators (of the chosen geometry model).",
                "pattern": "1142",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1141",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "World builder": {
            "List of relevant compositions": {
                "value": "",
                "default_value": "",
                "documentation": "A list of names of compositional fields for which to determine the initial composition using the World Builder. As World Builder evaluations can be expensive, this parameter allows to only evaluate the fields that are relevant. This plugin returns 0.0 for all compositions that are not selected in the list. By default the list is empty and the world builder is evaluated for all compositional fields.",
                "pattern": "1143",
                "pattern_description": "[Anything]"
            }
        }
    },
    "Initial temperature model": {
        "List of model names": {
            "value": "",
            "default_value": "",
            "documentation": "A comma-separated list of initial temperature models that will be used to initialize the temperature. These plugins are loaded in the order given, and modify the existing temperature field via the operators listed in 'List of model operators'.\n\nThe following initial temperature models are available:\n\n`S40RTS perturbation': An initial temperature field in which the temperature is perturbed following the S20RTS or S40RTS shear wave velocity model by Ritsema and others, which can be downloaded here \\url{http:\/\/www.earth.lsa.umich.edu\/~jritsema\/research.html}. Information on the vs model can be found in Ritsema, J., Deuss, A., van Heijst, H.J. \\& Woodhouse, J.H., 2011. S40RTS: a degree-40 shear-velocity model for the mantle from new Rayleigh wave dispersion, teleseismic traveltime and normal-mode splitting function measurements, Geophys. J. Int. 184, 1223-1236. The scaling between the shear wave perturbation and the density perturbation can be constant and set by the user with the 'Vs to density scaling' parameter or depth-dependent and read in from a file. To convert density the user can specify the 'Thermal expansion coefficient in initial temperature scaling' parameter. The scaling is as follows: $\\delta \\ln \\rho (r,\\theta,\\phi) = \\xi \\cdot \\delta \\ln v_s(r,\\theta, \\phi)$ and $\\delta T(r,\\theta,\\phi) = - \\frac{1}{\\alpha} \\delta \\ln \\rho(r,\\theta,\\phi)$. $\\xi$ is the `vs to density scaling' parameter and $\\alpha$ is the 'Thermal expansion coefficient in initial temperature scaling' parameter. The temperature perturbation is added to an otherwise constant temperature (incompressible model) or adiabatic reference profile (compressible model). If a depth is specified in 'Remove temperature heterogeneity down to specified depth', there is no temperature perturbation prescribed down to that depth.\nNote the required file format if the vs to density scaling is read in from a file: The first lines may contain any number of comments if they begin with '#', but one of these lines needs to contain the number of points in the reference state as for example '# POINTS: 3'. Following the comment lines there has to be a single line containing the names of all data columns, separated by arbitrarily many spaces. Column names are not allowed to contain spaces. The file can contain unnecessary columns, but for this plugin it needs to at least provide the columns named `depth' and `vs\\_to\\_density'. Note that the data lines in the file need to be sorted in order of increasing depth from 0 to the maximal depth in the model domain. Points in the model that are outside of the provided depth range will be assigned the maximum or minimum depth values, respectively. Points do not need to be equidistant, but the computation of properties is optimized in speed if they are.\nIf the plugin is used in 2d it will use an equatorial slice of the seismic tomography model.\n\n`SAVANI perturbation': An initial temperature field in which the temperature is perturbed following the SAVANI shear wave velocity model by Auer and others, which can be downloaded here \\url{http:\/\/n.ethz.ch\/~auerl\/savani.tar.bz2}. Information on the vs model can be found in Auer, L., Boschi, L., Becker, T.W., Nissen-Meyer, T. \\& Giardini, D., 2014. Savani: A variable resolution whole-mantle model of anisotropic shear velocity variations based on multiple data sets. Journal of Geophysical Research: Solid Earth 119.4 (2014): 3006-3034. The scaling between the shear wave perturbation and the density perturbation can be constant and set by the user with the 'Vs to density scaling' parameter or depth-dependent and read in from a file. To convert density the user can specify the 'Thermal expansion coefficient in initial temperature scaling' parameter. The scaling is as follows: $\\delta \\ln \\rho (r,\\theta,\\phi) = \\xi \\cdot \\delta \\ln v_s(r,\\theta, \\phi)$ and $\\delta T(r,\\theta,\\phi) = - \\frac{1}{\\alpha} \\delta \\ln \\rho(r,\\theta,\\phi)$. $\\xi$ is the `vs to density scaling' parameter and $\\alpha$ is the 'Thermal expansion coefficient in initial temperature scaling' parameter. The temperature perturbation is added to an otherwise constant temperature (incompressible model) or adiabatic reference profile (compressible model).If a depth is specified in 'Remove temperature heterogeneity down to specified depth', there is no temperature perturbation prescribed down to that depth.\nNote the required file format if the vs to density scaling is read in from a file: The first lines may contain any number of comments if they begin with '#', but one of these lines needs to contain the number of points in the reference state as for example '# POINTS: 3'. Following the comment lines there has to be a single line containing the names of all data columns, separated by arbitrarily many spaces. Column names are not allowed to contain spaces. The file can contain unnecessary columns, but for this plugin it needs to at least provide the columns named `depth' and `vs\\_to\\_density'. Note that the data lines in the file need to be sorted in order of increasing depth from 0 to the maximal depth in the model domain. Points in the model that are outside of the provided depth range will be assigned the maximum or minimum depth values, respectively. Points do not need to be equidistant, but the computation of properties is optimized in speed if they are.\n\n`adiabatic': Temperature is prescribed as an adiabatic profile with upper and lower thermal boundary layers, whose ages are given as input parameters. Note that this plugin uses the 'Adiabatic conditions model' to compute the adiabat. Thus, the results depend on variables defined outside of this specific subsection; e.g. the globally defined 'Adiabatic surface temperature', and the variables defined in the 'Material model' section including densities, heat capacities and thermal expansivities.\n\n`adiabatic boundary': An initial temperature condition that allows for discretizing the model domain into two layers separated by a user-defined isothermal boundary. The user includes an input ascii data file that is formatted as 3 columns of `longitude(radians)', `colatitude(radians)', and `isotherm depth(meters)', where `isotherm depth' represents the depth of an initial temperature of 1673.15 K (by default). The first lines in the data file may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 69 121'. Note that the coordinates need to be sorted in a specific order: the `longitude' coordinate needs to ascend first, followed by the `colatitude' coordinate in order to assign the correct data (isotherm depth) to the prescribed coordinates. The temperature is defined from the surface (273.15 K) to the isotherm depth (1673.15 K) as a linear gradient. Below the isotherm depth the temperature increases approximately adiabatically (0.0005 K per meter). This plugin should work for all geometry models, but is currently only tested for spherical models.\n\n`ascii data': Implementation of a model in which the initial temperature is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `y', `Temperature [K]' in a 2d model and  `x', `y', `z', `Temperature [K]' in a 3d model, which means that there has to be a single column containing the temperature. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second and the third at last in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`ascii data layered': Implementation of a model in which the initial temperature is derived from files containing data in ascii format. Each file defines a surface on which temperature is defined. Between the surfaces, the temperatures can be chosen to be constant (with a value defined by the nearest shallower surface), or linearly interpolated between surfaces. Note the required format of the input ascii data file: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `y', `Temperature [K]' in a 2d model and `x', `y', `z', `Temperature [K]' in a 3d model; i.e. the last two columns always contain the position of the isotherm along the vertical direction, and the temperature at that point. The first column needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the azimuth angle and `y' (if 3d) by the polar angle measured positive from the north pole. The last column will be the distance of the point from the origin (i.e. radial position). The grid in this case will be a latitude-longitude grid. Note that the order of spherical coordinates in 3d is `phi', `theta', `r', `T'and not `theta', `phi', `r', `T' as this is more consistent with other ASPECT plugins. Outside of the region defined by the grid, the plugin will use the value at the edge of the region.\n\n`ascii profile': Implementation of a model in which the initial temperature is read from a file that provides these values as a function of depth. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of points in the temperature profile, for example `# POINTS: 10'. Following the comment lines, there has to be a single line containing the names of all data columns, separated by arbitrarily many spaces. Column names are not allowed to contain spaces. The file can contain unnecessary columns, but for this plugin it needs to at least provide columns named `depth' and`temperature'.Note that the data lines in the file need to be sorted in order of increasing depth from 0 to the maximal depth in the model domain. Points in the model that are outside of the provided depth range will be assigned the maximum or minimum depth values, respectively. Points do not need to be equidistant, but the computation of properties is optimized in speed if they are.\n\n`continental geotherm': This is a temperature initial condition that computes a continental geotherm based on the solution of the steady-state conductive equation $k\\frac{d^2 T}{dy^2}+\\rho H = 0$ as described in e.g. Turcotte and Schubert, Ch. 4.6, or Chapman (1986). As boundary conditions, we take the surface temperature and the temperature of the Lithosphere-Asthenosphere Boundary (LAB). \nThe geotherm is computed for a homogeneous lithosphere composed of an upper crust, lower crust and mantle layer. The crustal layers are assumed to have a constant radioactive heating, and all layers are assumed to have a constant thermal conductivity. Layer thicknesses, surface temperature and LAB temperature should be specified by the user. For consistency, the density, heat production and thermal conductivity of each layer are read from the visco plastic material model and the compositional heating model. \nFor any depths below the depth of the LAB, a unrealistically high temperature is returned, such that this plugin can be combined with another temperature plugin through the 'minimum' operator. \nNote that the current implementation only works for a 3-layer lithosphere, even though in principle the heat conduction equation can be solved for any number of layers. The naming of the compositional fields that represent the layers is also very specific, namely `upper\\_crust', `lower\\_crust', and `lithospheric\\_mantle'. \nMake sure the top and bottom temperatures of the lithosphere agree with temperatures set in for example the temperature boundary conditions.\n\n`function': Specify the initial temperature in terms of an explicit formula. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`harmonic perturbation': An initial temperature field in which the temperature is perturbed following a harmonic function (spherical harmonic or sine depending on geometry and dimension) in lateral and radial direction from an otherwise constant temperature (incompressible model) or adiabatic reference profile (compressible model).\n\n`inclusion shape perturbation': An initial temperature field in which there is an inclusion in a constant-temperature box field. The size, shape, gradient, position, and temperature of the inclusion are defined by parameters.\n\n`lithosphere mask': Implementation of a model in which the initial temperature is set to a specified lithosphere temperature above the lithosphere-asthenosphere boundary (specified by an ascii file or maximum lithosphere depth value). Below this the initial temperature is set as NaN.  Note the required format of the input data file: The first lines may contain any number of comments if they begin with '#', but one of these lines needs to contain the number of grid points in each dimension as for example '# POINTS: 3 3'. For a spherical model, the order of the data columns has to be 'phi', 'theta', 'depth (m)', where phi is the azimuth angle and theta is the polar angle measured positive from the north pole. This plug-in can be combined with another using the 'replace if valid' operator. \n\n`mandelbox': Fractal-shaped temperature field.\n\n`patch on S40RTS': Implementation of a model in which the initial temperature is derived from a file containing shear wave velocity perturbations in ascii format (e.g. a high resolution upper mantle tomography) combined with S40RTS. Note the required format of the input ascii input data: The first lines may contain any number of comments if they begin with '#', but one of these lines needs to contain the number of grid points in each dimension as for example '# POINTS: 3 3 3'. The order of the data columns has to be  `x', `y', `z', 'Vs Perturbation' in a 3d model, which means that there has to be a single column containing the temperature. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second and the third at last in order to assign the correct data to the prescribed coordinates. In the spherical model data will be handled as Cartesian, however, `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions. See S40RTS documentation for details on input parameters in the S40RTS perturbation subsection. The boundary between the two tomography models is smoothed using a depth weighted combination of Vs values within the region of smoothing. \n\n`perturbed box': An initial temperature field in which the temperature is perturbed slightly from an otherwise constant value equal to one. The perturbation is chosen in such a way that the initial temperature is constant to one along the entire boundary.\n\n`polar box': An initial temperature field in which the temperature is perturbed slightly from an otherwise constant value equal to one. The perturbation is such that there are two poles on opposing corners of the box. \n\n`prescribed temperature': This model fixes the initial temperature to the prescribed temperature outputs computed by the material model. This only works if the material model implements prescribed temperature outputs.\n\n`random Gaussian perturbation': An initial temperature field in which the temperature is perturbed from a temperature of zero following a given number of Gaussian perturbations placed randomly throughout the model domain. The number, width, and maximum magnitude of the perturbations can be chosen as model parameters. This plugin is meant to be used in combination with another initial temperature model that determines the background temperature (such as the 'function' or the 'adiabatic' plugin) using the 'add' operator to combine them.\n\n`spherical gaussian perturbation': An initial temperature field in which the temperature is perturbed by a single Gaussian added to an otherwise spherically symmetric state. Additional parameters are read from the parameter file in subsection 'Spherical gaussian perturbation'.\n\n`spherical hexagonal perturbation': An initial temperature field in which the temperature is perturbed following an $N$-fold pattern in a specified direction from an otherwise spherically symmetric state. The class's name comes from previous versions when the only option was $N=6$.\n\n`world builder': Specify the initial temperature through the World Builder. More information on the World Builder can be found at \\url{https:\/\/geodynamicworldbuilder.github.io}. Make sure to specify the location of the World Builder file in the parameter 'World builder file'.",
            "pattern": "1021",
            "pattern_description": "[MultipleSelection S40RTS perturbation|SAVANI perturbation|adiabatic|adiabatic boundary|ascii data|ascii data layered|ascii profile|continental geotherm|function|harmonic perturbation|inclusion shape perturbation|lithosphere mask|mandelbox|patch on S40RTS|perturbed box|polar box|prescribed temperature|random Gaussian perturbation|spherical gaussian perturbation|spherical hexagonal perturbation|world builder ]"
        },
        "List of model operators": {
            "value": "add",
            "default_value": "add",
            "documentation": "A comma-separated list of operators that will be used to append the listed temperature models onto the previous models. If only one operator is given, the same operator is applied to all models.",
            "pattern": "1022",
            "pattern_description": "[MultipleSelection add|subtract|minimum|maximum|replace if valid ]"
        },
        "Model name": {
            "value": "function",
            "default_value": "unspecified",
            "documentation": "Select one of the following models:\n\n`S40RTS perturbation': An initial temperature field in which the temperature is perturbed following the S20RTS or S40RTS shear wave velocity model by Ritsema and others, which can be downloaded here \\url{http:\/\/www.earth.lsa.umich.edu\/~jritsema\/research.html}. Information on the vs model can be found in Ritsema, J., Deuss, A., van Heijst, H.J. \\& Woodhouse, J.H., 2011. S40RTS: a degree-40 shear-velocity model for the mantle from new Rayleigh wave dispersion, teleseismic traveltime and normal-mode splitting function measurements, Geophys. J. Int. 184, 1223-1236. The scaling between the shear wave perturbation and the density perturbation can be constant and set by the user with the 'Vs to density scaling' parameter or depth-dependent and read in from a file. To convert density the user can specify the 'Thermal expansion coefficient in initial temperature scaling' parameter. The scaling is as follows: $\\delta \\ln \\rho (r,\\theta,\\phi) = \\xi \\cdot \\delta \\ln v_s(r,\\theta, \\phi)$ and $\\delta T(r,\\theta,\\phi) = - \\frac{1}{\\alpha} \\delta \\ln \\rho(r,\\theta,\\phi)$. $\\xi$ is the `vs to density scaling' parameter and $\\alpha$ is the 'Thermal expansion coefficient in initial temperature scaling' parameter. The temperature perturbation is added to an otherwise constant temperature (incompressible model) or adiabatic reference profile (compressible model). If a depth is specified in 'Remove temperature heterogeneity down to specified depth', there is no temperature perturbation prescribed down to that depth.\nNote the required file format if the vs to density scaling is read in from a file: The first lines may contain any number of comments if they begin with '#', but one of these lines needs to contain the number of points in the reference state as for example '# POINTS: 3'. Following the comment lines there has to be a single line containing the names of all data columns, separated by arbitrarily many spaces. Column names are not allowed to contain spaces. The file can contain unnecessary columns, but for this plugin it needs to at least provide the columns named `depth' and `vs\\_to\\_density'. Note that the data lines in the file need to be sorted in order of increasing depth from 0 to the maximal depth in the model domain. Points in the model that are outside of the provided depth range will be assigned the maximum or minimum depth values, respectively. Points do not need to be equidistant, but the computation of properties is optimized in speed if they are.\nIf the plugin is used in 2d it will use an equatorial slice of the seismic tomography model.\n\n`SAVANI perturbation': An initial temperature field in which the temperature is perturbed following the SAVANI shear wave velocity model by Auer and others, which can be downloaded here \\url{http:\/\/n.ethz.ch\/~auerl\/savani.tar.bz2}. Information on the vs model can be found in Auer, L., Boschi, L., Becker, T.W., Nissen-Meyer, T. \\& Giardini, D., 2014. Savani: A variable resolution whole-mantle model of anisotropic shear velocity variations based on multiple data sets. Journal of Geophysical Research: Solid Earth 119.4 (2014): 3006-3034. The scaling between the shear wave perturbation and the density perturbation can be constant and set by the user with the 'Vs to density scaling' parameter or depth-dependent and read in from a file. To convert density the user can specify the 'Thermal expansion coefficient in initial temperature scaling' parameter. The scaling is as follows: $\\delta \\ln \\rho (r,\\theta,\\phi) = \\xi \\cdot \\delta \\ln v_s(r,\\theta, \\phi)$ and $\\delta T(r,\\theta,\\phi) = - \\frac{1}{\\alpha} \\delta \\ln \\rho(r,\\theta,\\phi)$. $\\xi$ is the `vs to density scaling' parameter and $\\alpha$ is the 'Thermal expansion coefficient in initial temperature scaling' parameter. The temperature perturbation is added to an otherwise constant temperature (incompressible model) or adiabatic reference profile (compressible model).If a depth is specified in 'Remove temperature heterogeneity down to specified depth', there is no temperature perturbation prescribed down to that depth.\nNote the required file format if the vs to density scaling is read in from a file: The first lines may contain any number of comments if they begin with '#', but one of these lines needs to contain the number of points in the reference state as for example '# POINTS: 3'. Following the comment lines there has to be a single line containing the names of all data columns, separated by arbitrarily many spaces. Column names are not allowed to contain spaces. The file can contain unnecessary columns, but for this plugin it needs to at least provide the columns named `depth' and `vs\\_to\\_density'. Note that the data lines in the file need to be sorted in order of increasing depth from 0 to the maximal depth in the model domain. Points in the model that are outside of the provided depth range will be assigned the maximum or minimum depth values, respectively. Points do not need to be equidistant, but the computation of properties is optimized in speed if they are.\n\n`adiabatic': Temperature is prescribed as an adiabatic profile with upper and lower thermal boundary layers, whose ages are given as input parameters. Note that this plugin uses the 'Adiabatic conditions model' to compute the adiabat. Thus, the results depend on variables defined outside of this specific subsection; e.g. the globally defined 'Adiabatic surface temperature', and the variables defined in the 'Material model' section including densities, heat capacities and thermal expansivities.\n\n`adiabatic boundary': An initial temperature condition that allows for discretizing the model domain into two layers separated by a user-defined isothermal boundary. The user includes an input ascii data file that is formatted as 3 columns of `longitude(radians)', `colatitude(radians)', and `isotherm depth(meters)', where `isotherm depth' represents the depth of an initial temperature of 1673.15 K (by default). The first lines in the data file may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 69 121'. Note that the coordinates need to be sorted in a specific order: the `longitude' coordinate needs to ascend first, followed by the `colatitude' coordinate in order to assign the correct data (isotherm depth) to the prescribed coordinates. The temperature is defined from the surface (273.15 K) to the isotherm depth (1673.15 K) as a linear gradient. Below the isotherm depth the temperature increases approximately adiabatically (0.0005 K per meter). This plugin should work for all geometry models, but is currently only tested for spherical models.\n\n`ascii data': Implementation of a model in which the initial temperature is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `y', `Temperature [K]' in a 2d model and  `x', `y', `z', `Temperature [K]' in a 3d model, which means that there has to be a single column containing the temperature. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second and the third at last in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`ascii data layered': Implementation of a model in which the initial temperature is derived from files containing data in ascii format. Each file defines a surface on which temperature is defined. Between the surfaces, the temperatures can be chosen to be constant (with a value defined by the nearest shallower surface), or linearly interpolated between surfaces. Note the required format of the input ascii data file: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `y', `Temperature [K]' in a 2d model and `x', `y', `z', `Temperature [K]' in a 3d model; i.e. the last two columns always contain the position of the isotherm along the vertical direction, and the temperature at that point. The first column needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the azimuth angle and `y' (if 3d) by the polar angle measured positive from the north pole. The last column will be the distance of the point from the origin (i.e. radial position). The grid in this case will be a latitude-longitude grid. Note that the order of spherical coordinates in 3d is `phi', `theta', `r', `T'and not `theta', `phi', `r', `T' as this is more consistent with other ASPECT plugins. Outside of the region defined by the grid, the plugin will use the value at the edge of the region.\n\n`ascii profile': Implementation of a model in which the initial temperature is read from a file that provides these values as a function of depth. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of points in the temperature profile, for example `# POINTS: 10'. Following the comment lines, there has to be a single line containing the names of all data columns, separated by arbitrarily many spaces. Column names are not allowed to contain spaces. The file can contain unnecessary columns, but for this plugin it needs to at least provide columns named `depth' and`temperature'.Note that the data lines in the file need to be sorted in order of increasing depth from 0 to the maximal depth in the model domain. Points in the model that are outside of the provided depth range will be assigned the maximum or minimum depth values, respectively. Points do not need to be equidistant, but the computation of properties is optimized in speed if they are.\n\n`continental geotherm': This is a temperature initial condition that computes a continental geotherm based on the solution of the steady-state conductive equation $k\\frac{d^2 T}{dy^2}+\\rho H = 0$ as described in e.g. Turcotte and Schubert, Ch. 4.6, or Chapman (1986). As boundary conditions, we take the surface temperature and the temperature of the Lithosphere-Asthenosphere Boundary (LAB). \nThe geotherm is computed for a homogeneous lithosphere composed of an upper crust, lower crust and mantle layer. The crustal layers are assumed to have a constant radioactive heating, and all layers are assumed to have a constant thermal conductivity. Layer thicknesses, surface temperature and LAB temperature should be specified by the user. For consistency, the density, heat production and thermal conductivity of each layer are read from the visco plastic material model and the compositional heating model. \nFor any depths below the depth of the LAB, a unrealistically high temperature is returned, such that this plugin can be combined with another temperature plugin through the 'minimum' operator. \nNote that the current implementation only works for a 3-layer lithosphere, even though in principle the heat conduction equation can be solved for any number of layers. The naming of the compositional fields that represent the layers is also very specific, namely `upper\\_crust', `lower\\_crust', and `lithospheric\\_mantle'. \nMake sure the top and bottom temperatures of the lithosphere agree with temperatures set in for example the temperature boundary conditions.\n\n`function': Specify the initial temperature in terms of an explicit formula. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`harmonic perturbation': An initial temperature field in which the temperature is perturbed following a harmonic function (spherical harmonic or sine depending on geometry and dimension) in lateral and radial direction from an otherwise constant temperature (incompressible model) or adiabatic reference profile (compressible model).\n\n`inclusion shape perturbation': An initial temperature field in which there is an inclusion in a constant-temperature box field. The size, shape, gradient, position, and temperature of the inclusion are defined by parameters.\n\n`lithosphere mask': Implementation of a model in which the initial temperature is set to a specified lithosphere temperature above the lithosphere-asthenosphere boundary (specified by an ascii file or maximum lithosphere depth value). Below this the initial temperature is set as NaN.  Note the required format of the input data file: The first lines may contain any number of comments if they begin with '#', but one of these lines needs to contain the number of grid points in each dimension as for example '# POINTS: 3 3'. For a spherical model, the order of the data columns has to be 'phi', 'theta', 'depth (m)', where phi is the azimuth angle and theta is the polar angle measured positive from the north pole. This plug-in can be combined with another using the 'replace if valid' operator. \n\n`mandelbox': Fractal-shaped temperature field.\n\n`patch on S40RTS': Implementation of a model in which the initial temperature is derived from a file containing shear wave velocity perturbations in ascii format (e.g. a high resolution upper mantle tomography) combined with S40RTS. Note the required format of the input ascii input data: The first lines may contain any number of comments if they begin with '#', but one of these lines needs to contain the number of grid points in each dimension as for example '# POINTS: 3 3 3'. The order of the data columns has to be  `x', `y', `z', 'Vs Perturbation' in a 3d model, which means that there has to be a single column containing the temperature. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second and the third at last in order to assign the correct data to the prescribed coordinates. In the spherical model data will be handled as Cartesian, however, `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions. See S40RTS documentation for details on input parameters in the S40RTS perturbation subsection. The boundary between the two tomography models is smoothed using a depth weighted combination of Vs values within the region of smoothing. \n\n`perturbed box': An initial temperature field in which the temperature is perturbed slightly from an otherwise constant value equal to one. The perturbation is chosen in such a way that the initial temperature is constant to one along the entire boundary.\n\n`polar box': An initial temperature field in which the temperature is perturbed slightly from an otherwise constant value equal to one. The perturbation is such that there are two poles on opposing corners of the box. \n\n`prescribed temperature': This model fixes the initial temperature to the prescribed temperature outputs computed by the material model. This only works if the material model implements prescribed temperature outputs.\n\n`random Gaussian perturbation': An initial temperature field in which the temperature is perturbed from a temperature of zero following a given number of Gaussian perturbations placed randomly throughout the model domain. The number, width, and maximum magnitude of the perturbations can be chosen as model parameters. This plugin is meant to be used in combination with another initial temperature model that determines the background temperature (such as the 'function' or the 'adiabatic' plugin) using the 'add' operator to combine them.\n\n`spherical gaussian perturbation': An initial temperature field in which the temperature is perturbed by a single Gaussian added to an otherwise spherically symmetric state. Additional parameters are read from the parameter file in subsection 'Spherical gaussian perturbation'.\n\n`spherical hexagonal perturbation': An initial temperature field in which the temperature is perturbed following an $N$-fold pattern in a specified direction from an otherwise spherically symmetric state. The class's name comes from previous versions when the only option was $N=6$.\n\n`world builder': Specify the initial temperature through the World Builder. More information on the World Builder can be found at \\url{https:\/\/geodynamicworldbuilder.github.io}. Make sure to specify the location of the World Builder file in the parameter 'World builder file'.\n\n\\textbf{Warning}: This parameter provides an old and deprecated way of specifying initial temperature models and shouldn't be used. Please use 'List of model names' instead.",
            "pattern": "1023",
            "pattern_description": "[Selection S40RTS perturbation|SAVANI perturbation|adiabatic|adiabatic boundary|ascii data|ascii data layered|ascii profile|continental geotherm|function|harmonic perturbation|inclusion shape perturbation|lithosphere mask|mandelbox|patch on S40RTS|perturbed box|polar box|prescribed temperature|random Gaussian perturbation|spherical gaussian perturbation|spherical hexagonal perturbation|world builder|unspecified ]"
        },
        "Adiabatic": {
            "Age bottom boundary layer": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The age of the lower thermal boundary layer, used for the calculation of the half-space cooling model temperature. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "1115",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Age top boundary layer": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The age of the upper thermal boundary layer, used for the calculation of the half-space cooling model temperature. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "1114",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Amplitude": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The amplitude (in K) of the initial spherical temperature perturbation at the bottom of the model domain. This perturbation will be added to the adiabatic temperature profile, but not to the bottom thermal boundary layer. Instead, the maximum of the perturbation and the bottom boundary layer temperature will be used.",
                "pattern": "1117",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Cooling model": {
                "value": "half-space cooling",
                "default_value": "half-space cooling",
                "documentation": "Whether to use the half space cooling model or the plate cooling model",
                "pattern": "1121",
                "pattern_description": "[Selection half-space cooling|plate cooling ]"
            },
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/adiabatic\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/adiabatic\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1111",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "adiabatic.txt",
                "default_value": "adiabatic.txt",
                "documentation": "The file name of the model data.",
                "pattern": "1112",
                "pattern_description": "[Anything]"
            },
            "Lithosphere thickness": {
                "value": "125e3",
                "default_value": "125e3",
                "documentation": "Thickness of the lithosphere for plate cooling model. \\si{\\m}",
                "pattern": "1122",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Position": {
                "value": "center",
                "default_value": "center",
                "documentation": "Where the initial temperature perturbation should be placed. If `center' is given, then the perturbation will be centered along a `midpoint' of some sort of the bottom boundary. For example, in the case of a box geometry, this is the center of the bottom face; in the case of a spherical shell geometry, it is along the inner surface halfway between the bounding radial lines.",
                "pattern": "1118",
                "pattern_description": "[Selection center ]"
            },
            "Radius": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The Radius (in m) of the initial spherical temperature perturbation at the bottom of the model domain.",
                "pattern": "1116",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1113",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Subadiabaticity": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "If this value is larger than 0, the initial temperature profile will not be adiabatic, but subadiabatic. This value gives the maximal deviation from adiabaticity. Set to 0 for an adiabatic temperature profile. Units: \\si{\\kelvin}.\n\nThe function object in the Function subsection represents the compositional fields that will be used as a reference profile for calculating the thermal diffusivity. This function is one-dimensional and depends only on depth. The format of this functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.",
                "pattern": "1119",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Top boundary layer age model": {
                "value": "constant",
                "default_value": "constant",
                "documentation": "How to define the age of the top thermal boundary layer. Options are: 'constant' for a constant age specified by the parameter 'Age top boundary layer'; 'function' for an analytical function describing the age as specified in the subsection 'Age function'; and 'ascii data' to use an 'ascii data' file specified by the parameter 'Data file name'.",
                "pattern": "1120",
                "pattern_description": "[Selection constant|function|ascii data ]"
            },
            "Age function": {
                "Coordinate system": {
                    "value": "cartesian",
                    "default_value": "cartesian",
                    "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `cartesian', `spherical', and `depth'. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. `depth' will create a function, in which only the first parameter is non-zero, which is interpreted to be the depth of the point.",
                    "pattern": "1126",
                    "pattern_description": "[Selection cartesian|spherical ]"
                },
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "1129",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "0",
                    "default_value": "0",
                    "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                    "pattern": "1128",
                    "pattern_description": "[Anything]"
                },
                "Variable names": {
                    "value": "x,y,t",
                    "default_value": "x,y,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "1127",
                    "pattern_description": "[Anything]"
                }
            },
            "Function": {
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "1125",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "0",
                    "default_value": "0",
                    "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                    "pattern": "1124",
                    "pattern_description": "[Anything]"
                },
                "Variable names": {
                    "value": "x,t",
                    "default_value": "x,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "1123",
                    "pattern_description": "[Anything]"
                }
            }
        },
        "Adiabatic boundary": {
            "Adiabatic temperature gradient": {
                "value": "0.0005",
                "default_value": "0.0005",
                "documentation": "The value of the adiabatic temperature gradient. Units: \\si{\\kelvin\\per\\meter}.",
                "pattern": "1135",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/adiabatic-boundary\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/adiabatic-boundary\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1130",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "adiabatic_boundary.txt",
                "default_value": "adiabatic_boundary.txt",
                "documentation": "The file name of the model data.",
                "pattern": "1131",
                "pattern_description": "[Anything]"
            },
            "Isotherm temperature": {
                "value": "1673.15",
                "default_value": "1673.15",
                "documentation": "The value of the isothermal boundary temperature. Units: \\si{\\kelvin}.",
                "pattern": "1133",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1132",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Surface temperature": {
                "value": "273.15",
                "default_value": "273.15",
                "documentation": "The value of the surface temperature. Units: \\si{\\kelvin}.",
                "pattern": "1134",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/ascii-data\/test\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/ascii-data\/test\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT. ",
                "pattern": "1055",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "initial_isotherm_500K_box_3d.txt",
                "default_value": "initial_isotherm_500K_box_3d.txt",
                "documentation": "The file name of the model data.",
                "pattern": "1053",
                "pattern_description": "[Anything]"
            },
            "Data file names": {
                "value": "initial_isotherm_500K_box_3d.txt",
                "default_value": "initial_isotherm_500K_box_3d.txt",
                "documentation": "The file names of the model data (comma separated). ",
                "pattern": "1056",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "First point on slice": {
                "value": "0.0,1.0,0.0",
                "default_value": "0.0,1.0,0.0",
                "documentation": "Point that determines the plane in which the 2d slice lies in. This variable is only used if 'Slice dataset in 2d plane' is true. The slice will go through this point, the point defined by the parameter 'Second point on slice', and the center of the model domain. After the rotation, this first point will lie along the (0,1,0) axis of the coordinate system. The coordinates of the point have to be given in Cartesian coordinates.",
                "pattern": "1050",
                "pattern_description": "[Anything]"
            },
            "Interpolation scheme": {
                "value": "linear",
                "default_value": "linear",
                "documentation": "Method to interpolate between layer boundaries. Select from piecewise constant or linear. Piecewise constant takes the value from the nearest layer boundary above the data point. The linear option interpolates linearly between layer boundaries. Above and below the domain given by the layer boundaries, the values aregiven by the top and bottom layer boundary.",
                "pattern": "1057",
                "pattern_description": "[Selection piecewise constant|linear ]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1054",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Second point on slice": {
                "value": "1.0,0.0,0.0",
                "default_value": "1.0,0.0,0.0",
                "documentation": "Second point that determines the plane in which the 2d slice lies in. This variable is only used if 'Slice dataset in 2d plane' is true. The slice will go through this point, the point defined by the parameter 'First point on slice', and the center of the model domain. The coordinates of the point have to be given in Cartesian coordinates.",
                "pattern": "1051",
                "pattern_description": "[Anything]"
            },
            "Slice dataset in 2D plane": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to use a 2d data slice of a 3d data file or the entire data file. Slicing a 3d dataset is only supported for 2d models.",
                "pattern": "1049",
                "pattern_description": "[Bool]"
            }
        },
        "Ascii profile": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/ascii-profile\/tests\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/ascii-profile\/tests\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1058",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "simple_test.txt",
                "default_value": "simple_test.txt",
                "documentation": "The file name of the model data.",
                "pattern": "1059",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1060",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Continental geotherm": {
            "Layer thicknesses": {
                "value": "30000.",
                "default_value": "30000.",
                "documentation": "List of the 3 thicknesses of the lithospheric layers 'upper\\_crust', 'lower\\_crust' and 'mantle\\_lithosphere'. If only one thickness is given, then the same thickness is used for all layers. Units: \\si{meter}.",
                "pattern": "1069",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Lithosphere-Asthenosphere boundary isotherm": {
                "value": "1673.15",
                "default_value": "1673.15",
                "documentation": "The value of the isotherm that is assumed at the Lithosphere-Asthenosphere boundary. Units: \\si{\\kelvin}.",
                "pattern": "1071",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Surface temperature": {
                "value": "273.15",
                "default_value": "273.15",
                "documentation": "The value of the surface temperature. Units: \\si{\\kelvin}.",
                "pattern": "1070",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Function": {
            "Coordinate system": {
                "value": "cartesian",
                "default_value": "cartesian",
                "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `cartesian', `spherical', and `depth'. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. `depth' will create a function, in which only the first parameter is non-zero, which is interpreted to be the depth of the point.",
                "pattern": "1072",
                "pattern_description": "[Selection cartesian|spherical|depth ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1075",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "sqrt((x-250.e3)^2 + (y-100.e3)^2) < 25.e3 ? 200.0 : 0.0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1074",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1073",
                "pattern_description": "[Anything]"
            }
        },
        "Harmonic perturbation": {
            "Lateral wave number one": {
                "value": "3",
                "default_value": "3",
                "documentation": "Doubled first lateral wave number of the harmonic perturbation. Equals the spherical harmonic degree in 3d spherical shells. In all other cases one equals half of a sine period over the model domain. This allows for single up-\/downswings. Negative numbers reverse the sign of the perturbation but are not allowed for the spherical harmonic case.",
                "pattern": "1077",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            },
            "Lateral wave number two": {
                "value": "2",
                "default_value": "2",
                "documentation": "Doubled second lateral wave number of the harmonic perturbation. Equals the spherical harmonic order in 3d spherical shells. In all other cases one equals half of a sine period over the model domain. This allows for single up-\/downswings. Negative numbers reverse the sign of the perturbation.",
                "pattern": "1078",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            },
            "Magnitude": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "The magnitude of the Harmonic perturbation.",
                "pattern": "1079",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "1600.0",
                "default_value": "1600.0",
                "documentation": "The reference temperature that is perturbed by the harmonic function. Only used in incompressible models.",
                "pattern": "1080",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Vertical wave number": {
                "value": "1",
                "default_value": "1",
                "documentation": "Doubled radial wave number of the harmonic perturbation.  One equals half of a sine period over the model domain.  This allows for single up-\/downswings. Negative numbers  reverse the sign of the perturbation.",
                "pattern": "1076",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            }
        },
        "Inclusion shape perturbation": {
            "Ambient temperature": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "The background temperature for the temperature field.",
                "pattern": "1064",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Center X": {
                "value": "0.5",
                "default_value": "0.5",
                "documentation": "The X coordinate for the center of the shape.",
                "pattern": "1066",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Center Y": {
                "value": "0.5",
                "default_value": "0.5",
                "documentation": "The Y coordinate for the center of the shape.",
                "pattern": "1067",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Center Z": {
                "value": "0.5",
                "default_value": "0.5",
                "documentation": "The Z coordinate for the center of the shape. This is only necessary for three-dimensional fields.",
                "pattern": "1068",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Inclusion gradient": {
                "value": "constant",
                "default_value": "constant",
                "documentation": "The gradient of the inclusion to be generated.",
                "pattern": "1062",
                "pattern_description": "[Selection gaussian|linear|constant ]"
            },
            "Inclusion shape": {
                "value": "circle",
                "default_value": "circle",
                "documentation": "The shape of the inclusion to be generated.",
                "pattern": "1061",
                "pattern_description": "[Selection square|circle ]"
            },
            "Inclusion temperature": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature of the inclusion shape. This is only the true temperature in the case of the constant gradient. In all other cases, it gives one endpoint of the temperature gradient for the shape.",
                "pattern": "1065",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Shape radius": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "The radius of the inclusion to be generated. For shapes with no radius (e.g. square), this will be the width, and for shapes with no width, this gives a general guideline for the size of the shape.",
                "pattern": "1063",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Lithosphere Mask": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/lithosphere-mask\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/lithosphere-mask\/",
                "documentation": "The path to the LAB depth data file",
                "pattern": "1026",
                "pattern_description": "[DirectoryName]"
            },
            "Depth specification method": {
                "value": "Value",
                "default_value": "Value",
                "documentation": "Method that is used to specify the depth of the lithosphere-asthenosphere boundary.",
                "pattern": "1024",
                "pattern_description": "[Selection File|Value ]"
            },
            "LAB depth filename": {
                "value": "LAB_CAM2016.txt",
                "default_value": "LAB_CAM2016.txt",
                "documentation": "File from which the lithosphere-asthenosphere boundary depth data is read.",
                "pattern": "1027",
                "pattern_description": "[FileName (Type: input)]"
            },
            "Lithosphere temperature": {
                "value": "1600.",
                "default_value": "1600.",
                "documentation": "The initial temperature within lithosphere, applied abovethe maximum lithosphere depth.",
                "pattern": "1028",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum lithosphere depth": {
                "value": "200000.0",
                "default_value": "200000.0",
                "documentation": "Units: \\si{\\meter}.The maximum depth of the lithosphere. The model will be NaNs below this depth.",
                "pattern": "1025",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Patch on S40RTS": {
            "Maximum grid depth": {
                "value": "700000.0",
                "default_value": "700000.0",
                "documentation": "The maximum depth of the Vs ascii grid. The model will read in  Vs from S40RTS below this depth.",
                "pattern": "1029",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Remove temperature heterogeneity down to specified depth": {
                "value": "-1.7976931348623157e+308",
                "default_value": "-1.7976931348623157e+308",
                "documentation": "This will set the heterogeneity prescribed by the Vs ascii grid and S40RTS to zero down to the specified depth (in meters). Note that your resolution has to be adequate to capture this cutoff. For example if you specify a depth of 660km, but your closest spherical depth layers are only at 500km and 750km (due to a coarse resolution) it will only zero out heterogeneities down to 500km. Similar caution has to be taken when using adaptive meshing.",
                "pattern": "1031",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Smoothing length scale": {
                "value": "200000.0",
                "default_value": "200000.0",
                "documentation": "The depth range (above maximum grid depth) over which to smooth. The boundary is smoothed using a depth weighted combination of Vs values from the ascii grid and S40RTS at each point in the region of smoothing.",
                "pattern": "1030",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Ascii data model": {
                "Data directory": {
                    "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/patch-on-S40RTS\/test\/",
                    "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/patch-on-S40RTS\/test\/",
                    "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                    "pattern": "1032",
                    "pattern_description": "[DirectoryName]"
                },
                "Data file name": {
                    "value": "upper_shell_3d.txt",
                    "default_value": "upper_shell_3d.txt",
                    "documentation": "The file name of the model data.",
                    "pattern": "1033",
                    "pattern_description": "[Anything]"
                },
                "Scale factor": {
                    "value": "1.",
                    "default_value": "1.",
                    "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                    "pattern": "1034",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                }
            }
        },
        "Random Gaussian perturbation": {
            "Maximum magnitude": {
                "value": "25.0",
                "default_value": "25.0",
                "documentation": "The maximum magnitude of the Gaussian perturbation. For each perturbation, a random magnitude between plus and minus the maximum magnitude will be chosen. Units: \\si{\\kelvin}.",
                "pattern": "1036",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Number of perturbations": {
                "value": "100",
                "default_value": "100",
                "documentation": "Total number of perturbations to be introduced into the model. Perturbations will be placed at random locations within the model domain.",
                "pattern": "1035",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            },
            "Width": {
                "value": "1000.0",
                "default_value": "1000.0",
                "documentation": "The Gaussian RMS width of the perturbations. Units: \\si{\\meter}.",
                "pattern": "1037",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "S40RTS perturbation": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/S40RTS\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/S40RTS\/",
                "documentation": "The path to the model data. ",
                "pattern": "1081",
                "pattern_description": "[DirectoryName]"
            },
            "Initial condition file name": {
                "value": "S40RTS.sph",
                "default_value": "S40RTS.sph",
                "documentation": "The file name of the spherical harmonics coefficients from Ritsema et al.",
                "pattern": "1082",
                "pattern_description": "[Anything]"
            },
            "Maximum order": {
                "value": "20",
                "default_value": "20",
                "documentation": "The maximum order the users specify when reading the data file of spherical harmonic coefficients, which must be smaller than the maximum order the data file stored. This parameter will be used only if 'Specify a lower maximum order' is set to true.",
                "pattern": "1092",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Reference temperature": {
                "value": "1600.0",
                "default_value": "1600.0",
                "documentation": "The reference temperature that is perturbed by the spherical harmonic functions. Only used in incompressible models.",
                "pattern": "1089",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Remove degree 0 from perturbation": {
                "value": "true",
                "default_value": "true",
                "documentation": "Option to remove the degree zero component from the perturbation, which will ensure that the laterally averaged temperature for a fixed depth is equal to the background temperature.",
                "pattern": "1088",
                "pattern_description": "[Bool]"
            },
            "Remove temperature heterogeneity down to specified depth": {
                "value": "-1.7976931348623157e+308",
                "default_value": "-1.7976931348623157e+308",
                "documentation": "This will set the heterogeneity prescribed by S20RTS or S40RTS to zero down to the specified depth (in meters). Note that your resolution has to be adequate to capture this cutoff. For example if you specify a depth of 660km, but your closest spherical depth layers are only at 500km and 750km (due to a coarse resolution) it will only zero out heterogeneities down to 500km. Similar caution has to be taken when using adaptive meshing.",
                "pattern": "1090",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Specify a lower maximum order": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to use a lower maximum order when reading the data file of spherical harmonic coefficients. This is probably used for the faster tests or when the users only want to see the spherical harmonic pattern up to a certain order.",
                "pattern": "1091",
                "pattern_description": "[Bool]"
            },
            "Spline knots depth file name": {
                "value": "Spline_knots.txt",
                "default_value": "Spline_knots.txt",
                "documentation": "The file name of the spline knot locations from Ritsema et al.",
                "pattern": "1083",
                "pattern_description": "[Anything]"
            },
            "Thermal expansion coefficient in initial temperature scaling": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\beta$. Units: \\si{\\per\\kelvin}.",
                "pattern": "1086",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Use thermal expansion coefficient from material model": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to take the thermal expansion coefficient from the material model instead of from what is specified in this section.",
                "pattern": "1087",
                "pattern_description": "[Bool]"
            },
            "Vs to density scaling": {
                "value": "0.25",
                "default_value": "0.25",
                "documentation": "This parameter specifies how the perturbation in shear wave velocity as prescribed by S20RTS or S40RTS is scaled into a density perturbation. See the general description of this model for more detailed information.",
                "pattern": "1085",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Vs to density scaling method": {
                "value": "constant",
                "default_value": "constant",
                "documentation": "Method that is used to specify how the vs-to-density scaling varies with depth.",
                "pattern": "1084",
                "pattern_description": "[Selection file|constant ]"
            },
            "Ascii data vs to density model": {
                "Data directory": {
                    "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/S40RTS\/",
                    "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/S40RTS\/",
                    "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                    "pattern": "1093",
                    "pattern_description": "[DirectoryName]"
                },
                "Data file name": {
                    "value": "vs_to_density_Steinberger.txt",
                    "default_value": "vs_to_density_Steinberger.txt",
                    "documentation": "The file name of the model data.",
                    "pattern": "1094",
                    "pattern_description": "[Anything]"
                },
                "Scale factor": {
                    "value": "1.",
                    "default_value": "1.",
                    "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                    "pattern": "1095",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                }
            }
        },
        "SAVANI perturbation": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/SAVANI\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/SAVANI\/",
                "documentation": "The path to the model data.",
                "pattern": "1096",
                "pattern_description": "[DirectoryName]"
            },
            "Initial condition file name": {
                "value": "savani.dlnvs.60.m.ab",
                "default_value": "savani.dlnvs.60.m.ab",
                "documentation": "The file name of the spherical harmonics coefficients from Auer et al.",
                "pattern": "1097",
                "pattern_description": "[Anything]"
            },
            "Maximum order": {
                "value": "20",
                "default_value": "20",
                "documentation": "The maximum order the users specify when reading the data file of spherical harmonic coefficients, which must be smaller than the maximum order the data file stored. This parameter will be used only if 'Specify a lower maximum order' is set to true.",
                "pattern": "1107",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Reference temperature": {
                "value": "1600.0",
                "default_value": "1600.0",
                "documentation": "The reference temperature that is perturbed by the spherical harmonic functions. Only used in incompressible models.",
                "pattern": "1104",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Remove degree 0 from perturbation": {
                "value": "true",
                "default_value": "true",
                "documentation": "Option to remove the degree zero component from the perturbation, which will ensure that the laterally averaged temperature for a fixed depth is equal to the background temperature.",
                "pattern": "1103",
                "pattern_description": "[Bool]"
            },
            "Remove temperature heterogeneity down to specified depth": {
                "value": "-1.7976931348623157e+308",
                "default_value": "-1.7976931348623157e+308",
                "documentation": "This will set the heterogeneity prescribed by SAVANI to zero down to the specified depth (in meters). Note that your resolution has to be adequate to capture this cutoff. For example if you specify a depth of 660km, but your closest spherical depth layers are only at 500km and 750km (due to a coarse resolution) it will only zero out heterogeneities down to 500km. Similar caution has to be taken when using adaptive meshing.",
                "pattern": "1105",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Specify a lower maximum order": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to use a lower maximum order when reading the data file of spherical harmonic coefficients. This is probably used for the faster tests or when the users only want to see the spherical harmonic pattern up to a certain order.",
                "pattern": "1106",
                "pattern_description": "[Bool]"
            },
            "Spline knots depth file name": {
                "value": "Spline_knots.txt",
                "default_value": "Spline_knots.txt",
                "documentation": "The file name of the spline knots taken from the 28 spherical layers of SAVANI tomography model.",
                "pattern": "1098",
                "pattern_description": "[Anything]"
            },
            "Thermal expansion coefficient in initial temperature scaling": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\beta$. Units: \\si{\\per\\kelvin}.",
                "pattern": "1101",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Use thermal expansion coefficient from material model": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to take the thermal expansion coefficient from the material model instead of from what is specified in this section.",
                "pattern": "1102",
                "pattern_description": "[Bool]"
            },
            "Vs to density scaling": {
                "value": "0.25",
                "default_value": "0.25",
                "documentation": "This parameter specifies how the perturbation in shear wave velocity as prescribed by SAVANI is scaled into a density perturbation. See the general description of this model for more detailed information.",
                "pattern": "1100",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Vs to density scaling method": {
                "value": "constant",
                "default_value": "constant",
                "documentation": "Method that is used to specify how the vs-to-density scaling varies with depth.",
                "pattern": "1099",
                "pattern_description": "[Selection file|constant ]"
            },
            "Ascii data vs to density model": {
                "Data directory": {
                    "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/S40RTS\/",
                    "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/S40RTS\/",
                    "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                    "pattern": "1108",
                    "pattern_description": "[DirectoryName]"
                },
                "Data file name": {
                    "value": "vs_to_density_Steinberger.txt",
                    "default_value": "vs_to_density_Steinberger.txt",
                    "documentation": "The file name of the model data.",
                    "pattern": "1109",
                    "pattern_description": "[Anything]"
                },
                "Scale factor": {
                    "value": "1.",
                    "default_value": "1.",
                    "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                    "pattern": "1110",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                }
            }
        },
        "Spherical gaussian perturbation": {
            "Amplitude": {
                "value": "0.01",
                "default_value": "0.01",
                "documentation": "The amplitude of the perturbation.",
                "pattern": "1042",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Angle": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The angle where the center of the perturbation is placed.",
                "pattern": "1040",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Filename for initial geotherm table": {
                "value": "initial-geotherm-table",
                "default_value": "initial-geotherm-table",
                "documentation": "The file from which the initial geotherm table is to be read. The format of the file is defined by what is read in source\/initial\\_temperature\/spherical\\_shell.cc.",
                "pattern": "1045",
                "pattern_description": "[FileName (Type: input)]"
            },
            "Non-dimensional depth": {
                "value": "0.7",
                "default_value": "0.7",
                "documentation": "The non-dimensional radial distance where the center of the perturbation is placed.",
                "pattern": "1041",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Sigma": {
                "value": "0.2",
                "default_value": "0.2",
                "documentation": "The standard deviation of the Gaussian perturbation.",
                "pattern": "1043",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Sign": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "The sign of the perturbation.",
                "pattern": "1044",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Spherical hexagonal perturbation": {
            "Angular mode": {
                "value": "6",
                "default_value": "6",
                "documentation": "The number of convection cells with which to perturb the system.",
                "pattern": "1038",
                "pattern_description": "[Integer range -2147483648...2147483647 (inclusive)]"
            },
            "Rotation offset": {
                "value": "-45.",
                "default_value": "-45.",
                "documentation": "Amount of clockwise rotation in degrees to apply to the perturbations. Default is set to -45 in order to provide backwards compatibility.",
                "pattern": "1039",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        }
    },
    "Material model": {
        "Material averaging": {
            "value": "none",
            "default_value": "none",
            "documentation": "Whether or not (and in the first case, how) to do any averaging of material model output data when constructing the linear systems for velocity\/pressure, temperature, and compositions in each time step, as well as their corresponding preconditioners.\n\nPossible choices: none|arithmetic average|harmonic average|geometric average|pick largest|project to Q1|log average|harmonic average only viscosity|geometric average only viscosity|project to Q1 only viscosity\n\nThe process of averaging, and where it may be used, is discussed in more detail in Section~\\ref{sec:sinker-with-averaging}.\n\nMore averaging schemes are available in the averaging material model. This material model is a ``compositing material model'' which can be used in combination with other material models.",
            "pattern": "94",
            "pattern_description": "[Selection none|arithmetic average|harmonic average|geometric average|pick largest|project to Q1|log average|harmonic average only viscosity|geometric average only viscosity|project to Q1 only viscosity ]"
        },
        "Model name": {
            "value": "simpler with crust",
            "default_value": "unspecified",
            "documentation": "The name of the material model to be used in this simulation. There are many material models you can choose from, as listed below. They generally fall into two category: (i) models that implement a particular case of material behavior, (ii) models that modify other models in some way. We sometimes call the latter ``compositing models''. An example of a compositing model is the ``depth dependent'' model below in that it takes another, freely choosable model as its base and then modifies that model's output in some way.\n\nYou can select one of the following models:\n\n`Steinberger': This material model looks up the viscosity from the tables that correspond to the paper of Steinberger and Calderwood 2006 (``Models of large-scale viscous flow in the Earth's mantle with constraints from mineral physics and surface observations'', Geophys. J. Int., 167, 1461-1481, <http:\/\/dx.doi.org\/10.1111\/j.1365-246X.2006.03131.x>) and material data from a database generated by the thermodynamics code \\texttt{Perplex}, see <http:\/\/www.perplex.ethz.ch\/>. The default example data builds upon the thermodynamic database by Stixrude 2011 and assumes a pyrolitic composition by Ringwood 1988 but is easily replaceable by other data files. \n\n`ascii reference profile': A material model that reads in a reference state for density, thermal expansivity, compressibility and specific heat from a text file. \nNote the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of points in the reference state as for example `# POINTS: 3'. Following the comment lines there has to be a single line containing the names of all data columns, separated by arbitrarily many spaces. Column names are not allowed to contain spaces. The file can contain unnecessary columns, but for this plugin it needs to at least provide the columns named `density', `thermal\\_expansivity', `specific\\_heat', and `compressibility'. Note that the data lines in the file need to be sorted in order of increasing depth from 0 to the maximal depth in the model domain. Points in the model that are outside of the provided depth range will be assigned the maximum or minimum depth values, respectively. Points do not need to be equidistant, but the computation of properties is optimized in speed if they are.\n\nThe viscosity $\\eta$ is computed as $\\eta(z,T) = \\eta_r(z) \\eta_0 \\exp\\left(-A \\frac{T - T_{\\text{adi}}}{T_{\\text{adi}}}\\right)$, where $\\eta_r(z)$ is the depth-dependence, which is a piecewise constant function computed according to the list of ``Viscosity prefactors'' and ``Transition depths'', $\\eta_0$ is the reference viscosity specified by the parameter ``Viscosity'' and $A$ describes the dependence on temperature and corresponds to the parameter ``Thermal viscosity exponent''.\n\n`averaging': The ``averaging'' Material model applies an averaging of the quadrature points within a cell. The values to average are supplied by any of the other available material models. In other words, it is a ``compositing material model''. Parameters related to the average model are read from a subsection ``Material model\/Averaging''.\n\nThe user must specify a ``Base model'' from which material properties are derived. Furthermore an averaging operation must be selected, where the Choice should be from the list none|arithmetic average|harmonic average|geometric average|pick largest|log average|NWD arithmetic average|NWD harmonic average|NWD geometric average.\n\nNWD stands for Normalized Weighed Distance. The models with this in front of their name work with a weighed average, which means each quadrature point requires an individual weight. The weight is determined by the distance, where the exact relation is determined by a bell shaped curve. A bell shaped curve is a continuous function which is one at its maximum and exactly zero at and beyond its limit. This bell shaped curve is spanned around each quadrature point to determine the weighting map for each quadrature point. The used bell shape comes from Lucy (1977). The distance is normalized so the largest distance becomes one. This means that if variable ''Bell shape limit'' is exactly one, the farthest quadrature point is just on the limit and its weight will be exactly zero. In this plugin it is not implemented as larger and equal than the limit, but larger than, to ensure the quadrature point at distance zero is always included.\n\n`compositing': The ``compositing'' Material model selects material model properties from a given set of other material models, and is intended to make mixing different material models easier. This is useful, for example, when wanting to use the melting parameterization of the ``melt simple'' model (which has a relatively simple viscosity model that only allows for a temperature- but not strain rate-dependent viscosity) with a more realistic viscosity model such as that provided by the ``diffusion dislocation'' model.\n\nSpecifically, this material model works by allowing to specify the name of another material model for each coefficient that material models are asked for (such as the viscosity, density, etc.). Whenever the material model is asked for the values of coefficients, it then evaluates all of the ``base models'' that were listed for the various coefficients, and copies the values returned by these base models into the output structure.\n\nThe implementation of this material model is somewhat expensive because it has to evaluate all material coefficients of all underlying material models. Consequently, if performance of assembly and postprocessing is important, then implementing a separate material model is a better choice than using this material model.\n\n`composition reaction': A material model that behaves in the same way as the simple material model, but includes two compositional fields and a reaction between them. Above a depth given in the input file, the first fields gets converted to the second field. \n\n`depth dependent': The ``depth dependent'' Material model applies a depth-dependent scaling to any of the other available material models. In other words, it is a ``compositing material model''.\n\nParameters related to the depth dependent model are read from a subsection ``Material model\/Depth dependent model''. The user must specify a ``Base model'' from which material properties are derived. Currently the depth dependent model only allows depth dependence of viscosity - other material properties are taken from the ``Base model''. Viscosity $\\eta$ at depth $z$ is calculated according to:$ \\eta(z,p,T,X,...) = \\eta(z) \\eta_b(p,T,X,..)\/\\eta_{r}$ where $\\eta(z)$ is the depth-dependence specified by the depth dependent model, $\\eta_b(p,T,X,...)$ is the viscosity calculated from the base model, and $\\eta_{r}$ is the reference viscosity. In addition to the specification of the ``Base model'', the user must specify the method to be used to calculate the depth-dependent viscosity $\\eta(z)$ as ``Material model\/Depth dependent model\/Depth dependence method'', which can be chosen among ``None|Function|File|List''. Each method and the associated parameters are as follows:\n\n``Function'': read a user-specified parsed function from the input file in a subsection ``Material model\/Depth dependent model\/Viscosity depth function''. By default, this function is uniformly equal to 1.0e21. Specifying a function that returns a value less than or equal to 0.0 anywhere in the model domain will produce an error. \n\n``File'': read a user-specified file containing viscosity values at specified depths. The file containing depth-dependent viscosities is read from a directory specified by the user as ``Material model\/Depth dependent model\/Data directory'', from a file with name specified as ``Material model\/Depth dependent model\/Viscosity depth file''. The format of this file is ascii text and contains two columns with one header line:\n\nexample Viscosity depth file:\\\\Depth (m)    Viscosity (Pa-s)\\\\0.0000000e+00     1.0000000e+21\\\\6.7000000e+05     1.0000000e+22\\\\\n\nViscosity is interpolated from this file using linear interpolation. ``None'': no depth-dependence. Viscosity is taken directly from ``Base model''\n\n``List:'': read a comma-separated list of depth values corresponding to the maximum depths of layers having constant depth-dependence $\\eta(z)$. The layers must be specified in order of increasing depth, and the last layer in the list must have a depth greater than or equal to the maximal depth of the model. The list of layer depths is specified as ``Material model\/Depth dependent model\/Depth list'' and the corresponding list of layer viscosities is specified as ``Material model\/Depth dependent model\/Viscosity list''\n\n`diffusion dislocation': An implementation of a viscous rheology including diffusion and dislocation creep. Compositional fields can each be assigned individual activation energies, reference densities, thermal expansivities, and stress exponents. The effective viscosity is defined as \n\n$\\eta_{\\text{eff}} = \\left(\\frac{1}{\\eta_{\\text{eff}}^\\text{diff}}+ \\frac{1}{\\eta_{\\text{eff}}^\\text{dis}}\\right)^{-1}$ where $\\eta_{\\text{i}} = \\frac{1}{2} A^{-\\frac{1}{n_i}} d^\\frac{m_i}{n_i} \\dot{\\varepsilon_i}^{\\frac{1-n_i}{n_i}} \\exp\\left(\\frac{E_i^\\ast + PV_i^\\ast}{n_iRT}\\right)$ \n\nwhere $d$ is grain size, $i$ corresponds to diffusion or dislocation creep, $\\dot{\\varepsilon}$ is the square root of the second invariant of the strain rate tensor, $R$ is the gas constant, $T$ is temperature, and $P$ is pressure. $A_i$ are prefactors, $n_i$ and $m_i$ are stress and grain size exponents $E_i$ are the activation energies and $V_i$ are the activation volumes. \n\nThis form of the viscosity equation is commonly used in geodynamic simulations See, for example, Billen and Hirth (2007), G3, 8, Q08012. Significantly, other studies may use slightly different forms of the viscosity equation leading to variations in how specific terms are defined or combined. For example, the grain size exponent should always be positive in the diffusion viscosity equation used here, while other studies place the grain size term in the denominator and invert the sign of the grain size exponent. When examining previous work, one should carefully check how the viscous prefactor and grain size terms are defined.  \n\nThe ratio of diffusion to dislocation strain rate is found by Newton's method, iterating to find the stress which satisfies the above equations. The value for the components of this formula and additional parameters are read from the parameter file in subsection 'Material model\/DiffusionDislocation'.\n\n`drucker prager': A material model that has constant values for all coefficients but the density and viscosity. The defaults for all coefficients are chosen to be similar to what is believed to be correct for Earth's mantle. All of the values that define this model are read from a section ``Material model\/Drucker Prager'' in the input file, see Section~\\ref{parameters:Material_20model\/Drucker_20Prager}. Note that the model does not take into account any dependencies of material properties on compositional fields. \n\nThe viscosity is computed according to the Drucker Prager frictional plasticity criterion (non-associative) based on a user-defined internal friction angle $\\phi$ and cohesion $C$. In 3d:  $\\sigma_y = \\frac{6 C \\cos(\\phi)}{\\sqrt{3} (3+\\sin(\\phi))} + \\frac{6 P \\sin(\\phi)}{\\sqrt{3} (3+\\sin(\\phi))}$, where $P$ is the pressure. See for example Zienkiewicz, O. C., Humpheson, C. and Lewis, R. W. (1975), G\\'{e}otechnique 25, No. 4, 671-689. With this formulation we circumscribe instead of inscribe the Mohr Coulomb yield surface. In 2d the Drucker Prager yield surface is the same as the Mohr Coulomb surface:  $\\sigma_y = P \\sin(\\phi) + C \\cos(\\phi)$. Note that in 2d for $\\phi=0$, these criteria revert to the von Mises criterion (no pressure dependence). See for example \\cite{Thieulot:2011}. \n\nNote that we enforce the pressure to be positive to prevent negative yield strengths and viscosities. \n\nWe then use the computed yield strength to scale back the viscosity on to the yield surface using the Viscosity Rescaling Method described in Kachanov, L. M. (2004), Fundamentals of the Theory of Plasticity, Dover Publications, Inc. (Not Radial Return.)A similar implementation can be found in GALE (<https:\/\/geodynamics.org\/resources\/gale>). \n\nTo avoid numerically unfavourably large (or even negative) viscosity ranges, we cut off the viscosity with a user-defined minimum and maximum viscosity: $\\eta_{eff} = \\frac{1}{\\frac{1}{\\eta_{min} + \\eta}+ \\frac{1}{\\eta_{max}}}$. \n\nNote that this model uses the formulation that assumes an incompressible medium despite the fact that the density follows the law $\\rho(T)=\\rho_0(1-\\beta(T-T_{\\text{ref}}))$. \n\n`entropy model': A material model that is designed to use pressure and entropy (rather than pressure and temperature) as independent variables. It requires a thermodynamic data table that contains all relevant properties in a specific format as illustrated in the data\/material-model\/entropy-table\/opxtable example folder. The material model requires the use of the projected density approximation for compressibility, and the existence of a compositional field called 'entropy'.\n\n`grain size': A material model that relies on compositional fields that correspond to the average grain sizes of a mineral phase and source terms that determine the grain size evolution in terms of the strain rate, temperature, phase transitions, and the creep regime. This material model only works if a compositional field named 'grain_size' is present. In the diffusion creep regime, the viscosity depends on this grain size field. We use the grain size evolution laws described in Behn et al., 2009. Implications of grain size evolution on the seismic structure of the oceanic upper mantle, Earth Planet. Sci. Letters, 282, 178–189. Other material parameters are either prescribed similar to the 'simple' material model, or read from data files that were generated by the Perplex or Hefesto software. This material model is described in more detail in Dannberg, J., Z. Eilon, U. Faul, R. Gassmoeller, P. Moulik, and R. Myhill (2017), The importance of grain size to mantle dynamics and seismological observations, Geochem. Geophys. Geosyst., 18, 3034–3061, doi:10.1002\/2017GC006944.\n\n`latent heat': A material model that includes phase transitions and the possibility that latent heat is released or absorbed when material crosses one of the phase transitions of up to two different materials (compositional fields). This model implements a standard approximation of the latent heat terms following Christensen \\& Yuen, 1985 \\cite{christensen:yuen:1985}. The change of entropy is calculated as $\\Delta S = \\gamma \\frac{\\Delta\\rho}{\\rho^2}$ with the Clapeyron slope $\\gamma$ and the density change $\\Delta\\rho$ of the phase transition being input parameters. The model employs an analytic phase function in the form $X=\\frac{1}{2} \\left( 1 + \\tanh \\left( \\frac{\\Delta p}{\\Delta p_0} \\right) \\right)$ with $\\Delta p = p - p_{\\text{transition}} - \\gamma \\left( T - T_{\\text{transition}} \\right)$ and $\\Delta p_0$ being the pressure difference over the width of the phase transition (specified as input parameter).\n\n`latent heat melt': A material model that includes the latent heat of melting for two materials: peridotite and pyroxenite. The melting model for peridotite is taken from Katz et al., 2003 (A new parameterization of hydrous mantle melting) and the one for pyroxenite from Sobolev et al., 2011 (Linking mantle plumes, large igneous provinces and environmental catastrophes). The model assumes a constant entropy change for melting 100\\% of the material, which can be specified in the input file. The partial derivatives of entropy with respect to temperature and pressure required for calculating the latent heat consumption are then calculated as product of this constant entropy change, and the respective derivative of the function the describes the melt fraction. This is linearly averaged with respect to the fractions of the two materials present. If no compositional fields are specified in the input file, the model assumes that the material is peridotite. If compositional fields are specified, the model assumes that the first compositional field is the fraction of pyroxenite and the rest of the material is peridotite. \n\nOtherwise, this material model has a temperature- and pressure-dependent density and viscosity and the density and thermal expansivity depend on the melt fraction present. It is possible to extent this model to include a melt fraction dependence of all the material parameters by calling the function melt_fraction in the calculation of the respective parameter. However, melt and solid move with the same velocity and melt extraction is not taken into account (batch melting). \n\n`melt boukare': A material model that implements a simplified version of the melting model of Boukare et al. (https:\/\/doi.org\/10.1002\/2015JB011929) for the lowermost mantle and uses it to compute the material parameters required for the modeling of melt transport, including melting and solidification and the corresponding changes in composition.The model parameterizes the composition (which includes the components MgO, FeO and SiO2) as a mixture between two endmembers (one iron-bearing and one magnesium-bearing). The equation of state considers three phases: bridgmanite, ferropericlase, and melt (each with their individual compositions). More details can be found in Dannberg, J., Myhill, R., Gassmöller, R., and Cottaar, S. (2021). The morphology, evolution and seismic visibility of partial melt at the core–mantle boundary: implications for ULVZs. Geophysical Journal International, 227(2), 1028-1059.\n\n`melt global': A material model that implements a simple formulation of the material parameters required for the modeling of melt transport, including a source term for the porosity according to a simplified linear melting model similar to \\cite{schmeling2006}:\n$\\phi_{\\text{equilibrium}} = \\frac{T-T_{\\text{sol}}}{T_{\\text{liq}}-T_{\\text{sol}}}$\nwith $T_{\\text{sol}} = T_{\\text{sol,0}} + \\Delta T_p \\, p + \\Delta T_c \\, C$ \n$T_{\\text{liq}} = T_{\\text{sol}}  + \\Delta T_{\\text{sol-liq}}$.\n\n`melt simple': A material model that implements a simple formulation of the material parameters required for the modeling of melt transport, including a source term for the porosity according to the melting model for dry peridotite of \\cite{KSL2003}. This also includes a computation of the latent heat of melting (if the `latent heat' heating model is active).\n\nMost of the material properties are constant, except for the shear, viscosity $\\eta$, the compaction viscosity $\\xi$, and the permeability $k$, which depend on the porosity; and the solid and melt densities, which depend on temperature and pressure:\n $\\eta(\\phi,T) = \\eta_0 e^{\\alpha(\\phi-\\phi_0)} e^{-\\beta(T-T_0)\/T_0}$, $\\xi(\\phi,T) = \\xi_0 \\frac{\\phi_0}{\\phi} e^{-\\beta(T-T_0)\/T_0}$, $k=k_0 \\phi^n (1-\\phi)^m$, $\\rho=\\rho_0 (1 - \\alpha (T - T_{\\text{adi}})) e^{\\kappa p}$.\n\nThe model is compressible only if this is specified in the input file, and contains compressibility for both solid and melt.\n\n`modified tait': A material model that implements the thermal modified Tait equation of state as written in \\cite{HP2011}. Constant values are used for the thermal conductivity and viscosity. The defaults for all coefficients are chosen to be similar to what is believed to be correct for Earth's mantle. All of the values that define this model are read from a section ``Material model\/Modified Tait model'' in the input file, see Section~\\ref{parameters:Material_20model\/Modified_20Tait_20model}.\n\n`multicomponent': This incompressible model is for use with an arbitrary number of compositional fields, where each field represents a rock type which can have completely different properties from the others. However, each rock type itself has constant material properties.  The value of the  compositional field is interpreted as a volume fraction. If the sum of the fields is greater than one, they are renormalized.  If it is less than one, material properties  for ``background mantle'' make up the rest. When more than one field is present, the material properties are averaged arithmetically.  An exception is the viscosity, where the averaging should make more of a difference.  For this, the user selects between arithmetic, harmonic, geometric, or maximum composition averaging.\n\n`multicomponent compressible': This model is for use with an arbitrary number of compositional fields, where each field represents a rock type which can have completely different properties from the others. Each rock type is described by a self-consistent equation of state.  The value of the  compositional field is interpreted as a mass fraction. If the sum of the fields is greater than one, they are renormalized.  If it is less than one, material properties  for ``background mantle'' make up the rest. When more than one field is present, the material properties are averaged arithmetically by mass fraction (for specific heat), or volume fraction (for density, thermal expansivity and compressibility). The thermal conductivity is also arithmetically averaged by volume fraction. Finally, the viscosity is averaged by volume fraction, but the user can choose between arithmetic, harmonic, geometric or maximum composition averaging.\n\n`nondimensional': A material model for nondimensionalized computations for compressible or incompressible computations defined through Rayleigh number \text{Ra} and Dissipation number Di. This model is made to be used with the Boussinesq, ALA, or TALA formulation.\n\nThe viscosity is defined as $\\eta = \\text{Di} \/ \\text{Ra} \\cdot \\exp(-b T^\\prime + c z)$ where $T^\\prime$ is the temperature variation from the adiabatic temperature, $z$ is the depth, $b$ is given by ``Viscosity temperature prefactor'', and $c$ by ``Viscosity depth prefactor''. If $\\text{Di}$ is zero, it will be replaced by 1.0 in $\\eta$.\n\nThe density is defined as $\\rho = \\exp(\\text{Di}\/\\gamma \\cdot z)  (1.0 - \\alpha T^\\prime + \\text{Di} \\gamma p^\\prime),$ where $\\alpha=\\text{Di}$ is the thermal expansion coefficient, $\\gamma$ is the Grueneisen parameter, and $p^\\prime$ is the pressure variation from the adiabatic pressure. The pressure dependent term is not present if ``TALA'' is enabled.\n\n`perplex lookup': A material model that has constant values for viscosity and thermal conductivity, and calculates other properties on-the-fly using PerpleX meemum. Compositional fields correspond to the individual components in the order given in the PerpleX file.\n\n`prescribed viscosity': A material model that applies a viscosity to a ''base model'' chosen from any of the other available material models. This prescribed viscosity material model allows the user to specify a function which describes where the viscosity should be prescribed and a second function which describes the viscosity in that region. This material model requires a base model which prescribes the viscosity and the other material parameters in the rest of the model.\n\n`replace lithosphere viscosity': The ``replace lithosphere viscosity'' Material model sets viscosity to a prescribed constant above the lithosphere-asthenosphere boundary (specified by an ascii file or maximum lithosphere depth). Below the lithosphere-asthenosphereboundary the viscosity is taken from any of the other available material model. In other words, it is a ``compositing material model''.\nParameters related to the replace lithosphere viscosity model are read from a subsection ``Material model\/Replace lithosphere viscosity''. The user must specify a ``Base model'' from which other material properties are derived.  \nNote the required format of the input data file: The first lines may contain any number of comments if they begin with ‘#’, but one of these lines needs to contain the number of grid points in each dimension as for example ‘# POINTS: 3 3’. For a spherical model, the order of the data columns has to be'phi', 'theta','depth (m)', where phi is the  azimuth angle and theta is the polar angle measured positive from the north pole.\n\n`simple': A material model that has constant values for all coefficients but the density and viscosity. The defaults for all coefficients are chosen to be similar to what is believed to be correct for Earth's mantle. All of the values that define this model are read from a section ``Material model\/Simple model'' in the input file, see Section~\\ref{parameters:Material_20model\/Simple_20model}.\n\nThis model uses the following set of equations for the two coefficients that are non-constant: \\begin{align}  \\eta(p,T,\\mathfrak c) &= \\tau(T) \\zeta(\\mathfrak c) \\eta_0, \\\\  \\rho(p,T,\\mathfrak c) &= \\left(1-\\alpha (T-T_0)\\right)\\rho_0 + \\Delta\\rho \\; c_0,\\end{align}where $c_0$ is the first component of the compositional vector $\\mathfrak c$ if the model uses compositional fields, or zero otherwise. \n\nThe temperature pre-factor for the viscosity formula above is defined as \\begin{align}  \\tau(T) &= H\\left(e^{-\\beta (T-T_0)\/T_0}\\right),\\intertext{with}   \\qquad\\qquad H(x) &= \\begin{cases}                            \\tau_{\\text{min}} & \\text{if}\\; x<\\tau_{\\text{min}}, \\\\                            x & \\text{if}\\; 10^{-2}\\le x \\le 10^2, \\\\                            \\tau_{\\text{max}} & \\text{if}\\; x>\\tau_{\\text{max}}, \\\\                         \\end{cases}\\end{align} where $x=e^{-\\beta (T-T_0)\/T_0}$, $\\beta$ corresponds to the input parameter ``Thermal viscosity exponent'', and $T_0$ to the parameter ``Reference temperature''. If you set $T_0=0$ in the input file, the thermal pre-factor $\\tau(T)=1$. The parameters $\\tau_{\\text{min}}$ and $\\tau_{\\text{max}}$ set the minimum and maximum values of the temperature pre-factor and are set using ``Maximum thermal prefactor'' and ``Minimum thermal prefactor''. Specifying a value of 0.0 for the minimum or maximum values will disable pre-factor limiting.\n\nThe compositional pre-factor for the viscosity is defined as $ \\zeta(\\mathfrak c) = \\xi^{c_0}$ if the model has compositional fields and equals one otherwise. $\\xi$ corresponds to the parameter ``Composition viscosity prefactor'' in the input file.\n\nFinally, in the formula for the density, $\\alpha$ corresponds to the ``Thermal expansion coefficient'' and $\\Delta\\rho$ corresponds to the parameter ``Density differential for compositional field 1''.\n\nNote that this model uses the formulation that assumes an incompressible medium despite the fact that the density follows the law $\\rho(T)=\\rho_0(1-\\alpha(T-T_{\\text{ref}}))$. \n\n\\note{Despite its name, this material model is not exactly ``simple'', as indicated by the formulas above. While it was originally intended to be simple, it has over time acquired all sorts of temperature and compositional dependencies that weren't initially intended. Consequently, there is now a ``simpler'' material model that now fills the role the current model was originally intended to fill.}\n\n`simple compressible': A material model that has constant values for all coefficients but the density. The defaults for all coefficients are chosen to be similar to what is believed to be correct for Earth's mantle. All of the values that define this model are read from a section ``Material model\/Simple compressible model'' in the input file, see Section~\\ref{parameters:Material_20model\/Simple_20compressible_20model}.\n\nThis model uses the following equations for the density: $ \\rho(p,T) = \\rho_0 \\left(1-\\alpha (T-T_a)\\right) \\exp{\\beta (P-P_0))}$ This formulation for the density assumes that the compressibility provided by the user is the adiabatic compressibility ($\\beta_S$). The thermal expansivity and isentropic compressibility implied by the pressure and temperature dependence are equal to the user-defined constant values only along the reference isentrope, and there is also an implicit pressure dependence to the heat capacity $C_p$ via Maxwell's relations.\n\n`simpler': A material model that has constant values except for density, which depends linearly on temperature: $ \\rho(p,T) = \\left(1-\\alpha (T-T_0)\\right)\\rho_0.$ \n\nNote that this material model fills the role the ``simple'' material model was originally intended to fill, before the latter acquired all sorts of complicated temperature and compositional dependencies. \n\n`simpler with crust': A material model that is like the ``simpler'' model but has a jump in the viscosity at a specified depth.\n\n`visco plastic': An implementation of an incompressible visco(elastic)-plastic rheology with options for selecting dislocation creep, diffusion creep or composite viscous flow laws. Prior to yielding, one may select to modify the viscosity to account for viscoelastic effects by setting the parameter 'Enable elasticity' in subsection Formulation to true. Plasticity limits viscous stresses through a Drucker Prager yield criterion. The implementation of this material model is based heavily on the `DiffusionDislocation' (Bob Myhill), `DruckerPrager' (Anne Glerum), and `Viscoelastic' (John Naliboff) material models. \n\n The viscosity for dislocation or diffusion creep is defined as $ \\eta = \\frac 12 A^{-\\frac{1}{n}} d^{\\frac{m}{n}} \\dot{\\varepsilon}_{ii}^{\\frac{1-n}{n}} \\exp\\left(\\frac{E + PV}{nRT}\\right)$ where $A$ is the prefactor, $n$ is the stress exponent, $\\dot{\\varepsilon}_{ii}$ is the square root of the deviatoric strain rate tensor second invariant, $d$ is grain size, $m$ is the grain size exponent, $E$ is activation energy, $V$ is activation volume, $P$ is pressure, $R$ is the gas exponent and $T$ is temperature. This form of the viscosity equation is commonly used in geodynamic simulations. See, for example, Billen and Hirth (2007), G3, 8, Q08012. Significantly, other studies may use slightly different forms of the viscosity equation leading to variations in how specific terms are defined or combined. For example, the grain size exponent should always be positive in the diffusion viscosity equation used here, while other studies place the grain size term in the denominator and invert the sign of the grain size exponent. When examining previous work, one should carefully check how the viscous prefactor and grain size terms are defined. \n\n One may select to use the diffusion ($\\eta_{\\text{diff}}$; $n=1$, $m\\neq 0$), dislocation ($\\eta_{\\text{disl}}$, $n>1$, $m=0$) or composite $\\frac{\\eta_{\\text{diff}} \\eta_{\\text{disl}}}{\\eta_{\\text{diff}}+\\eta_{\\text{disl}}}$ equation form. \n\n The diffusion and dislocation prefactors can be weakened with a factor between 0 and 1 according to the total or the viscous strain only. \n\n Viscosity is limited through one of two different `yielding' mechanisms. \n\nThe first plasticity mechanism limits viscous stress through a Drucker Prager yield criterion, where the yield stress in 3d is  $\\sigma_y = \\frac{6C\\cos(\\phi) + 2P\\sin(\\phi)} {\\sqrt{3}(3+\\sin(\\phi))}$ and $\\sigma_y = C\\cos(\\phi) + P\\sin(\\phi)$ in 2d. Above, $C$ is cohesion and $\\phi$  is the angle of internal friction.  Note that the 2d form is equivalent to the Mohr Coulomb yield surface.  If $\\phi$ is 0, the yield stress is fixed and equal to the cohesion (Von Mises yield criterion). When the viscous stress ($2\\eta {\\varepsilon}_{ii}$) exceeds the yield stress, the viscosity is rescaled back to the yield surface: $\\eta_{y}=\\sigma_{y}\/(2{\\varepsilon}_{ii})$. This form of plasticity is commonly used in geodynamic models. See, for example, Thieulot, C. (2011), PEPI 188, pp. 47-68. \n\nThe user has the option to linearly reduce the cohesion and internal friction angle as a function of the finite strain magnitude. The finite strain invariant or full strain tensor is calculated through compositional fields within the material model. This implementation is identical to the compositional field finite strain plugin and cookbook described in the manual (author: Gassmoeller, Dannberg). If the user selects to track the finite strain invariant ($e_{ii}$), a single compositional field tracks the value derived from $e_{ii}^t = (e_{ii})^{(t-1)} + \\dot{e}_{ii}\\; dt$, where $t$ and $t-1$ are the current and prior time steps, $\\dot{e}_{ii}$ is the second invariant of the strain rate tensor and $dt$ is the time step size. In the case of the full strain tensor $F$, the finite strain magnitude is derived from the second invariant of the symmetric stretching tensor $L$, where $L = F [F]^T$. The user must specify a single compositional field for the finite strain invariant or multiple fields (4 in 2d, 9 in 3d) for the finite strain tensor. These field(s) must be the first listed compositional fields in the parameter file. Note that one or more of the finite strain tensor components must be assigned a non-zero value initially. This value can be be quite small (e.g., 1.e-8), but still non-zero. While the option to track and use the full finite strain tensor exists, tracking the associated compositional fields is computationally expensive in 3d. Similarly, the finite strain magnitudes may in fact decrease if the orientation of the deformation field switches through time. Consequently, the ideal solution is track the finite strain invariant (single compositional) field within the material and track the full finite strain tensor through particles.When only the second invariant of the strain is tracked, one has the option to track the full strain or only the plastic strain. In the latter case, strain is only tracked in case the material is plastically yielding, i.e. the viscous stress > yield stress. \n\nViscous stress may also be limited by a non-linear stress limiter that has a form similar to the Peierls creep mechanism. This stress limiter assigns an effective viscosity $\\sigma_{\\text{eff}} = \\frac{\\tau_y}{2\\varepsilon_y} {\\frac{\\varepsilon_{ii}}{\\varepsilon_y}}^{\\frac{1}{n_y}-1}$ Above $\\tau_y$ is a yield stress, $\\varepsilon_y$ is the reference strain rate, $\\varepsilon_{ii}$ is the strain rate and $n_y$ is the stress limiter exponent.  The yield stress, $\\tau_y$, is defined through the Drucker Prager yield criterion formulation. This method of limiting viscous stress has been used in various forms within the geodynamic literature \\cite{chri92,vavv02,cibi13,cibi15}.When $n_y$ is 1, it essentially becomes a linear viscosity model, and in the limit $n_y\\rightarrow \\infty$ it converges to the standard viscosity rescaling method (concretely, values $n_y>20$ are large enough).\n\n The visco-plastic rheology described above may also be modified to include viscoelastic deformation, thus producing a viscoelastic plastic constitutive relationship. \n\n The viscoelastic rheology behavior takes into account the elastic shear strength (e.g., shear modulus), while the tensile and volumetric strength (e.g., Young's and bulk modulus) are not considered. The model is incompressible and allows specifying an arbitrary number of compositional fields, where each field represents a different rock type or component of the viscoelastic stress tensor. The stress tensor in 2d and 3d, respectively, contains 3 or 6 components. The compositional fields representing these components must be named and listed in a very specific format, which is designed to minimize mislabeling stress tensor components as distinct 'compositional rock types' (or vice versa). For 2d models, the first three compositional fields must be labeled 'stress\\_xx', 'stress\\_yy' and 'stress\\_xy'. In 3d, the first six compositional fields must be labeled 'stress\\_xx', 'stress\\_yy', 'stress\\_zz', 'stress\\_xy', 'stress\\_xz', 'stress\\_yz'. \n\n Combining this viscoelasticity implementation with non-linear viscous flow and plasticity produces a constitutive relationship commonly referred to as partial elastoviscoplastic (e.g., pEVP) in the geodynamics community. While extensively discussed and applied within the geodynamics literature, notable references include: Moresi et al. (2003), J. Comp. Phys., v. 184, p. 476-497. Gerya and Yuen (2007), Phys. Earth. Planet. Inter., v. 163, p. 83-105. Gerya (2010), Introduction to Numerical Geodynamic Modeling. Kaus (2010), Tectonophysics, v. 484, p. 36-47. Choi et al. (2013), J. Geophys. Res., v. 118, p. 2429-2444. Keller et al. (2013), Geophys. J. Int., v. 195, p. 1406-1442. \n\n The overview below directly follows Moresi et al. (2003) eqns. 23-38. However, an important distinction between this material model and the studies above is the use of compositional fields, rather than particles, to track individual components of the viscoelastic stress tensor. The material model will be updated when an option to track and calculate viscoelastic stresses with particles is implemented. \n\n Moresi et al. (2003) begins (eqn. 23) by writing the deviatoric rate of deformation ($\\hat{D}$) as the sum of elastic ($\\hat{D_{e}}$) and viscous ($\\hat{D_{v}}$) components: $\\hat{D} = \\hat{D_{e}} + \\hat{D_{v}}$.  These terms further decompose into $\\hat{D_{v}} = \\frac{\\tau}{2\\eta}$ and $\\hat{D_{e}} = \\frac{\\overset{\\nabla}{\\tau}}{2\\mu}$, where $\\tau$ is the viscous deviatoric stress, $\\eta$ is the shear viscosity, $\\mu$ is the shear modulus and $\\overset{\\nabla}{\\tau}$ is the Jaumann corotational stress rate. This later term (eqn. 24) contains the time derivative of the deviatoric stress ($\\dot{\\tau}$) and terms that account for material spin (e.g., rotation) due to advection: $\\overset{\\nabla}{\\tau} = \\dot{\\tau} + {\\tau}W -W\\tau$. Above, $W$ is the material spin tensor (eqn. 25): $W_{ij} = \\frac{1}{2} \\left (\\frac{\\partial V_{i}}{\\partial x_{j}} - \\frac{\\partial V_{j}}{\\partial x_{i}} \\right )$. \n\n If plasticity is included, the deviatoric rate of deformation may be written as: $\\hat{D} = \\hat{D_{e}} + \\hat{D_{v}} + \\hat{D_{p}}$, where $\\hat{D_{p}}$ is the plastic component. $\\hat{D_{p}}$ decomposes to $\\frac{\\tau_{y}}{2\\eta_{y}}$, where $\\tau_{y}$ is the yield stress and $\\eta_{y}$ is the viscosity rescaled to the yield surface. The Jaumann stress-rate can also be approximated using terms from the previous time step ($t$) and current time step ($t + \\Delta t^{e}$): $\\smash[t]{\\overset{\\nabla}{\\tau}}^{t + \\Delta t^{e}} \\approx \\frac{\\tau^{t + \\Delta t^{e} - \\tau^{t}}}{\\Delta t^{e}} - W^{t}\\tau^{t} + \\tau^{t}W^{t}$. In this material model, the size of the time step above ($\\Delta t^{e}$) can be specified as the numerical time step size or an independent fixed time step. If the latter case is selected, the user has an option to apply a stress averaging scheme to account for the differences between the numerical and fixed elastic time step (eqn. 32). If one selects to use a fixed elastic time step throughout the model run, this can still be achieved by using CFL and maximum time step values that restrict the numerical time step to a specific time.\n\n The formulation above allows rewriting the total rate of deformation (eqn. 29) as\n $\\tau^{t + \\Delta t^{e}} = \\eta_{eff} \\left ( 2\\hat{D}^{t + \\triangle t^{e}} + \\frac{\\tau^{t}}{\\mu \\Delta t^{e}} + \\frac{W^{t}\\tau^{t} - \\tau^{t}W^{t}}{\\mu}  \\right )$. \n\n The effective viscosity (eqn. 28) is a function of the viscosity ($\\eta$), elastic time step size ($\\Delta t^{e}$) and shear relaxation time ($ \\alpha = \\frac{\\eta}{\\mu} $): $\\eta_{eff} = \\eta \\frac{\\Delta t^{e}}{\\Delta t^{e} + \\alpha}$ The magnitude of the shear modulus thus controls how much the effective viscosity is reduced relative to the initial viscosity. \n\n Elastic effects are introduced into the governing Stokes equations through an elastic force term (eqn. 30) using stresses from the previous time step: $F^{e,t} = -\\frac{\\eta_{eff}}{\\mu \\Delta t^{e}} \\tau^{t}$. This force term is added onto the right-hand side force vector in the system of equations. \n\n When plastic yielding occurs, the effective viscosity in equation 29 and 30 is the plastic viscosity (equation 36). If the current stress is below the plastic yield stress, the effective viscosity is still as defined in equation 28. During non-linear iterations, we define the current stress prior to yielding (e.g., value compared to yield stress) as $\\tau^{t + \\Delta t^{e}} = \\eta_{eff} \\left ( 2\\hat{D}^{t + \\triangle t^{e}} + \\frac{\\tau^{t}}{\\mu \\Delta t^{e}} \\right ) $\n\n Compositional fields can each be assigned individual values of thermal diffusivity, heat capacity, density, thermal expansivity and rheological parameters. \n\n If more than one compositional field is present at a given point, viscosities are averaged with an arithmetic, geometric harmonic (default) or maximum composition scheme. \n\n The value for the components of this formula and additional parameters are read from the parameter file in subsection  'Material model\/Visco Plastic'.\n\n`viscoelastic': An implementation of a simple linear viscoelastic rheology that only includes the deviatoric components of elasticity. Specifically, the viscoelastic rheology only takes into account the elastic shear strength (e.g., shear modulus), while the tensile and volumetric strength (e.g., Young's and bulk modulus) are not considered. The model is incompressible and allows specifying an arbitrary number of compositional fields, where each field represents a different rock type or component of the viscoelastic stress tensor. The stress tensor in 2d and 3d, respectively, contains 3 or 6 components. The compositional fields representing these components must be named and listed in a very specific format, which is designed to minimize mislabeling stress tensor components as distinct 'compositional rock types' (or vice versa). For 2d models, the first three compositional fields must be labeled 'stress\\_xx', 'stress\\_yy' and 'stress\\_xy'. In 3d, the first six compositional fields must be labeled 'stress\\_xx', 'stress\\_yy', 'stress\\_zz', 'stress\\_xy', 'stress\\_xz', 'stress\\_yz'. \n\n Expanding the model to include non-linear viscous flow (e.g., diffusion\/dislocation creep) and plasticity would produce a constitutive relationship commonly referred to as partial elastoviscoplastic (e.g., pEVP) in the geodynamics community. While extensively discussed and applied within the geodynamics literature, notable references include: Moresi et al. (2003), J. Comp. Phys., v. 184, p. 476-497. Gerya and Yuen (2007), Phys. Earth. Planet. Inter., v. 163, p. 83-105. Gerya (2010), Introduction to Numerical Geodynamic Modeling. Kaus (2010), Tectonophysics, v. 484, p. 36-47. Choi et al. (2013), J. Geophys. Res., v. 118, p. 2429-2444. Keller et al. (2013), Geophys. J. Int., v. 195, p. 1406-1442. \n\n The overview below directly follows Moresi et al. (2003) eqns. 23-32. However, an important distinction between this material model and the studies above is the use of compositional fields, rather than particles, to track individual components of the viscoelastic stress tensor. The material model will be updated when an option to track and calculate viscoelastic stresses with particles is implemented. \n\n Moresi et al. (2003) begins (eqn. 23) by writing the deviatoric rate of deformation ($\\hat{D}$) as the sum of elastic ($\\hat{D_{e}}$) and viscous ($\\hat{D_{v}}$) components: $\\hat{D} = \\hat{D_{e}} + \\hat{D_{v}}$.  These terms further decompose into $\\hat{D_{v}} = \\frac{\\tau}{2\\eta}$ and $\\hat{D_{e}} = \\frac{\\overset{\\nabla}{\\tau}}{2\\mu}$, where $\\tau$ is the viscous deviatoric stress, $\\eta$ is the shear viscosity, $\\mu$ is the shear modulus and $\\overset{\\nabla}{\\tau}$ is the Jaumann corotational stress rate. This later term (eqn. 24) contains the time derivative of the deviatoric stress ($\\dot{\\tau}$) and terms that account for material spin (e.g., rotation) due to advection: $\\overset{\\nabla}{\\tau} = \\dot{\\tau} + {\\tau}W -W\\tau$. Above, $W$ is the material spin tensor (eqn. 25): $W_{ij} = \\frac{1}{2} \\left (\\frac{\\partial V_{i}}{\\partial x_{j}} - \\frac{\\partial V_{j}}{\\partial x_{i}} \\right )$. \n\n The Jaumann stress-rate can also be approximated using terms from the previous time step ($t$) and current time step ($t + \\Delta t^{e}$): $\\smash[t]{\\overset{\\nabla}{\\tau}}^{t + \\Delta t^{e}} \\approx \\frac{\\tau^{t + \\Delta t^{e} - \\tau^{t}}}{\\Delta t^{e}} - W^{t}\\tau^{t} + \\tau^{t}W^{t}$. In this material model, the size of the time step above ($\\Delta t^{e}$) can be specified as the numerical time step size or an independent fixed time step. If the latter case is selected, the user has an option to apply a stress averaging scheme to account for the differences between the numerical and fixed elastic time step (eqn. 32). If one selects to use a fixed elastic time step throughout the model run, this can still be achieved by using CFL and maximum time step values that restrict the numerical time step to a specific time.\n\n The formulation above allows rewriting the total deviatoric stress (eqn. 29) as\n $\\tau^{t + \\Delta t^{e}} = \\eta_\\text{eff} \\left ( 2\\hat{D}^{t + \\triangle t^{e}} + \\frac{\\tau^{t}}{\\mu \\Delta t^{e}} + \\frac{W^{t}\\tau^{t} - \\tau^{t}W^{t}}{\\mu}  \\right )$. \n\n The effective viscosity (eqn. 28) is a function of the viscosity ($\\eta$), elastic time step size ($\\Delta t^{e}$) and shear relaxation time ($ \\alpha = \\frac{\\eta}{\\mu} $): $\\eta_\\text{eff} = \\eta \\frac{\\Delta t^{e}}{\\Delta t^{e} + \\alpha}$ The magnitude of the shear modulus thus controls how much the effective viscosity is reduced relative to the initial viscosity. \n\n Elastic effects are introduced into the governing Stokes equations through an elastic force term (eqn. 30) using stresses from the previous time step: $F^{e,t} = -\\frac{\\eta_\\text{eff}}{\\mu \\Delta t^{e}} \\tau^{t}$. This force term is added onto the right-hand side force vector in the system of equations. \n\n The value of each compositional field representing distinct rock types at a point is interpreted to be a volume fraction of that rock type. If the sum of the compositional field volume fractions is less than one, then the remainder of the volume is assumed to be 'background material'.\n\n Several model parameters (densities, elastic shear moduli, thermal expansivities, thermal conductivies, specific heats) can be defined per-compositional field. For each material parameter the user supplies a comma delimited list of length N+1, where N is the number of compositional fields. The additional field corresponds to the value for background material. They should be ordered ''background, composition1, composition2...''. However, the first 3 (2d) or 6 (3d) composition fields correspond to components of the elastic stress tensor and their material values will not contribute to the volume fractions. If a single value is given, then all the compositional fields are given that value. Other lengths of lists are not allowed. For a given compositional field the material parameters are treated as constant, except density, which varies linearly with temperature according to the thermal expansivity. \n\n When more than one compositional field is present at a point, they are averaged arithmetically. An exception is viscosity, which may be averaged arithmetically, harmonically, geometrically, or by selecting the viscosity of the composition field with the greatest volume fraction.",
            "pattern": "377",
            "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
        },
        "Ascii reference profile": {
            "Thermal conductivity": {
                "value": "4.0",
                "default_value": "4.0",
                "documentation": "Reference conductivity",
                "pattern": "889",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal viscosity exponent": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The temperature dependence of viscosity. Dimensionless exponent.",
                "pattern": "892",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Transition depths": {
                "value": "1.5e5, 4.1e5, 6.6e5",
                "default_value": "1.5e5, 4.1e5, 6.6e5",
                "documentation": "A list of depths where the viscosity changes. Values must monotonically increase. Units: \\si{\\meter}.",
                "pattern": "893",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Use TALA": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to use the TALA instead of the ALA approximation.",
                "pattern": "891",
                "pattern_description": "[Bool]"
            },
            "Viscosity": {
                "value": "1e21",
                "default_value": "1e21",
                "documentation": "Viscosity",
                "pattern": "890",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity prefactors": {
                "value": "10., 0.1, 1., 10.",
                "default_value": "10., 0.1, 1., 10.",
                "documentation": "A list of prefactors for the viscosity that determine the viscosity profile. Each prefactor is applied in a depth range specified by the list of `Transition depths', i.e. the first prefactor is applied above the first transition depth, the second one between the first and second transition depth, and so on. To compute the viscosity profile, this prefactor is multiplied by the reference viscosity specified through the parameter `Viscosity'. List must have one more entry than Transition depths. Units: non-dimensional.",
                "pattern": "894",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Ascii data model": {
                "Data directory": {
                    "value": "$ASPECT_SOURCE_DIR\/data\/adiabatic-conditions\/ascii-data\/",
                    "default_value": "$ASPECT_SOURCE_DIR\/data\/adiabatic-conditions\/ascii-data\/",
                    "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                    "pattern": "895",
                    "pattern_description": "[DirectoryName]"
                },
                "Data file name": {
                    "value": "",
                    "default_value": "",
                    "documentation": "The file name of the model data.",
                    "pattern": "896",
                    "pattern_description": "[Anything]"
                },
                "Scale factor": {
                    "value": "1.",
                    "default_value": "1.",
                    "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                    "pattern": "897",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                }
            }
        },
        "Averaging": {
            "Averaging operation": {
                "value": "none",
                "default_value": "none",
                "documentation": "Choose the averaging operation to use.",
                "pattern": "790",
                "pattern_description": "[Selection none|arithmetic average|harmonic average|geometric average|pick largest|log average|nwd arithmetic average|nwd harmonic average|nwd geometric average ]"
            },
            "Base model": {
                "value": "simple",
                "default_value": "simple",
                "documentation": "The name of a material model that will be modified by an averaging operation. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "789",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic ]"
            },
            "Bell shape limit": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "The limit normalized distance between 0 and 1 where the bell shape becomes zero. See the manual for a more information.",
                "pattern": "791",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Compositing": {
            "Compressibility": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Material model to use for Compressibility. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "792",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
            },
            "Density": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Material model to use for Density. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "793",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
            },
            "Entropy derivative pressure": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Material model to use for Entropy derivative pressure. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "794",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
            },
            "Entropy derivative temperature": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Material model to use for Entropy derivative temperature. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "795",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
            },
            "Reaction terms": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Material model to use for Reaction terms. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "796",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
            },
            "Specific heat": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Material model to use for Specific heat. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "797",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
            },
            "Thermal conductivity": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Material model to use for Thermal conductivity. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "798",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
            },
            "Thermal expansion coefficient": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Material model to use for Thermal expansion coefficient. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "799",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
            },
            "Viscosity": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Material model to use for Viscosity. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "800",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic|unspecified ]"
            }
        },
        "Composition reaction model": {
            "Composition viscosity prefactor 1": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "A linear dependency of viscosity on the first compositional field. Dimensionless prefactor. With a value of 1.0 (the default) the viscosity does not depend on the composition.",
                "pattern": "809",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Composition viscosity prefactor 2": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "A linear dependency of viscosity on the second compositional field. Dimensionless prefactor. With a value of 1.0 (the default) the viscosity does not depend on the composition.",
                "pattern": "810",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Density differential for compositional field 1": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "If compositional fields are used, then one would frequently want to make the density depend on these fields. In this simple material model, we make the following assumptions: if no compositional fields are used in the current simulation, then the density is simply the usual one with its linear dependence on the temperature. If there are compositional fields, then the material model determines how many of them influence the density. The composition-dependence adds a term of the kind $+\\Delta \\rho \\; c_1(\\mathbf x)$. This parameter describes the value of $\\Delta \\rho$. Units: \\si{\\kilogram\\per\\meter\\cubed}\/unit change in composition.",
                "pattern": "805",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Density differential for compositional field 2": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "If compositional fields are used, then one would frequently want to make the density depend on these fields. In this simple material model, we make the following assumptions: if no compositional fields are used in the current simulation, then the density is simply the usual one with its linear dependence on the temperature. If there are compositional fields, then the material model determines how many of them influence the density. The composition-dependence adds a term of the kind $+\\Delta \\rho \\; c_2(\\mathbf x)$. This parameter describes the value of $\\Delta \\rho$. Units: \\si{\\kilogram\\per\\meter\\cubed}\/unit change in composition.",
                "pattern": "806",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Reaction depth": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Above this depth the compositional fields react: The first field gets converted to the second field. Units: \\si{\\meter}.",
                "pattern": "813",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference density": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "Reference density $\\rho_0$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "801",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "803",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. Units: \\si{\\kelvin}.",
                "pattern": "807",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "812",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\alpha$. Units: \\si{\\per\\kelvin}.",
                "pattern": "804",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of viscosity. Dimensionless exponent.",
                "pattern": "811",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity": {
                "value": "5e24",
                "default_value": "5e24",
                "documentation": "The value of the constant viscosity. Units: \\si{\\kilogram\\per\\meter\\per\\second}.",
                "pattern": "808",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Depth dependent model": {
            "Base model": {
                "value": "simple",
                "default_value": "simple",
                "documentation": "The name of a material model that will be modified by a depth dependent viscosity. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "817",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic ]"
            },
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/material-model\/rheology\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/material-model\/rheology\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "814",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "ascii_depth_profile.txt",
                "default_value": "ascii_depth_profile.txt",
                "documentation": "The file name of the model data.",
                "pattern": "815",
                "pattern_description": "[Anything]"
            },
            "Depth dependence method": {
                "value": "None",
                "default_value": "None",
                "documentation": "Method that is used to specify how the viscosity should vary with depth.",
                "pattern": "818",
                "pattern_description": "[Selection Function|File|List|None ]"
            },
            "Depth list": {
                "value": "",
                "default_value": "",
                "documentation": "A comma-separated list of depth values for use with the ``List'' ``Depth dependence method''. The list must be provided in order of increasing depth, and the last value must be greater than or equal to the maximal depth of the model. The depth list is interpreted as a layered viscosity structure and the depth values specify the maximum depths of each layer.",
                "pattern": "819",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference viscosity": {
                "value": "1.7976931348623157e+308",
                "default_value": "1.7976931348623157e+308",
                "documentation": "The value of the constant reference viscosity $\\eta_r$ that is used to scale the non-dimensional depth-dependent viscosity prefactor. Units: \\si{\\pascal\\second}.",
                "pattern": "821",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "816",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity depth file": {
                "alias": "Data file name",
                "deprecation_status": "false"
            },
            "Viscosity list": {
                "value": "",
                "default_value": "",
                "documentation": "A comma-separated list of viscosity values, corresponding to the depth values provided in ``Depth list''. The number of viscosity values specified here must be the same as the number of depths provided in ``Depth list''.",
                "pattern": "820",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Viscosity depth function": {
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "824",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "1.0e21",
                    "default_value": "1.0e21",
                    "documentation": "",
                    "pattern": "825",
                    "pattern_description": "[Anything]"
                },
                "Variable names": {
                    "value": "x,t",
                    "default_value": "x,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "822",
                    "pattern_description": "[Anything]"
                }
            }
        },
        "Depth dependent viscosity": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/material-model\/rheology\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/material-model\/rheology\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "886",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "ascii_depth_profile.txt",
                "default_value": "ascii_depth_profile.txt",
                "documentation": "The file name of the model data.",
                "pattern": "887",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "888",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Diffusion dislocation": {
            "Activation energies for diffusion creep": {
                "value": "375e3",
                "default_value": "375e3",
                "documentation": "List of activation energies, $E_a$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\joule\\per\\mole}.",
                "pattern": "850",
                "pattern_description": "[Anything]"
            },
            "Activation energies for dislocation creep": {
                "value": "530e3",
                "default_value": "530e3",
                "documentation": "List of activation energies, $E_a$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\joule\\per\\mole}.",
                "pattern": "855",
                "pattern_description": "[Anything]"
            },
            "Activation volumes for diffusion creep": {
                "value": "6e-6",
                "default_value": "6e-6",
                "documentation": "List of activation volumes, $V_a$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\meter\\cubed\\per\\mole}.",
                "pattern": "851",
                "pattern_description": "[Anything]"
            },
            "Activation volumes for dislocation creep": {
                "value": "1.4e-5",
                "default_value": "1.4e-5",
                "documentation": "List of activation volumes, $V_a$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\meter\\cubed\\per\\mole}.",
                "pattern": "856",
                "pattern_description": "[Anything]"
            },
            "Densities": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "List of densities, $\\rho$, for background mantle and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "835",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Effective viscosity coefficient": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "Scaling coefficient for effective viscosity.",
                "pattern": "830",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Grain size": {
                "value": "1e-3",
                "default_value": "1e-3",
                "documentation": "Units: \\si{\\meter}.",
                "pattern": "852",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Grain size exponents for diffusion creep": {
                "value": "3.",
                "default_value": "3.",
                "documentation": "List of grain size exponents, $m_{\\text{diffusion}}$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: None.",
                "pattern": "849",
                "pattern_description": "[Anything]"
            },
            "Heat capacity": {
                "value": "1.25e3",
                "default_value": "1.25e3",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "834",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum strain rate ratio iterations": {
                "value": "40",
                "default_value": "40",
                "documentation": "Maximum number of iterations to find the correct diffusion\/dislocation strain rate ratio.",
                "pattern": "832",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Maximum viscosity": {
                "value": "1e28",
                "default_value": "1e28",
                "documentation": "Upper cutoff for effective viscosity. Units: \\si{\\pascal\\second}.",
                "pattern": "829",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum strain rate": {
                "value": "1.4e-20",
                "default_value": "1.4e-20",
                "documentation": "Stabilizes strain dependent viscosity. Units: \\si{\\per\\second}.",
                "pattern": "827",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum viscosity": {
                "value": "1e17",
                "default_value": "1e17",
                "documentation": "Lower cutoff for effective viscosity. Units: \\si{\\pascal\\second}.",
                "pattern": "828",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Prefactors for diffusion creep": {
                "value": "1.5e-15",
                "default_value": "1.5e-15",
                "documentation": "List of viscosity prefactors, $A$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\per\\pascal\\meter}$^{m_{\\text{diffusion}}}$\\si{\\per\\second}.",
                "pattern": "847",
                "pattern_description": "[Anything]"
            },
            "Prefactors for dislocation creep": {
                "value": "1.1e-16",
                "default_value": "1.1e-16",
                "documentation": "List of viscosity prefactors, $A$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\pascal}$^{-n_{\\text{dislocation}}}$ \\si{\\per\\second}.",
                "pattern": "853",
                "pattern_description": "[Anything]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "For calculating density by thermal expansivity. Units: \\si{\\kelvin}.",
                "pattern": "826",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Strain rate residual tolerance": {
                "value": "1e-10",
                "default_value": "1e-10",
                "documentation": "Tolerance for determining the correct stress and viscosity from the strain rate by internal iteration. The tolerance is expressed as the difference between the natural logarithm of the input strain rate and the strain rate at the current iteration. This determines that strain rate is correctly partitioned between diffusion and dislocation creep assuming that both mechanisms experience the same stress.",
                "pattern": "831",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Stress exponents for diffusion creep": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "List of stress exponents, $n_{\\text{diffusion}}$, for background mantle and compositional fields, for a total of N+1 values, where N is the number of compositional fields. The stress exponent for diffusion creep is almost always equal to one. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "848",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Stress exponents for dislocation creep": {
                "value": "3.5",
                "default_value": "3.5",
                "documentation": "List of stress exponents, $n_{\\text{dislocation}}$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "854",
                "pattern_description": "[Anything]"
            },
            "Thermal diffusivity": {
                "value": "0.8e-6",
                "default_value": "0.8e-6",
                "documentation": "Units: \\si{\\meter\\squared\\per\\second}.",
                "pattern": "833",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansivities": {
                "value": "3.5e-5",
                "default_value": "3.5e-5",
                "documentation": "List of thermal expansivities for background mantle and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: \\si{\\per\\kelvin}.",
                "pattern": "836",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Viscosity averaging scheme": {
                "value": "harmonic",
                "default_value": "harmonic",
                "documentation": "When more than one compositional field is present at a point with different viscosities, we need to come up with an average viscosity at that point.  Select a weighted harmonic, arithmetic, geometric, or maximum composition.",
                "pattern": "837",
                "pattern_description": "[Selection arithmetic|harmonic|geometric|maximum composition ]"
            }
        },
        "Drucker Prager": {
            "Reference density": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "Reference density $\\rho_0$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "857",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "859",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. The reference temperature is used in the density calculation. Units: \\si{\\kelvin}.",
                "pattern": "861",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "862",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\alpha$. Units: \\si{\\per\\kelvin}.",
                "pattern": "860",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity": {
                "Angle of internal friction": {
                    "value": "0.",
                    "default_value": "0.",
                    "documentation": "The value of the angle of internal friction $\\phi$. For a value of zero, in 2d the von Mises criterion is retrieved. Angles higher than 30 degrees are harder to solve numerically. Units: degrees.",
                    "pattern": "866",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Cohesion": {
                    "value": "2e7",
                    "default_value": "2e7",
                    "documentation": "The value of the cohesion $C$. Units: \\si{\\pascal}.",
                    "pattern": "867",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Maximum viscosity": {
                    "value": "1e24",
                    "default_value": "1e24",
                    "documentation": "The value of the maximum viscosity cutoff $\\eta_max$. Units: \\si{\\pascal\\second}.",
                    "pattern": "864",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Minimum viscosity": {
                    "value": "1e19",
                    "default_value": "1e19",
                    "documentation": "The value of the minimum viscosity cutoff $\\eta_min$. Units: \\si{\\pascal\\second}.",
                    "pattern": "863",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Reference strain rate": {
                    "value": "1e-15",
                    "default_value": "1e-15",
                    "documentation": "The value of the initial strain rate prescribed during the first nonlinear iteration $\\dot{\\epsilon}_ref$. Units: \\si{\\per\\second}.",
                    "pattern": "865",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                }
            }
        },
        "Entropy model": {
            "Angle of internal friction": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "List of angles of internal friction, $\\phi$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. For a value of zero, in 2D the von Mises criterion is retrieved. Angles higher than 30 degrees are harder to solve numerically. Units: degrees.",
                "pattern": "875",
                "pattern_description": "[Anything]"
            },
            "Cohesion": {
                "value": "1e20",
                "default_value": "1e20",
                "documentation": "List of cohesions, $C$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. The extremely large default cohesion value (1e20 Pa) prevents the viscous stress from exceeding the yield stress. Units: \\si{\\pascal}.",
                "pattern": "876",
                "pattern_description": "[Anything]"
            },
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/material-model\/entropy-table\/opxtable\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/material-model\/entropy-table\/opxtable\/",
                "documentation": "The path to the model data. The path may also include the special text '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "868",
                "pattern_description": "[DirectoryName]"
            },
            "Lateral viscosity file name": {
                "value": "temp-viscosity-prefactor.txt",
                "default_value": "temp-viscosity-prefactor.txt",
                "documentation": "The file name of the lateral viscosity prefactor.",
                "pattern": "871",
                "pattern_description": "[Anything]"
            },
            "Material file name": {
                "value": "material_table.txt",
                "default_value": "material_table.txt",
                "documentation": "The file name of the material data.",
                "pattern": "869",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "Maximum lateral viscosity variation": {
                "value": "1e2",
                "default_value": "1e2",
                "documentation": "The relative cutoff value for lateral viscosity variations caused by temperature deviations. The viscosity may vary laterally by this factor squared.",
                "pattern": "874",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum thermal conductivity": {
                "value": "1000",
                "default_value": "1000",
                "documentation": "The maximum thermal conductivity that is allowed in the model. Larger values will be cut off.",
                "pattern": "885",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum viscosity": {
                "value": "1e23",
                "default_value": "1e23",
                "documentation": "The maximum viscosity that is allowed in the viscosity calculation. Larger values will be cut off.",
                "pattern": "873",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum viscosity": {
                "value": "1e19",
                "default_value": "1e19",
                "documentation": "The minimum viscosity that is allowed in the viscosity calculation. Smaller values will be cut off.",
                "pattern": "872",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Pressure dependencies of thermal conductivity": {
                "value": "3.3e-10, 3.4e-10, 3.6e-10, 1.05e-10",
                "default_value": "3.3e-10, 3.4e-10, 3.6e-10, 1.05e-10",
                "documentation": "A list of values that determine the linear scaling of the thermal conductivity with the pressure in the 'p-T-dependent' thermal conductivity formulation. Units: \\si{\\watt\\per\\meter\\per\\kelvin\\per\\pascal}.",
                "pattern": "881",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference temperatures for thermal conductivity": {
                "value": "300, 300, 300, 1200",
                "default_value": "300, 300, 300, 1200",
                "documentation": "A list of values of reference temperatures used to determine the temperature-dependence of the thermal conductivity in the 'p-T-dependent' thermal conductivity formulation. Units: \\si{\\kelvin}.",
                "pattern": "882",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference thermal conductivities": {
                "value": "2.47, 3.81, 3.52, 4.9",
                "default_value": "2.47, 3.81, 3.52, 4.9",
                "documentation": "A list of base values of the thermal conductivity for each of the horizontal layers in the 'p-T-dependent' thermal conductivity formulation. Pressure- and temperature-dependence will be appliedon top of this base value, according to the parameters 'Pressure dependencies of thermal conductivity' and 'Reference temperatures for thermal conductivity'. Units: \\si{\\watt\\per\\meter\\per\\kelvin}",
                "pattern": "880",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference viscosity": {
                "value": "1e22",
                "default_value": "1e22",
                "documentation": "The viscosity that is used in this model. \n\nUnits: \\si{\\pascal\\second}",
                "pattern": "870",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Saturation prefactors": {
                "value": "0, 0, 0, 1",
                "default_value": "0, 0, 0, 1",
                "documentation": "A list of values that indicate how a given layer in the conductivity formulation should take into account the effects of saturation on the temperature-dependence of the thermal conducitivity. This factor is multiplied with a saturation function based on the theory of Roufosse and Klemens, 1974. A value of 1 reproduces the formulation of Stackhouse et al. (2015), a value of 0 reproduces the formulation of Tosi et al., (2013). Units: none.",
                "pattern": "884",
                "pattern_description": "[List of <[Double 0...1 (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "877",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity exponents": {
                "value": "0.48, 0.56, 0.61, 1.0",
                "default_value": "0.48, 0.56, 0.61, 1.0",
                "documentation": "A list of exponents in the temperature-dependent term of the 'p-T-dependent' thermal conductivity formulation. Note that this exponent is not used (and should have a value of 1) in the formulation of Stackhouse et al. (2015). Units: none.",
                "pattern": "883",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal conductivity formulation": {
                "value": "constant",
                "default_value": "constant",
                "documentation": "Which law should be used to compute the thermal conductivity. The 'constant' law uses a constant value for the thermal conductivity. The 'p-T-dependent' formulation uses equations from Stackhouse et al. (2015): First-principles calculations of the lattice thermal conductivity of the lower mantle (https:\/\/doi.org\/10.1016\/j.epsl.2015.06.050), and Tosi et al. (2013): Mantle dynamics with pressure- and temperature-dependent thermal expansivity and conductivity (https:\/\/doi.org\/10.1016\/j.pepi.2013.02.004) to compute the thermal conductivity in dependence of temperature and pressure. The thermal conductivity parameter sets can be chosen in such a way that either the Stackhouse or the Tosi relations are used. The conductivity description can consist of several layers with different sets of parameters. Note that the Stackhouse parametrization is only valid for the lower mantle (bridgmanite).",
                "pattern": "878",
                "pattern_description": "[Selection constant|p-T-dependent ]"
            },
            "Thermal conductivity transition depths": {
                "value": "410000, 520000, 660000",
                "default_value": "410000, 520000, 660000",
                "documentation": "A list of depth values that indicate where the transitions between the different conductivity parameter sets should occur in the 'p-T-dependent' Thermal conductivity formulation (in most cases, this will be the depths of major mantle phase transitions). Units: \\si{\\meter}.",
                "pattern": "879",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Grain size model": {
            "Advect logarithm of grain size": {
                "value": "false",
                "default_value": "false",
                "documentation": "This parameter determines whether to advect the logarithm of the grain size or the grain size itself. The equation and the physics are the same, but for problems with high grain size gradients it might be preferable to advect the logarithm. ",
                "pattern": "719",
                "pattern_description": "[Bool]"
            },
            "Average specific grain boundary energy": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "The average specific grain boundary energy $\\gamma$. List must have one more entry than the Phase transition depths. Units: \\si{\\joule\\per\\meter\\squared}.",
                "pattern": "695",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Bilinear interpolation": {
                "value": "true",
                "default_value": "true",
                "documentation": "This parameter determines whether to use bilinear interpolation to compute material properties (slower but more accurate).",
                "pattern": "726",
                "pattern_description": "[Bool]"
            },
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/material-model\/steinberger\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/material-model\/steinberger\/",
                "documentation": "The path to the model data. The path may also include the special text '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the 'data\/' subdirectory of ASPECT. ",
                "pattern": "720",
                "pattern_description": "[DirectoryName]"
            },
            "Derivatives file names": {
                "value": "",
                "default_value": "",
                "documentation": "The file names of the enthalpy derivatives data. List with as many components as active compositional fields (material data is assumed to be in order with the ordering of the fields). ",
                "pattern": "722",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "Diffusion activation energy": {
                "value": "3.35e5",
                "default_value": "3.35e5",
                "documentation": "The activation energy for diffusion creep $E_{diff}$. List must have one more entry than the Phase transition depths. Units: \\si{\\joule\\per\\mole}.",
                "pattern": "705",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Diffusion activation volume": {
                "value": "4e-6",
                "default_value": "4e-6",
                "documentation": "The activation volume for diffusion creep $V_{diff}$. List must have one more entry than the Phase transition depths. Units: \\si{\\meter\\cubed\\per\\mole}.",
                "pattern": "706",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Diffusion creep exponent": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "The power-law exponent $n_{diff}$ for diffusion creep. List must have one more entry than the Phase transition depths. Units: none.",
                "pattern": "704",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Diffusion creep grain size exponent": {
                "value": "3.",
                "default_value": "3.",
                "documentation": "The diffusion creep grain size exponent $p_{diff}$ that determines the dependence of viscosity on grain size. List must have one more entry than the Phase transition depths. Units: none.",
                "pattern": "708",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Diffusion creep prefactor": {
                "value": "7.4e-15",
                "default_value": "7.4e-15",
                "documentation": "The prefactor for the diffusion creep law $A_{diff}$. List must have one more entry than the Phase transition depths. Units: \\si{\\meter}$^{p_{diff}}$\\si{\\pascal}$^{-n_{diff}}$\\si{\\per\\second}.",
                "pattern": "707",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Dislocation activation energy": {
                "value": "4.8e5",
                "default_value": "4.8e5",
                "documentation": "The activation energy for dislocation creep $E_{dis}$. List must have one more entry than the Phase transition depths. Units: \\si{\\joule\\per\\mole}.",
                "pattern": "701",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Dislocation activation volume": {
                "value": "1.1e-5",
                "default_value": "1.1e-5",
                "documentation": "The activation volume for dislocation creep $V_{dis}$. List must have one more entry than the Phase transition depths. Units: \\si{\\meter\\cubed\\per\\mole}.",
                "pattern": "702",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Dislocation creep exponent": {
                "value": "3.5",
                "default_value": "3.5",
                "documentation": "The power-law exponent $n_{dis}$ for dislocation creep. List must have one more entry than the Phase transition depths. Units: none.",
                "pattern": "700",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Dislocation creep prefactor": {
                "value": "4.5e-15",
                "default_value": "4.5e-15",
                "documentation": "The prefactor for the dislocation creep law $A_{dis}$. List must have one more entry than the Phase transition depths. Units: \\si{\\pascal}$^{-n_{dis}}$\\si{\\per\\second}.",
                "pattern": "703",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Dislocation viscosity iteration number": {
                "value": "100",
                "default_value": "100",
                "documentation": "We need to perform an iteration inside the computation of the dislocation viscosity, because it depends on the dislocation strain rate, which depends on the dislocation viscosity itself. This number determines the maximum number of iterations that are performed. ",
                "pattern": "699",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Dislocation viscosity iteration threshold": {
                "value": "1e-3",
                "default_value": "1e-3",
                "documentation": "We need to perform an iteration inside the computation of the dislocation viscosity, because it depends on the dislocation strain rate, which depends on the dislocation viscosity itself. This number determines the termination accuracy, i.e. if the dislocation viscosity changes by less than this factor we terminate the iteration.",
                "pattern": "698",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Geometric constant": {
                "value": "3.",
                "default_value": "3.",
                "documentation": "The geometric constant $c$ used in the paleowattmeter grain size reduction law. List must have one more entry than the Phase transition depths. Units: none.",
                "pattern": "697",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Grain growth activation energy": {
                "value": "3.5e5",
                "default_value": "3.5e5",
                "documentation": "The activation energy for grain growth $E_g$. List must have one more entry than the Phase transition depths. Units: \\si{\\joule\\per\\mole}.",
                "pattern": "685",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Grain growth activation volume": {
                "value": "8e-6",
                "default_value": "8e-6",
                "documentation": "The activation volume for grain growth $V_g$. List must have one more entry than the Phase transition depths. Units: \\si{\\meter\\cubed\\per\\mole}.",
                "pattern": "686",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Grain growth exponent": {
                "value": "3.",
                "default_value": "3.",
                "documentation": "The exponent of the grain growth law $p_g$. This is an experimentally determined grain growth constant. List must have one more entry than the Phase transition depths. Units: none.",
                "pattern": "687",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Grain growth rate constant": {
                "value": "1.5e-5",
                "default_value": "1.5e-5",
                "documentation": "The prefactor for the Ostwald ripening grain growth law $G_0$. This is dependent on water content, which is assumed to be 50 H\/$10^6$ Si for the default value. List must have one more entry than the Phase transition depths. Units: \\si{\\meter}$^{p_g}$\\si{\\per\\second}.",
                "pattern": "688",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Grain size evolution formulation": {
                "value": "paleowattmeter",
                "default_value": "paleowattmeter",
                "documentation": "A flag indicating whether the material model should use the paleowattmeter approach of Austin and Evans (2007) for grain size reduction in the dislocation creep regime, the paleopiezometer approach from Hall and Parmetier (2003), or the pinned grain damage approach from Mulyukova and Bercovici (2018).",
                "pattern": "693",
                "pattern_description": "[Selection paleowattmeter|paleopiezometer|pinned grain damage ]"
            },
            "Lower mantle grain size scaling": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "A scaling factor for the grain size in the lower mantle. In models where the high grain size contrast between the upper and lower mantle causes numerical problems, the grain size in the lower mantle can be scaled to a larger value, simultaneously scaling the viscosity prefactors and grain growth parameters to keep the same physical behavior. Differences to the original formulation only occur when material with a smaller grain size than the recrystallization grain size cross the upper-lower mantle boundary. The real grain size can be obtained by dividing the model grain size by this value. Units: none.",
                "pattern": "718",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Material file format": {
                "value": "perplex",
                "default_value": "perplex",
                "documentation": "The material file format to be read in the property tables.",
                "pattern": "724",
                "pattern_description": "[Selection perplex|hefesto ]"
            },
            "Material file names": {
                "value": "pyr-ringwood88.txt",
                "default_value": "pyr-ringwood88.txt",
                "documentation": "The file names of the material data. List with as many components as active compositional fields (material data is assumed to be in order with the ordering of the fields). ",
                "pattern": "721",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "Maximum latent heat substeps": {
                "value": "1",
                "default_value": "1",
                "documentation": "The maximum number of substeps over the temperature pressure range to calculate the averaged enthalpy gradient over a cell.",
                "pattern": "716",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Maximum specific heat": {
                "value": "6000.",
                "default_value": "6000.",
                "documentation": "The maximum specific heat that is allowed in the whole model domain. Units: J\/kg\/K.",
                "pattern": "713",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum temperature dependence of viscosity": {
                "value": "100.",
                "default_value": "100.",
                "documentation": "The factor by which viscosity at adiabatic temperature and ambient temperature are allowed to differ (a value of x means that the viscosity can be x times higher or x times lower compared to the value at adiabatic temperature. This parameter is introduced to limit local viscosity contrasts, but still allow for a widely varying viscosity over the whole mantle range. Units: none.",
                "pattern": "709",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum thermal expansivity": {
                "value": "1e-3",
                "default_value": "1e-3",
                "documentation": "The maximum thermal expansivity that is allowed in the whole model domain. Units: 1\/K.",
                "pattern": "715",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Maximum viscosity": {
                "value": "1e26",
                "default_value": "1e26",
                "documentation": "The maximum viscosity that is allowed in the whole model domain. Units: Pa \\, s.",
                "pattern": "711",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum grain size": {
                "value": "1e-5",
                "default_value": "1e-5",
                "documentation": "The minimum grain size that is used for the material model. This parameter is introduced to limit local viscosity contrasts, but still allows for a widely varying viscosity over the whole mantle range. Units: \\si{\\meter}.",
                "pattern": "717",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum specific heat": {
                "value": "500.",
                "default_value": "500.",
                "documentation": "The minimum specific heat that is allowed in the whole model domain. Units: J\/kg\/K.",
                "pattern": "712",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum thermal expansivity": {
                "value": "1e-5",
                "default_value": "1e-5",
                "documentation": "The minimum thermal expansivity that is allowed in the whole model domain. Units: 1\/K.",
                "pattern": "714",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Minimum viscosity": {
                "value": "1e18",
                "default_value": "1e18",
                "documentation": "The minimum viscosity that is allowed in the whole model domain. Units: Pa \\, s.",
                "pattern": "710",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Phase transition Clapeyron slopes": {
                "value": "",
                "default_value": "",
                "documentation": "A list of Clapeyron slopes for each phase transition. A positive Clapeyron slope indicates that the phase transition will occur in a greater depth, if the temperature is higher than the one given in Phase transition temperatures and in a smaller depth, if the temperature is smaller than the one given in Phase transition temperatures. For negative slopes the other way round. List must have the same number of entries as Phase transition depths. Units: \\si{\\pascal\\per\\kelvin}.",
                "pattern": "684",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Phase transition depths": {
                "value": "",
                "default_value": "",
                "documentation": "A list of depths where phase transitions occur. Values must monotonically increase. Units: \\si{\\meter}.",
                "pattern": "681",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Phase transition temperatures": {
                "value": "",
                "default_value": "",
                "documentation": "A list of temperatures where phase transitions occur. Higher or lower temperatures lead to phase transition occurring in smaller or greater depths than given in Phase transition depths, depending on the Clapeyron slope given in Phase transition Clapeyron slopes. List must have the same number of entries as Phase transition depths. Units: \\si{\\kelvin}.",
                "pattern": "682",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Phase transition widths": {
                "value": "",
                "default_value": "",
                "documentation": "A list of widths for each phase transition. This is only use to specify the region where the recrystallized grain size is assigned after material has crossed a phase transition and should accordingly be chosen similar to the maximum cell width expected at the phase transition.List must have the same number of entries as Phase transition depths. Units: \\si{\\meter}.",
                "pattern": "683",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Phase volume fraction": {
                "value": "0.4",
                "default_value": "0.4",
                "documentation": "The volume fraction of one of the phases in the two-phase damage model of Bercovici and Ricard (2012). The volume fraction of the other phase can be simply calculated by subtracting from one. This parameter is only used in the pinned state grain damage formulation.Units: none.",
                "pattern": "692",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "Reciprocal required strain": {
                "value": "10.",
                "default_value": "10.",
                "documentation": "This parameter ($\\lambda$) gives an estimate of the strain necessary to achieve a new grain size. List must have one more entry than the Phase transition depths.",
                "pattern": "690",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Recrystallized grain size": {
                "value": "",
                "default_value": "",
                "documentation": "The grain size $d_{ph}$ to that a phase will be reduced to when crossing a phase transition. When set to zero, grain size will not be reduced. List must have the same number of entries as Phase transition depths. Units: \\si{\\meter}.",
                "pattern": "691",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference compressibility": {
                "value": "4e-12",
                "default_value": "4e-12",
                "documentation": "The value of the reference compressibility. Units: \\si{\\per\\pascal}.",
                "pattern": "680",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference density": {
                "value": "3300",
                "default_value": "3300",
                "documentation": "The reference density $\\rho_0$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "674",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $cp$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "678",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. Units: \\si{\\kelvin}.",
                "pattern": "675",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "677",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\alpha$. Units: \\si{\\per\\kelvin}.",
                "pattern": "679",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Use enthalpy for material properties": {
                "value": "true",
                "default_value": "true",
                "documentation": "This parameter determines whether to use the enthalpy to calculate the thermal expansivity and specific heat (if true) or use the thermal expansivity and specific heat values from the material properties table directly (if false).",
                "pattern": "725",
                "pattern_description": "[Bool]"
            },
            "Use paleowattmeter": {
                "value": "default",
                "default_value": "default",
                "documentation": "A flag indicating whether the computation should use the paleowattmeter approach of Austin and Evans (2007) for grain size reduction in the dislocation creep regime (if true) or the paleopiezometer approach from Hall and Parmetier (2003) (if false). This parameter has been removed. Use 'Grain size evolution formulation' instead.",
                "pattern": "694",
                "pattern_description": "[Selection true|false|default ]"
            },
            "Use table properties": {
                "value": "false",
                "default_value": "false",
                "documentation": "This parameter determines whether to use the table properties also for density, thermal expansivity and specific heat. If false the properties are generated as in the simple compressible plugin.",
                "pattern": "723",
                "pattern_description": "[Bool]"
            },
            "Viscosity": {
                "value": "5e24",
                "default_value": "5e24",
                "documentation": "The value of the constant viscosity. Units: \\si{\\pascal\\second}.",
                "pattern": "676",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Work fraction for boundary area change": {
                "value": "0.1",
                "default_value": "0.1",
                "documentation": "The fraction $\\chi$ of work done by dislocation creep to change the grain boundary area. List must have one more entry than the Phase transition depths. Units: \\si{\\joule\\per\\meter\\squared}.",
                "pattern": "696",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Grain damage partitioning": {
                "Grain size reduction work fraction exponent": {
                    "value": "10",
                    "default_value": "10",
                    "documentation": "This parameter determines the variability in how much shear heating is partitioned into grain damage. A higher value suggests a wider temperature range over which the partitioning coefficient is high.",
                    "pattern": "731",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Maximum grain size reduction work fraction": {
                    "value": "1e-1",
                    "default_value": "1e-1",
                    "documentation": "This parameter determines the maximum value of the partitioning coefficient, which governs the amount of shear heating partitioned into grain damage in the pinned state limit.",
                    "pattern": "730",
                    "pattern_description": "[Double 0...1 (inclusive)]"
                },
                "Minimum grain size reduction work fraction": {
                    "value": "1e-12",
                    "default_value": "1e-12",
                    "documentation": "This parameter determines the minimum value of the partitioning coefficient, which governs the amount of shear heating partitioned into grain damage in the pinned state limit.",
                    "pattern": "729",
                    "pattern_description": "[Double 0...1 (inclusive)]"
                },
                "Temperature for maximum grain damage partitioning": {
                    "value": "283",
                    "default_value": "283",
                    "documentation": "This parameter determines the temperature at which the computed coefficient of shear energy partitioned into grain damage is maximum. This is used in the pinned state limit of the grain size evolution. One choice of this parameter is the surface temperature of the seafloor, see Mulyukova and Bercovici (2018) for details.",
                    "pattern": "728",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Temperature for minimum grain damage partitioning": {
                    "value": "1600",
                    "default_value": "1600",
                    "documentation": "This parameter determines the temperature at which the computed coefficient of shear energy partitioned into grain damage is minimum. This is used in the pinned state limit of the grain size evolution. One choice of this parameter is the mantle temperature at the ridge axis, see Mulyukova and Bercovici (2018) for details.",
                    "pattern": "727",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                }
            }
        },
        "Latent heat": {
            "Composition viscosity prefactor": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "A linear dependency of viscosity on composition. Dimensionless prefactor.",
                "pattern": "735",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Compressibility": {
                "value": "5.124e-12",
                "default_value": "5.124e-12",
                "documentation": "The value of the compressibility $\\kappa$. Units: \\si{\\per\\pascal}.",
                "pattern": "740",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Corresponding phase for density jump": {
                "value": "",
                "default_value": "",
                "documentation": "A list of phases, which correspond to the Phase transition density jumps. The density jumps occur only in the phase that is given by this phase value. 0 stands for the 1st compositional fields, 1 for the second compositional field and -1 for none of them. List must have the same number of entries as Phase transition depths. Units: \\si{\\pascal\\per\\kelvin}.",
                "pattern": "743",
                "pattern_description": "[List of <[Integer range 0...2147483647 (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Define transition by depth instead of pressure": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to list phase transitions by depth or pressure. If this parameter is true, then the input file will use Phase transitions depths and Phase transition widths to define the phase transition. If it is false, the parameter file will read in phase transition data from Phase transition pressures and Phase transition pressure widths.",
                "pattern": "751",
                "pattern_description": "[Bool]"
            },
            "Density differential for compositional field 1": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "If compositional fields are used, then one would frequently want to make the density depend on these fields. In this simple material model, we make the following assumptions: if no compositional fields are used in the current simulation, then the density is simply the usual one with its linear dependence on the temperature. If there are compositional fields, then the density only depends on the first one in such a way that the density has an additional term of the kind $+\\Delta \\rho \\; c_1(\\mathbf x)$. This parameter describes the value of $\\Delta \\rho$. Units: \\si{\\kilogram\\per\\meter\\cubed}\/unit change in composition.",
                "pattern": "741",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Maximum viscosity": {
                "value": "1e24",
                "default_value": "1e24",
                "documentation": "Limit for the maximum viscosity in the model. Units: Pa \\, s.",
                "pattern": "746",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum viscosity": {
                "value": "1e19",
                "default_value": "1e19",
                "documentation": "Limit for the minimum viscosity in the model. Units: Pa \\, s.",
                "pattern": "745",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Phase transition Clapeyron slopes": {
                "value": "",
                "default_value": "",
                "documentation": "A list of Clapeyron slopes for each phase transition. A positive Clapeyron slope indicates that the phase transition will occur in a greater depth, if the temperature is higher than the one given in Phase transition temperatures and in a smaller depth, if the temperature is smaller than the one given in Phase transition temperatures. For negative slopes the other way round. List must have the same number of entries as Phase transition depths. Units: \\si{\\pascal\\per\\kelvin}.",
                "pattern": "755",
                "pattern_description": "[Anything]"
            },
            "Phase transition density jumps": {
                "value": "",
                "default_value": "",
                "documentation": "A list of density jumps at each phase transition. A positive value means that the density increases with depth. The corresponding entry in Corresponding phase for density jump determines if the density jump occurs in peridotite, eclogite or none of them.List must have the same number of entries as Phase transition depths. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "742",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Phase transition depths": {
                "value": "",
                "default_value": "",
                "documentation": "A list of depths where phase transitions occur. Values must monotonically increase. Units: \\si{\\meter}.",
                "pattern": "747",
                "pattern_description": "[Anything]"
            },
            "Phase transition pressure widths": {
                "value": "",
                "default_value": "",
                "documentation": "A list of widths for each phase transition, in terms of pressure. The phase functions are scaled with these values, leading to a jump between phases for a value of zero and a gradual transition for larger values. List must have the same number of entries as Phase transition pressures. Define transition by depth instead of pressure must be set to false to use this parameter. Units: \\si{\\pascal}.",
                "pattern": "750",
                "pattern_description": "[Anything]"
            },
            "Phase transition pressures": {
                "value": "",
                "default_value": "",
                "documentation": "A list of pressures where phase transitions occur. Values must monotonically increase. Define transition by depth instead of pressure must be set to false to use this parameter. Units: \\si{\\pascal}.",
                "pattern": "749",
                "pattern_description": "[Anything]"
            },
            "Phase transition temperature lower limits": {
                "value": "-1.7976931348623157e+308",
                "default_value": "-1.7976931348623157e+308",
                "documentation": "A list of lower temperature limits for each phase transition. Below this temperature the respective phase transition is deactivated. The default value means there is no lower limit for any phase transition. List must have the same number of entries as Phase transition depths. When the optional temperature limits are applied, the user has to be careful about the consistency between adjacent phases. Phase transitions should be continuous in pressure-temperature space. We recommend producing a phase diagram with simple model setups to check the implementation as a starting point.Units: \\si{\\kelvin}.",
                "pattern": "754",
                "pattern_description": "[Anything]"
            },
            "Phase transition temperature upper limits": {
                "value": "1.7976931348623157e+308",
                "default_value": "1.7976931348623157e+308",
                "documentation": "A list of upper temperature limits for each phase transition. Above this temperature the respective phase transition is deactivated. The default value means there is no upper limit for any phase transitions. List must have the same number of entries as Phase transition depths. When the optional temperature limits are applied, the user has to be careful about the consistency between adjacent phases. Phase transitions should be continuous in pressure-temperature space. We recommend producing a phase diagram with simple model setups to check the implementation as a starting point.Units: \\si{\\kelvin}.",
                "pattern": "753",
                "pattern_description": "[Anything]"
            },
            "Phase transition temperatures": {
                "value": "",
                "default_value": "",
                "documentation": "A list of temperatures where phase transitions occur. Higher or lower temperatures lead to phase transition occurring in smaller or greater depths than given in Phase transition depths, depending on the Clapeyron slope given in Phase transition Clapeyron slopes. List must have the same number of entries as Phase transition depths. Units: \\si{\\kelvin}.",
                "pattern": "752",
                "pattern_description": "[Anything]"
            },
            "Phase transition widths": {
                "value": "",
                "default_value": "",
                "documentation": "A list of widths for each phase transition, in terms of depth. The phase functions are scaled with these values, leading to a jump between phases for a value of zero and a gradual transition for larger values. List must have the same number of entries as Phase transition depths. Units: \\si{\\meter}.",
                "pattern": "748",
                "pattern_description": "[Anything]"
            },
            "Reference density": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "Reference density $\\rho_0$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "732",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "738",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. Units: \\si{\\kelvin}.",
                "pattern": "733",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "2.38",
                "default_value": "2.38",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "737",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "4e-5",
                "default_value": "4e-5",
                "documentation": "The value of the thermal expansion coefficient $\\beta$. Units: \\si{\\per\\kelvin}.",
                "pattern": "739",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of viscosity. Dimensionless exponent.",
                "pattern": "736",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity": {
                "value": "5e24",
                "default_value": "5e24",
                "documentation": "The value of the constant viscosity. Units: \\si{\\pascal\\second}.",
                "pattern": "734",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity prefactors": {
                "value": "",
                "default_value": "",
                "documentation": "A list of prefactors for the viscosity for each phase. The reference viscosity will be multiplied by this factor to get the corresponding viscosity for each phase. List must have one more entry than Phase transition depths. Units: non-dimensional.",
                "pattern": "744",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Latent heat melt": {
            "A1": {
                "value": "1085.7",
                "default_value": "1085.7",
                "documentation": "Constant parameter in the quadratic function that approximates the solidus of peridotite. Units: \\si{\\degreeCelsius}.",
                "pattern": "767",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "A2": {
                "value": "1.329e-7",
                "default_value": "1.329e-7",
                "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the solidus of peridotite. Units: \\si{\\degreeCelsius\\per\\pascal}.",
                "pattern": "768",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "A3": {
                "value": "-5.1e-18",
                "default_value": "-5.1e-18",
                "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the solidus of peridotite. Units: \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                "pattern": "769",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "B1": {
                "value": "1475.0",
                "default_value": "1475.0",
                "documentation": "Constant parameter in the quadratic function that approximates the lherzolite liquidus used for calculating the fraction of peridotite-derived melt. Units: \\si{\\degreeCelsius}.",
                "pattern": "770",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "B2": {
                "value": "8.0e-8",
                "default_value": "8.0e-8",
                "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the  lherzolite liquidus used for calculating the fraction of peridotite-derived melt. Units: \\si{\\degreeCelsius\\per\\pascal}.",
                "pattern": "771",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "B3": {
                "value": "-3.2e-18",
                "default_value": "-3.2e-18",
                "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the  lherzolite liquidus used for calculating the fraction of peridotite-derived melt. Units: \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                "pattern": "772",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "C1": {
                "value": "1780.0",
                "default_value": "1780.0",
                "documentation": "Constant parameter in the quadratic function that approximates the liquidus of peridotite. Units: \\si{\\degreeCelsius}.",
                "pattern": "773",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "C2": {
                "value": "4.50e-8",
                "default_value": "4.50e-8",
                "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the liquidus of peridotite. Units: \\si{\\degreeCelsius\\per\\pascal}.",
                "pattern": "774",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "C3": {
                "value": "-2.0e-18",
                "default_value": "-2.0e-18",
                "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the liquidus of peridotite. Units: \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                "pattern": "775",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Composition viscosity prefactor": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "A linear dependency of viscosity on composition. Dimensionless prefactor.",
                "pattern": "759",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Compressibility": {
                "value": "5.124e-12",
                "default_value": "5.124e-12",
                "documentation": "The value of the compressibility $\\kappa$. Units: \\si{\\per\\pascal}.",
                "pattern": "765",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "D1": {
                "value": "976.0",
                "default_value": "976.0",
                "documentation": "Constant parameter in the quadratic function that approximates the solidus of pyroxenite. Units: \\si{\\degreeCelsius}.",
                "pattern": "781",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "D2": {
                "value": "1.329e-7",
                "default_value": "1.329e-7",
                "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the solidus of pyroxenite. Note that this factor is different from the value given in Sobolev, 2011, because they use the potential temperature whereas we use the absolute temperature. Units: \\si{\\degreeCelsius\\per\\pascal}.",
                "pattern": "782",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "D3": {
                "value": "-5.1e-18",
                "default_value": "-5.1e-18",
                "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the solidus of pyroxenite. Units: \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                "pattern": "783",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Density differential for compositional field 1": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "If compositional fields are used, then one would frequently want to make the density depend on these fields. In this simple material model, we make the following assumptions: if no compositional fields are used in the current simulation, then the density is simply the usual one with its linear dependence on the temperature. If there are compositional fields, then the density only depends on the first one in such a way that the density has an additional term of the kind $+\\Delta \\rho \\; c_1(\\mathbf x)$. This parameter describes the value of $\\Delta \\rho$. Units: \\si{\\kilogram\\per\\meter\\cubed}\/unit change in composition.",
                "pattern": "766",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "E1": {
                "value": "663.8",
                "default_value": "663.8",
                "documentation": "Prefactor of the linear depletion term in the quadratic function that approximates the melt fraction of pyroxenite. Units: \\si{\\degreeCelsius\\per\\pascal}.",
                "pattern": "784",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "E2": {
                "value": "-611.4",
                "default_value": "-611.4",
                "documentation": "Prefactor of the quadratic depletion term in the quadratic function that approximates the melt fraction of pyroxenite. Units: \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                "pattern": "785",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Mass fraction cpx": {
                "value": "0.15",
                "default_value": "0.15",
                "documentation": "Mass fraction of clinopyroxene in the peridotite to be molten. Units: non-dimensional.",
                "pattern": "780",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Maximum pyroxenite melt fraction": {
                "value": "0.5429",
                "default_value": "0.5429",
                "documentation": "Maximum melt fraction of pyroxenite in this parameterization. At higher temperatures peridotite begins to melt.",
                "pattern": "787",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Peridotite melting entropy change": {
                "value": "-300.",
                "default_value": "-300.",
                "documentation": "The entropy change for the phase transition from solid to melt of peridotite. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "779",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Pyroxenite melting entropy change": {
                "value": "-400.",
                "default_value": "-400.",
                "documentation": "The entropy change for the phase transition from solid to melt of pyroxenite. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "786",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Reference density": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "Reference density $\\rho_0$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "756",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "762",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. Units: \\si{\\kelvin}.",
                "pattern": "757",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Relative density of melt": {
                "value": "0.9",
                "default_value": "0.9",
                "documentation": "The relative density of melt compared to the solid material. This means, the density change upon melting is this parameter times the density of solid material.Units: non-dimensional.",
                "pattern": "788",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "2.38",
                "default_value": "2.38",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "761",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "4e-5",
                "default_value": "4e-5",
                "documentation": "The value of the thermal expansion coefficient $\\alpha_s$. Units: \\si{\\per\\kelvin}.",
                "pattern": "763",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient of melt": {
                "value": "6.8e-5",
                "default_value": "6.8e-5",
                "documentation": "The value of the thermal expansion coefficient $\\alpha_f$. Units: \\si{\\per\\kelvin}.",
                "pattern": "764",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of viscosity. Dimensionless exponent.",
                "pattern": "760",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity": {
                "value": "5e24",
                "default_value": "5e24",
                "documentation": "The value of the constant viscosity. Units: \\si{\\pascal\\second}.",
                "pattern": "758",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "beta": {
                "value": "1.5",
                "default_value": "1.5",
                "documentation": "Exponent of the melting temperature in the melt fraction calculation. Units: non-dimensional.",
                "pattern": "778",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "r1": {
                "value": "0.5",
                "default_value": "0.5",
                "documentation": "Constant in the linear function that approximates the clinopyroxene reaction coefficient. Units: non-dimensional.",
                "pattern": "776",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "r2": {
                "value": "8e-11",
                "default_value": "8e-11",
                "documentation": "Prefactor of the linear pressure term in the linear function that approximates the clinopyroxene reaction coefficient. Units: \\si{\\per\\pascal}.",
                "pattern": "777",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Melt boukare": {
            "Einstein temperatures": {
                "value": "418.1, 561.0, 297.6, 540.2, 505.75, 558.1, 558.1",
                "default_value": "418.1, 561.0, 297.6, 540.2, 505.75, 558.1, 558.1",
                "documentation": "List of Einstein temperatures for each different endmember.Units: K.",
                "pattern": "561",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Endmember names": {
                "value": "FeSiO3_bridgmanite, MgSiO3_bridgmanite, FeO_periclase, MgO_periclase, FeO_melt, MgO_melt, SiO2_melt",
                "default_value": "FeSiO3_bridgmanite, MgSiO3_bridgmanite, FeO_periclase, MgO_periclase, FeO_melt, MgO_melt, SiO2_melt",
                "documentation": "Names of the endmember components used in the equation of state and the melting model, and whose parameters are determined by the other input parameters of this material model. The order the parameters are given in has to be the same as the order the endmember names are given in. Units: none.",
                "pattern": "552",
                "pattern_description": "[List of <[MultipleSelection MgSiO3_bridgmanite|FeSiO3_bridgmanite|MgO_periclase|FeO_periclase|MgO_melt|FeO_melt|SiO2_melt ]> of length 0...4294967295 (inclusive)]"
            },
            "Endmember states": {
                "value": "solid, solid, solid, solid, melt, melt, melt",
                "default_value": "solid, solid, solid, solid, melt, melt, melt",
                "documentation": "States of the endmember components used in the equation of state and the melting model. For each endmember, this list has to define if they belong to the melt or to the solid. The order the states are given in has to be the same as the order the 'Endmember names' are given in. Units: none.",
                "pattern": "553",
                "pattern_description": "[List of <[MultipleSelection solid|melt ]> of length 0...4294967295 (inclusive)]"
            },
            "Exponential melt weakening factor": {
                "value": "27",
                "default_value": "27",
                "documentation": "The porosity dependence of the viscosity. Units: dimensionless.",
                "pattern": "539",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Fe mantle melting temperature": {
                "value": "3424.5",
                "default_value": "3424.5",
                "documentation": "The melting temperature of one of the components in the melting model, the Fe mantle endmember.Units: K.",
                "pattern": "546",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Fe number of moles": {
                "value": "0.48",
                "default_value": "0.48",
                "documentation": "The number of moles of Fe atoms mixing on a pseudosite in the mantle lattice, This is needed because we use an empirical model fitting the full Boukare model, and can be changed to reflect partition coefficients from other sources.Units: none.",
                "pattern": "548",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "First derivatives of the bulk modulus": {
                "value": "4.14, 4.14, 4.9, 3.95, 5.0802472229003905, 4.25, 4.25",
                "default_value": "4.14, 4.14, 4.9, 3.95, 5.0802472229003905, 4.25, 4.25",
                "documentation": "The pressure derivative of the bulk modulus at the reference temperature and reference pressure for each different endmember component.Units: none.",
                "pattern": "559",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Include melting and freezing": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to include melting and freezing (according to a simplified linear melting approximation in the model (if true), or not (if false).",
                "pattern": "544",
                "pattern_description": "[Bool]"
            },
            "Linear coefficients for specific heat polynomial": {
                "value": "6.36191292e-03, -3.31714290e-03, 3.36163516e-03, -6.35318887e-03, -2.41909947e-03, -2.41909947e-03, -2.41909947e-03",
                "default_value": "6.36191292e-03, -3.31714290e-03, 3.36163516e-03, -6.35318887e-03, -2.41909947e-03, -2.41909947e-03, -2.41909947e-03",
                "documentation": "The first of three coefficients that are used to compute the specific heat capacities for each different endmember at the reference temperature and reference pressure. This coefficient describes the linear part of the temperature dependence. Units: J\/kg\/K\/K.",
                "pattern": "565",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Melting time scale for operator splitting": {
                "value": "1e3",
                "default_value": "1e3",
                "documentation": "In case the operator splitting scheme is used, the porosity field can not be set to a new equilibrium melt fraction instantly, but the model has to provide a melting time scale instead. This time scale defines how fast melting happens, or more specifically, the parameter defines the time after which the deviation of the porosity from the equilibrium melt fraction will be reduced to a fraction of $1\/e$. So if the melting time scale is small compared to the time step size, the reaction will be so fast that the porosity is very close to the equilibrium melt fraction after reactions are computed. Conversely, if the melting time scale is large compared to the time step size, almost no melting and freezing will occur.\n\nAlso note that the melting time scale has to be larger than or equal to the reaction time step used in the operator splitting scheme, otherwise reactions can not be computed. If the model does not use operator splitting, this parameter is not used. Units: yr or s, depending on the ``Use years in output instead of seconds'' parameter.",
                "pattern": "545",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Mg mantle melting temperature": {
                "value": "4821.2",
                "default_value": "4821.2",
                "documentation": "The melting temperature of one of the components in the melting model, the Mg mantle endmember.Units: K.",
                "pattern": "547",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Mg number of moles": {
                "value": "0.62",
                "default_value": "0.62",
                "documentation": "The number of moles of Mg atoms mixing on a pseudosite in the mantle lattice, This is needed because we use an empirical model fitting the full Boukare model, and can be changed to reflect partition coefficients from other sources.Units: none.",
                "pattern": "549",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Molar masses": {
                "value": "0.1319287, 0.1003887, 0.0718444, 0.0403044, 0.0707624708, 0.048592178, 0.048592178",
                "default_value": "0.1319287, 0.1003887, 0.0718444, 0.0403044, 0.0707624708, 0.048592178, 0.048592178",
                "documentation": "Molar masses of the different endmembersUnits: kg\/mol.",
                "pattern": "554",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Number of atoms": {
                "value": "5.0, 5.0, 2.0, 2.0, 2.092, 2.419, 2.419",
                "default_value": "5.0, 5.0, 2.0, 2.0, 2.092, 2.419, 2.419",
                "documentation": "Number of atoms per in the formula of each endmember.Units: none.",
                "pattern": "555",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference bulk moduli": {
                "value": "2.81e11, 2.51e+11, 1.52e11, 1.616e11, 166652774642.11273, 2.317e11, 2.317e11",
                "default_value": "2.81e11, 2.51e+11, 1.52e11, 1.616e11, 166652774642.11273, 2.317e11, 2.317e11",
                "documentation": "List of bulk moduli for each different endmember at the reference temperature and reference pressure.Units: Pa.",
                "pattern": "558",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference bulk viscosity": {
                "value": "1e22",
                "default_value": "1e22",
                "documentation": "The value of the constant bulk viscosity $\\xi_0$ of the solid matrix. This viscosity may be modified by both temperature and porosity dependencies. Units: $Pa \\, s$.",
                "pattern": "537",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference enthalpies": {
                "value": "-1082910.0, -1442310.0, -262240.0, -601570.0, -195245.49100022088, -538009.8, -538009.8",
                "default_value": "-1082910.0, -1442310.0, -262240.0, -601570.0, -195245.49100022088, -538009.8, -538009.8",
                "documentation": "List of enthalpies at the reference temperature and reference pressure for each different endmember component.Units: J\/mol.",
                "pattern": "562",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference entropies": {
                "value": "95.0, 62.6, 58.6, 26.5, 95.0299295525918, 64.9, 64.9",
                "default_value": "95.0, 62.6, 58.6, 26.5, 95.0299295525918, 64.9, 64.9",
                "documentation": "List of entropies at the reference temperature and reference pressure for each different endmember component.Units: J\/K\/mol.",
                "pattern": "563",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference melt viscosity": {
                "value": "10",
                "default_value": "10",
                "documentation": "The value of the constant melt viscosity $\\eta_f$. Units: $Pa \\, s$.",
                "pattern": "538",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference permeability": {
                "value": "1e-8",
                "default_value": "1e-8",
                "documentation": "Reference permeability of the solid host rock.Units: $m^2$.",
                "pattern": "543",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Reference pressure": {
                "value": "1e11",
                "default_value": "1e11",
                "documentation": "Reference pressure used to compute the material propertiesof the different endmember components.Units: Pa.",
                "pattern": "551",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Reference shear viscosity": {
                "value": "5e20",
                "default_value": "5e20",
                "documentation": "The value of the constant viscosity $\\eta_0$ of the solid matrix. This viscosity may be modified by both temperature and porosity dependencies. Units: $Pa \\, s$.",
                "pattern": "536",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat capacities": {
                "value": "139.546209, 161.546581, 52.0016403, 73.1147154, 79.5326013, 79.5326013, 79.5326013",
                "default_value": "139.546209, 161.546581, 52.0016403, 73.1147154, 79.5326013, 79.5326013, 79.5326013",
                "documentation": "List of specific heat capacities for each different endmember at the reference temperature and reference pressure.Units: J\/kg\/K.",
                "pattern": "564",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference temperature": {
                "value": "298.15",
                "default_value": "298.15",
                "documentation": "Reference temperature used to compute the material propertiesof the different endmember components.Units: K.",
                "pattern": "550",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Reference thermal expansivities": {
                "value": "1.87e-05, 1.87e-05, 3.22e-05, 3.11e-05, 2.9614332469401705e-05, 2.06e-05, 2.06e-05",
                "default_value": "1.87e-05, 1.87e-05, 3.22e-05, 3.11e-05, 2.9614332469401705e-05, 2.06e-05, 2.06e-05",
                "documentation": "List of thermal expansivities for each different endmember at the reference temperature and reference pressure.Units: 1\/K.",
                "pattern": "557",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference volumes": {
                "value": "2.534e-05, 2.445e-05, 1.206e-05, 1.125e-05, 1.2325484447664221e-05, 1.218e-05, 1.218e-05",
                "default_value": "2.534e-05, 2.445e-05, 1.206e-05, 1.125e-05, 1.2325484447664221e-05, 1.218e-05, 1.218e-05",
                "documentation": "Reference volumes of the different endmembers.Units: $m^3$.",
                "pattern": "556",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Second coefficients for specific heat polynomial": {
                "value": "-4.13886524e+06, -3.57533814e+06, -1.19540964e+06, -7.33679285e+05, -1.61692272e+06, -1.61692272e+06, -1.61692272e+06",
                "default_value": "-4.13886524e+06, -3.57533814e+06, -1.19540964e+06, -7.33679285e+05, -1.61692272e+06, -1.61692272e+06, -1.61692272e+06",
                "documentation": "The second of three coefficients that are used to compute the specific heat capacities for each different endmember at the reference temperature and reference pressure. This coefficient describes the part of the temperature dependence that scales as the inverse of the square of the temperature. Units: J K\/kg.",
                "pattern": "566",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Second derivatives of the bulk modulus": {
                "value": "-1.6e-11, -1.6e-11, -3.2e-11, -2.4e-11, -3.9742163085937504e-11, -2.14e-11, -2.14e-11",
                "default_value": "-1.6e-11, -1.6e-11, -3.2e-11, -2.4e-11, -3.9742163085937504e-11, -2.14e-11, -2.14e-11",
                "documentation": "The second pressure derivative of the bulk modulus at the reference temperature and reference pressure for each different endmember component.Units: 1\/Pa.",
                "pattern": "560",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal bulk viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of the bulk viscosity. Dimensionless exponent. See the general documentation of this model for a formula that states the dependence of the viscosity on this factor, which is called $\\beta$ there.",
                "pattern": "541",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: $W\/m\/K$.",
                "pattern": "542",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of the shear viscosity. Dimensionless exponent. See the general documentation of this model for a formula that states the dependence of the viscosity on this factor, which is called $\\beta$ there.",
                "pattern": "540",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Third coefficients for specific heat polynomial": {
                "value": "-464.775577, -1112.54791, 25.5067110, -592.994207, -562.222634, -562.222634, -562.222634",
                "default_value": "-464.775577, -1112.54791, 25.5067110, -592.994207, -562.222634, -562.222634, -562.222634",
                "documentation": "The third of three coefficients that are used to compute the specific heat capacities for each different endmember at the reference temperature and reference pressure. This coefficient describes the part of the temperature dependence that scales as the inverse of the square root of the temperatureUnits: J\/kg\/sqrt(K).",
                "pattern": "567",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Melt global": {
            "Depletion density change": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The density contrast between material with a depletion of 1 and a depletion of zero. Negative values indicate lower densities of depleted material. Depletion is indicated by the compositional field with the name peridotite. Not used if this field does not exist in the model. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "581",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Depletion solidus change": {
                "value": "200.0",
                "default_value": "200.0",
                "documentation": "The solidus temperature change for a depletion of 100\\%. For positive values, the solidus gets increased for a positive peridotite field (depletion) and lowered for a negative peridotite field (enrichment). Scaling with depletion is linear. Only active when fractional melting is used. Units: \\si{\\kelvin}.",
                "pattern": "583",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Exponential depletion strengthening factor": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "$\\alpha_F$: exponential dependency of viscosity on the depletion field $F$ (called peridotite). Dimensionless factor. With a value of 0.0 (the default) the viscosity does not depend on the depletion. The effective viscosity increasedue to depletion is defined as $exp( \\alpha_F * F)$. Rationale: melting dehydrates the source rock by removing most of the volatiles,and makes it stronger. Hirth and Kohlstedt (1996) report typical values around a factor 100 to 1000 viscosity contrast between wet and dry rocks, although some experimental studies report a smaller (factor 10) contrast (e.g. Fei et al., 2013).",
                "pattern": "590",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Exponential melt weakening factor": {
                "value": "27.",
                "default_value": "27.",
                "documentation": "The porosity dependence of the viscosity. Units: dimensionless.",
                "pattern": "574",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Include melting and freezing": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to include melting and freezing (according to a simplified linear melting approximation in the model (if true), or not (if false).",
                "pattern": "588",
                "pattern_description": "[Bool]"
            },
            "Maximum Depletion viscosity change": {
                "value": "1.0e3",
                "default_value": "1.0e3",
                "documentation": "$\\Delta \\eta_{F,max}$: maximum depletion strengthening of viscosity. Rationale: melting dehydrates the source rock by removing most of the volatiles,and makes it stronger. Hirth and Kohlstedt (1996) report typical values around a factor 100 to 1000 viscosity contrast between wet and dry rocks, although some experimental studies report a smaller (factor 10) contrast (e.g. Fei et al., 2013).",
                "pattern": "591",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Melt bulk modulus derivative": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The value of the pressure derivative of the melt bulk modulus. Units: None.",
                "pattern": "587",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Melt compressibility": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The value of the compressibility of the melt. Units: \\si{\\per\\pascal}.",
                "pattern": "586",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Melting time scale for operator splitting": {
                "value": "1e3",
                "default_value": "1e3",
                "documentation": "In case the operator splitting scheme is used, the porosity field can not be set to a new equilibrium melt fraction instantly, but the model has to provide a melting time scale instead. This time scale defines how fast melting happens, or more specifically, the parameter defines the time after which the deviation of the porosity from the equilibrium melt fraction will be reduced to a fraction of $1\/e$. So if the melting time scale is small compared to the time step size, the reaction will be so fast that the porosity is very close to the equilibrium melt fraction after reactions are computed. Conversely, if the melting time scale is large compared to the time step size, almost no melting and freezing will occur.\n\nAlso note that the melting time scale has to be larger than or equal to the reaction time step used in the operator splitting scheme, otherwise reactions can not be computed. If the model does not use operator splitting, this parameter is not used. Units: yr or s, depending on the ``Use years in output instead of seconds'' parameter.",
                "pattern": "589",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Pressure solidus change": {
                "value": "6e-8",
                "default_value": "6e-8",
                "documentation": "The linear solidus temperature change with pressure. For positive values, the solidus gets increased for positive pressures. Units: \\si{\\per\\pascal}.",
                "pattern": "584",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Reference bulk viscosity": {
                "value": "1e22",
                "default_value": "1e22",
                "documentation": "The value of the constant bulk viscosity $\\xi_0$ of the solid matrix. This viscosity may be modified by both temperature and porosity dependencies. Units: \\si{\\pascal\\second}.",
                "pattern": "572",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference melt density": {
                "value": "2500.",
                "default_value": "2500.",
                "documentation": "Reference density of the melt\/fluid$\\rho_{f,0}$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "569",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference melt viscosity": {
                "value": "10.",
                "default_value": "10.",
                "documentation": "The value of the constant melt viscosity $\\eta_f$. Units: \\si{\\pascal\\second}.",
                "pattern": "573",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference permeability": {
                "value": "1e-8",
                "default_value": "1e-8",
                "documentation": "Reference permeability of the solid host rock.Units: \\si{\\meter\\squared}.",
                "pattern": "580",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Reference shear viscosity": {
                "value": "5e20",
                "default_value": "5e20",
                "documentation": "The value of the constant viscosity $\\eta_0$ of the solid matrix. This viscosity may be modified by both temperature and porosity dependencies. Units: \\si{\\pascal\\second}.",
                "pattern": "571",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference solid density": {
                "value": "3000.",
                "default_value": "3000.",
                "documentation": "Reference density of the solid $\\rho_{s,0}$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "568",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "578",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. The reference temperature is used in both the density and viscosity formulas. Units: \\si{\\kelvin}.",
                "pattern": "570",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Solid compressibility": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The value of the compressibility of the solid matrix. Units: \\si{\\per\\pascal}.",
                "pattern": "585",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Surface solidus": {
                "value": "1300.",
                "default_value": "1300.",
                "documentation": "Solidus for a pressure of zero. Units: \\si{\\kelvin}.",
                "pattern": "582",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal bulk viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of the bulk viscosity. Dimensionless exponent. See the general documentation of this model for a formula that states the dependence of the viscosity on this factor, which is called $\\beta$ there.",
                "pattern": "576",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "577",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\beta$. Units: \\si{\\per\\kelvin}.",
                "pattern": "579",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of the shear viscosity. Dimensionless exponent. See the general documentation of this model for a formula that states the dependence of the viscosity on this factor, which is called $\\beta$ there.",
                "pattern": "575",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Melt simple": {
            "A1": {
                "value": "1085.7",
                "default_value": "1085.7",
                "documentation": "Constant parameter in the quadratic function that approximates the solidus of peridotite. Units: \\si{\\degreeCelsius}.",
                "pattern": "615",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "A2": {
                "value": "1.329e-7",
                "default_value": "1.329e-7",
                "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the solidus of peridotite. Units: \\si{\\degreeCelsius\\per\\pascal}.",
                "pattern": "616",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "A3": {
                "value": "-5.1e-18",
                "default_value": "-5.1e-18",
                "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the solidus of peridotite. Units: \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                "pattern": "617",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "B1": {
                "value": "1475.0",
                "default_value": "1475.0",
                "documentation": "Constant parameter in the quadratic function that approximates the lherzolite liquidus used for calculating the fraction of peridotite-derived melt. Units: \\si{\\degreeCelsius}.",
                "pattern": "618",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "B2": {
                "value": "8.0e-8",
                "default_value": "8.0e-8",
                "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the  lherzolite liquidus used for calculating the fraction of peridotite-derived melt. Units: \\si{\\degreeCelsius\\per\\pascal}.",
                "pattern": "619",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "B3": {
                "value": "-3.2e-18",
                "default_value": "-3.2e-18",
                "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the  lherzolite liquidus used for calculating the fraction of peridotite-derived melt. Units: \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                "pattern": "620",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "C1": {
                "value": "1780.0",
                "default_value": "1780.0",
                "documentation": "Constant parameter in the quadratic function that approximates the liquidus of peridotite. Units: \\si{\\degreeCelsius}.",
                "pattern": "621",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "C2": {
                "value": "4.50e-8",
                "default_value": "4.50e-8",
                "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the liquidus of peridotite. Units: \\si{\\degreeCelsius\\per\\pascal}.",
                "pattern": "622",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "C3": {
                "value": "-2.0e-18",
                "default_value": "-2.0e-18",
                "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the liquidus of peridotite. Units: \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                "pattern": "623",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Depletion density change": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The density contrast between material with a depletion of 1 and a depletion of zero. Negative values indicate lower densities of depleted material. Depletion is indicated by the compositional field with the name peridotite. Not used if this field does not exist in the model. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "613",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Depletion solidus change": {
                "value": "200.0",
                "default_value": "200.0",
                "documentation": "The solidus temperature change for a depletion of 100\\%. For positive values, the solidus gets increased for a positive peridotite field (depletion) and lowered for a negative peridotite field (enrichment). Scaling with depletion is linear. Only active when fractional melting is used. Units: \\si{\\kelvin}.",
                "pattern": "614",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Exponential melt weakening factor": {
                "value": "27.",
                "default_value": "27.",
                "documentation": "The porosity dependence of the viscosity. Units: dimensionless.",
                "pattern": "598",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Freezing rate": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "Freezing rate of melt when in subsolidus regions. If this parameter is set to a number larger than 0.0, it specifies the fraction of melt that will freeze per year (or per second, depending on the ``Use years in output instead of seconds'' parameter), as soon as the porosity exceeds the equilibrium melt fraction, and the equilibrium melt fraction falls below the depletion. In this case, melt will freeze according to the given rate until one of those conditions is not fulfilled anymore. The reasoning behind this is that there should not be more melt present than the equilibrium melt fraction, as melt production decreases with increasing depletion, but the freezing process of melt also reduces the depletion by the same amount, and as soon as the depletion falls below the equilibrium melt fraction, we expect that material should melt again (no matter how much melt is present). This is quite a simplification and not a realistic freezing parameterization, but without tracking the melt composition, there is no way to compute freezing rates accurately. If this parameter is set to zero, no freezing will occur. Note that freezing can never be faster than determined by the ``Melting time scale for operator splitting''. The product of the ``Freezing rate'' and the ``Melting time scale for operator splitting'' defines how fast freezing occurs with respect to melting (if the product is 0.5, melting will occur twice as fast as freezing). Units: 1\/yr or 1\/s, depending on the ``Use years in output instead of seconds'' parameter.",
                "pattern": "611",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Mass fraction cpx": {
                "value": "0.15",
                "default_value": "0.15",
                "documentation": "Mass fraction of clinopyroxene in the peridotite to be molten. Units: non-dimensional.",
                "pattern": "628",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Melt bulk modulus derivative": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The value of the pressure derivative of the melt bulk modulus. Units: None.",
                "pattern": "608",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Melt compressibility": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The value of the compressibility of the melt. Units: \\si{\\per\\pascal}.",
                "pattern": "607",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Melt extraction depth": {
                "value": "1000.0",
                "default_value": "1000.0",
                "documentation": "Depth above that melt will be extracted from the model, which is done by a negative reaction term proportional to the porosity field. Units: \\si{\\meter}.",
                "pattern": "605",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Melting time scale for operator splitting": {
                "value": "1e3",
                "default_value": "1e3",
                "documentation": "Because the operator splitting scheme is used, the porosity field can not be set to a new equilibrium melt fraction instantly, but the model has to provide a melting time scale instead. This time scale defines how fast melting happens, or more specifically, the parameter defines the time after which the deviation of the porosity from the equilibrium melt fraction will be reduced to a fraction of $1\/e$. So if the melting time scale is small compared to the time step size, the reaction will be so fast that the porosity is very close to the equilibrium melt fraction after reactions are computed. Conversely, if the melting time scale is large compared to the time step size, almost no melting and freezing will occur.\n\nAlso note that the melting time scale has to be larger than or equal to the reaction time step used in the operator splitting scheme, otherwise reactions can not be computed. Units: yr or s, depending on the ``Use years in output instead of seconds'' parameter.",
                "pattern": "612",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Peridotite melting entropy change": {
                "value": "-300.",
                "default_value": "-300.",
                "documentation": "The entropy change for the phase transition from solid to melt of peridotite. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "627",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Reference bulk viscosity": {
                "value": "1e22",
                "default_value": "1e22",
                "documentation": "The value of the constant bulk viscosity $\\xi_0$ of the solid matrix. This viscosity may be modified by both temperature and porosity dependencies. Units: \\si{\\pascal\\second}.",
                "pattern": "596",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference melt density": {
                "value": "2500.",
                "default_value": "2500.",
                "documentation": "Reference density of the melt\/fluid$\\rho_{f,0}$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "593",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference melt viscosity": {
                "value": "10.",
                "default_value": "10.",
                "documentation": "The value of the constant melt viscosity $\\eta_f$. Units: \\si{\\pascal\\second}.",
                "pattern": "597",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference permeability": {
                "value": "1e-8",
                "default_value": "1e-8",
                "documentation": "Reference permeability of the solid host rock.Units: \\si{\\meter\\squared}.",
                "pattern": "604",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Reference shear viscosity": {
                "value": "5e20",
                "default_value": "5e20",
                "documentation": "The value of the constant viscosity $\\eta_0$ of the solid matrix. This viscosity may be modified by both temperature and porosity dependencies. Units: \\si{\\pascal\\second}.",
                "pattern": "595",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference solid density": {
                "value": "3000.",
                "default_value": "3000.",
                "documentation": "Reference density of the solid $\\rho_{s,0}$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "592",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "602",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. The reference temperature is used in both the density and viscosity formulas. Units: \\si{\\kelvin}.",
                "pattern": "594",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Solid compressibility": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The value of the compressibility of the solid matrix. Units: \\si{\\per\\pascal}.",
                "pattern": "606",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal bulk viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of the bulk viscosity. Dimensionless exponent. See the general documentation of this model for a formula that states the dependence of the viscosity on this factor, which is called $\\beta$ there.",
                "pattern": "600",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "601",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\beta$. Units: \\si{\\per\\kelvin}.",
                "pattern": "603",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of the shear viscosity. Dimensionless exponent. See the general documentation of this model for a formula that states the dependence of the viscosity on this factor, which is called $\\beta$ there.",
                "pattern": "599",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Use fractional melting": {
                "value": "false",
                "default_value": "false",
                "documentation": "If fractional melting should be used (if true), including a solidus change based on depletion (in this case, the amount of melt that has migrated away from its origin), and freezing of melt when it has moved to a region with temperatures lower than the solidus; or if batch melting should be used (if false), assuming that the melt fraction only depends on temperature and pressure, and how much melt has already been generated at a given point, but not considering movement of melt in the melting parameterization.\n\nNote that melt does not freeze unless the 'Freezing rate' parameter is set to a value larger than 0.",
                "pattern": "610",
                "pattern_description": "[Bool]"
            },
            "Use full compressibility": {
                "value": "false",
                "default_value": "false",
                "documentation": "If the compressibility should be used everywhere in the code (if true), changing the volume of material when the density changes, or only in the momentum conservation and advection equations (if false).",
                "pattern": "609",
                "pattern_description": "[Bool]"
            },
            "beta": {
                "value": "1.5",
                "default_value": "1.5",
                "documentation": "Exponent of the melting temperature in the melt fraction calculation. Units: non-dimensional.",
                "pattern": "626",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "r1": {
                "value": "0.5",
                "default_value": "0.5",
                "documentation": "Constant in the linear function that approximates the clinopyroxene reaction coefficient. Units: non-dimensional.",
                "pattern": "624",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "r2": {
                "value": "8e-11",
                "default_value": "8e-11",
                "documentation": "Prefactor of the linear pressure term in the linear function that approximates the clinopyroxene reaction coefficient. Units: \\si{\\per\\pascal}.",
                "pattern": "625",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Modified Tait model": {
            "Einstein temperature": {
                "value": "600.",
                "default_value": "600.",
                "documentation": "The Einstein temperature at the reference pressure and temperature. Units: \\si{\\kelvin}.",
                "pattern": "635",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference bulk modulus derivative": {
                "value": "4.",
                "default_value": "4.",
                "documentation": "The value of the first pressure derivative of the isothermal bulk modulus at the reference pressure and temperature. Units: None.",
                "pattern": "633",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference density": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "The density at the reference pressure and temperature. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "631",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference isothermal bulk modulus": {
                "value": "125e9",
                "default_value": "125e9",
                "documentation": "The isothermal bulk modulus at the reference pressure and temperature. Units: \\si{\\pascal}.",
                "pattern": "632",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference pressure": {
                "value": "1e5",
                "default_value": "1e5",
                "documentation": "Reference pressure $P_0$. Units: \\si{\\pascal}.",
                "pattern": "629",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "298.15",
                "default_value": "298.15",
                "documentation": "Reference temperature $T_0$. Units: \\si{\\kelvin}.",
                "pattern": "630",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference thermal expansivity": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The thermal expansion coefficient at the reference pressure and temperature. Units: \\si{\\per\\kelvin}.",
                "pattern": "634",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the constant thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "637",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity": {
                "value": "1e21",
                "default_value": "1e21",
                "documentation": "The value of the constant viscosity $\\eta_0$. Units: \\si{\\pascal\\second}.",
                "pattern": "636",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference heat capacity function": {
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "640",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "1.25e3",
                    "default_value": "1.25e3",
                    "documentation": "",
                    "pattern": "641",
                    "pattern_description": "[Anything]"
                },
                "Variable names": {
                    "value": "x,t",
                    "default_value": "x,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "638",
                    "pattern_description": "[Anything]"
                }
            }
        },
        "Multicomponent": {
            "Densities": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "List of densities for background mantle and compositional fields,for a total of N+M+1 values, where N is the number of compositional fields and M is the number of phases. If only one value is given, then all use the same value. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "643",
                "pattern_description": "[Anything]"
            },
            "Heat capacities": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "List of specific heats $C_p$ for background mantle and compositional fields,for a total of N+M+1 values, where N is the number of compositional fields and M is the number of phases. If only one value is given, then all use the same value. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "645",
                "pattern_description": "[Anything]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. Units: \\si{\\kelvin}.",
                "pattern": "646",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Specific heats": {
                "alias": "Heat capacities",
                "deprecation_status": "false"
            },
            "Thermal conductivities": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "List of thermal conductivities for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "648",
                "pattern_description": "[Anything]"
            },
            "Thermal expansivities": {
                "value": "0.000040",
                "default_value": "0.000040",
                "documentation": "List of thermal expansivities for background mantle and compositional fields,for a total of N+M+1 values, where N is the number of compositional fields and M is the number of phases. If only one value is given, then all use the same value. Units: \\si{\\per\\kelvin}.",
                "pattern": "644",
                "pattern_description": "[Anything]"
            },
            "Viscosities": {
                "value": "1.e21",
                "default_value": "1.e21",
                "documentation": "List of viscosities for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: \\si{\\pascal\\second}.",
                "pattern": "647",
                "pattern_description": "[Anything]"
            },
            "Viscosity averaging scheme": {
                "value": "harmonic",
                "default_value": "harmonic",
                "documentation": "When more than one compositional field is present at a point with different viscosities, we need to come up with an average viscosity at that point.  Select a weighted harmonic, arithmetic, geometric, or maximum composition.",
                "pattern": "649",
                "pattern_description": "[Selection arithmetic|harmonic|geometric|maximum composition ]"
            }
        },
        "Multicomponent compressible": {
            "Isochoric specific heats": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "List of isochoric specific heats $C_v$ for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "655",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Isothermal bulk modulus pressure derivatives": {
                "value": "4.",
                "default_value": "4.",
                "documentation": "List of isothermal pressure derivatives of the bulk moduli for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: [].",
                "pattern": "653",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference densities": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "List of densities for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "651",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference isothermal compressibilities": {
                "value": "4e-12",
                "default_value": "4e-12",
                "documentation": "List of isothermal compressibilities for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: \\si{\\per\\pascal}.",
                "pattern": "652",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference temperatures": {
                "value": "298.15",
                "default_value": "298.15",
                "documentation": "List of reference temperatures $T_0$ for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: \\si{\\kelvin}.",
                "pattern": "650",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference thermal expansivities": {
                "value": "4.e-5",
                "default_value": "4.e-5",
                "documentation": "List of thermal expansivities for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: \\si{\\per\\kelvin}.",
                "pattern": "654",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal conductivities": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "List of thermal conductivities for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "657",
                "pattern_description": "[Anything]"
            },
            "Viscosities": {
                "value": "1.e21",
                "default_value": "1.e21",
                "documentation": "List of viscosities for background mantle and compositional fields,for a total of N+1 values, where N is the number of compositional fields.If only one value is given, then all use the same value. Units: \\si{\\pascal\\second}.",
                "pattern": "656",
                "pattern_description": "[Anything]"
            },
            "Viscosity averaging scheme": {
                "value": "harmonic",
                "default_value": "harmonic",
                "documentation": "When more than one compositional field is present at a point with different viscosities, we need to come up with an average viscosity at that point.  Select a weighted harmonic, arithmetic, geometric, or maximum composition.",
                "pattern": "658",
                "pattern_description": "[Selection arithmetic|harmonic|geometric|maximum composition ]"
            }
        },
        "Nondimensional model": {
            "Di": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "Dissipation number. Pick 0.0 for incompressible computations.",
                "pattern": "661",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Ra": {
                "value": "1e4",
                "default_value": "1e4",
                "documentation": "Rayleigh number Ra",
                "pattern": "660",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference density": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "Reference density $\\rho_0$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "659",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "663",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Use TALA": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to use the TALA instead of the ALA approximation.",
                "pattern": "666",
                "pattern_description": "[Bool]"
            },
            "Viscosity depth prefactor": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "Exponential depth prefactor for viscosity.",
                "pattern": "665",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity temperature prefactor": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "Exponential temperature prefactor for viscosity.",
                "pattern": "664",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "gamma": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "Grueneisen parameter",
                "pattern": "662",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "PerpleX lookup model": {
            "Maximum material pressure": {
                "value": "1.e12",
                "default_value": "1.e12",
                "documentation": "The value of the maximum pressure used to query PerpleX. Units: \\si{\\pascal}.",
                "pattern": "673",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum material temperature": {
                "value": "6000.",
                "default_value": "6000.",
                "documentation": "The value of the maximum temperature used to query PerpleX. Units: \\si{\\kelvin}.",
                "pattern": "671",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum material pressure": {
                "value": "1.e5",
                "default_value": "1.e5",
                "documentation": "The value of the minimum pressure used to query PerpleX. Units: \\si{\\pascal}.",
                "pattern": "672",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum material temperature": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The value of the minimum temperature used to query PerpleX. Units: \\si{\\kelvin}.",
                "pattern": "670",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "PerpleX input file name": {
                "value": "rock.dat",
                "default_value": "rock.dat",
                "documentation": "The name of the PerpleX input file (should end with .dat).",
                "pattern": "667",
                "pattern_description": "[Anything]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "669",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity": {
                "value": "5e24",
                "default_value": "5e24",
                "documentation": "The value of the viscosity $\\eta$. Units: \\si{\\pascal\\second}.",
                "pattern": "668",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Prescribed viscosity": {
            "Base model": {
                "value": "simple",
                "default_value": "simple",
                "documentation": "The name of a material model that will be modified by the prescribed viscosity material model. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for that for more information.",
                "pattern": "523",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic ]"
            },
            "Indicator function": {
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "526",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "0; 0; 0",
                    "default_value": "0; 0; 0",
                    "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                    "pattern": "525",
                    "pattern_description": "[Anything]"
                },
                "Variable names": {
                    "value": "x,y,t",
                    "default_value": "x,y,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "524",
                    "pattern_description": "[Anything]"
                }
            },
            "Viscosity function": {
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "529",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "0; 0; 0",
                    "default_value": "0; 0; 0",
                    "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                    "pattern": "528",
                    "pattern_description": "[Anything]"
                },
                "Variable names": {
                    "value": "x,y,t",
                    "default_value": "x,y,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "527",
                    "pattern_description": "[Anything]"
                }
            }
        },
        "Replace lithosphere viscosity": {
            "Base model": {
                "value": "simple",
                "default_value": "simple",
                "documentation": "The name of a material model that will be modified by a replacingthe viscosity in the lithosphere by a constant value. Valid values for this parameter are the names of models that are also valid for the ``Material models\/Model name'' parameter. See the documentation for more information.",
                "pattern": "530",
                "pattern_description": "[Selection Steinberger|ascii reference profile|averaging|compositing|composition reaction|depth dependent|diffusion dislocation|drucker prager|entropy model|grain size|latent heat|latent heat melt|melt boukare|melt global|melt simple|modified tait|multicomponent|multicomponent compressible|nondimensional|perplex lookup|prescribed viscosity|replace lithosphere viscosity|simple|simple compressible|simpler|simpler with crust|visco plastic|viscoelastic ]"
            },
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/lithosphere-mask\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/initial-temperature\/lithosphere-mask\/",
                "documentation": "The path to the LAB depth data file",
                "pattern": "534",
                "pattern_description": "[DirectoryName]"
            },
            "Depth specification method": {
                "value": "Value",
                "default_value": "Value",
                "documentation": "Method that is used to specify the depth of the lithosphere-asthenosphere boundary.",
                "pattern": "532",
                "pattern_description": "[Selection File|Value ]"
            },
            "LAB depth filename": {
                "value": "LAB_CAM2016.txt",
                "default_value": "LAB_CAM2016.txt",
                "documentation": "File from which the lithosphere-asthenosphere boundary depth data is read.",
                "pattern": "535",
                "pattern_description": "[FileName (Type: input)]"
            },
            "Lithosphere viscosity": {
                "value": "1e23",
                "default_value": "1e23",
                "documentation": "The viscosity within lithosphere, applied abovethe maximum lithosphere depth.",
                "pattern": "531",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum lithosphere depth": {
                "value": "200000.0",
                "default_value": "200000.0",
                "documentation": "Units: \\si{\\meter}.The maximum depth of the lithosphere. The model will be NaNs below this depth.",
                "pattern": "533",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Simple compressible model": {
            "Reference compressibility": {
                "value": "4e-12",
                "default_value": "4e-12",
                "documentation": "The value of the reference compressibility. Units: \\si{\\per\\pascal}.",
                "pattern": "382",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference density": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "Reference density $\\rho_0$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "378",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "380",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "379",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\alpha$. Units: \\si{\\per\\kelvin}.",
                "pattern": "381",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity": {
                "value": "1000000000000000000000.000000",
                "default_value": "1000000000000000000000.000000",
                "documentation": "The value of the viscosity $\\eta$. Units: \\si{\\pascal\\second}.",
                "pattern": "383",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Simple model": {
            "Composition viscosity prefactor": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "A linear dependency of viscosity on the first compositional field. Dimensionless prefactor. With a value of 1.0 (the default) the viscosity does not depend on the composition. See the general documentation of this model for a formula that states the dependence of the viscosity on this factor, which is called $\\xi$ there.",
                "pattern": "518",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Density differential for compositional field 1": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "If compositional fields are used, then one would frequently want to make the density depend on these fields. In this simple material model, we make the following assumptions: if no compositional fields are used in the current simulation, then the density is simply the usual one with its linear dependence on the temperature. If there are compositional fields, then the material model determines how many of them influence the density. The composition-dependence adds a term of the kind $+\\Delta \\rho \\; c_1(\\mathbf x)$. This parameter describes the value of $\\Delta \\rho$. Units: \\si{\\kilogram\\per\\meter\\cubed}\/unit change in composition.",
                "pattern": "515",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Maximum thermal prefactor": {
                "value": "1.0e2",
                "default_value": "1.0e2",
                "documentation": "The maximum value of the viscosity prefactor associated with temperature dependence.",
                "pattern": "520",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum thermal prefactor": {
                "value": "1.0e-2",
                "default_value": "1.0e-2",
                "documentation": "The minimum value of the viscosity prefactor associated with temperature dependence.",
                "pattern": "521",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference density": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "Reference density $\\rho_0$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "511",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "513",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. The reference temperature is used in both the density and viscosity formulas. Units: \\si{\\kelvin}.",
                "pattern": "516",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "522",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\alpha$. Units: \\si{\\per\\kelvin}.",
                "pattern": "514",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal viscosity exponent": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "The temperature dependence of viscosity. Dimensionless exponent. See the general documentation of this model for a formula that states the dependence of the viscosity on this factor, which is called $\\beta$ there.",
                "pattern": "519",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity": {
                "value": "5e24",
                "default_value": "5e24",
                "documentation": "The value of the constant viscosity $\\eta_0$. This viscosity may be modified by both temperature and compositional dependencies. Units: \\si{\\pascal\\second}.",
                "pattern": "517",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Simpler model": {
            "Reference density": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "Reference density $\\rho_0$. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "384",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "The value of the specific heat $C_p$. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "386",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. The reference temperature is used in both the density and viscosity formulas. Units: \\si{\\kelvin}.",
                "pattern": "385",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "388",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "2e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\alpha$. Units: \\si{\\per\\kelvin}.",
                "pattern": "387",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Viscosity": {
                "value": "5000000000000000452984832.000000",
                "default_value": "5000000000000000452984832.000000",
                "documentation": "The value of the viscosity $\\eta$. Units: \\si{\\pascal\\second}.",
                "pattern": "389",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Simpler with crust model": {
            "Jump height": {
                "value": "170.e3",
                "default_value": "100000",
                "documentation": "The height at which the viscosity changes. Units: m.",
                "pattern": "902",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Lower viscosity": {
                "value": "1.e20",
                "default_value": "1e20",
                "documentation": "The value of the viscosity $\\eta_L$ in the lower layer. Units: $Pa s$.",
                "pattern": "900",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference density": {
                "value": "3300",
                "default_value": "3300",
                "documentation": "Reference density $\\rho_0$. Units: $kg\/m^3$.",
                "pattern": "898",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference specific heat": {
                "value": "1250",
                "default_value": "1250",
                "documentation": "The value of the specific heat capacity $c_p$. Units: $J\/kg\/K$.",
                "pattern": "904",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "0.0",
                "default_value": "293",
                "documentation": "The reference temperature $T_0$. The reference temperature is used in the density formula. Units: $K$.",
                "pattern": "899",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "1.0",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Units: $W\/m\/K$.",
                "pattern": "903",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal expansion coefficient": {
                "value": "4e-5",
                "default_value": "2e-5",
                "documentation": "The value of the thermal expansion coefficient $\\alpha$. Units: $1\/K$.",
                "pattern": "905",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Upper viscosity": {
                "value": "1.e23",
                "default_value": "1e23",
                "documentation": "The value of the viscosity $\\eta_U$ in the upper layer. Units: $Pa s$.",
                "pattern": "901",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Steinberger model": {
            "Bilinear interpolation": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to use bilinear interpolation to compute material properties (slower but more accurate). ",
                "pattern": "413",
                "pattern_description": "[Bool]"
            },
            "Composition viscosity prefactors": {
                "value": "1",
                "default_value": "1",
                "documentation": "List of N prefactors that are used to modify the reference viscosity, where N is either equal to one or the number of chemical components in the simulation. If only one value is given, then all components use the same value. Units: \\si{\\pascal\\second}.",
                "pattern": "398",
                "pattern_description": "[Anything]"
            },
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/material-model\/steinberger\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/material-model\/steinberger\/",
                "documentation": "The path to the model data. The path may also include the special text '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT. ",
                "pattern": "409",
                "pattern_description": "[DirectoryName]"
            },
            "Derivatives file names": {
                "value": "",
                "default_value": "",
                "documentation": "The file names of the enthalpy derivatives data. List with as many components as active compositional fields (material data is assumed to be in order with the ordering of the fields).",
                "pattern": "411",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "Latent heat": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to include latent heat effects in the calculation of thermal expansivity and specific heat. If true, ASPECT follows the approach of Nakagawa et al. 2009, using pressure and temperature derivatives of the enthalpy to calculate the thermal expansivity and specific heat. If false, ASPECT uses the thermal expansivity and specific heat values from the material properties table.",
                "pattern": "414",
                "pattern_description": "[Bool]"
            },
            "Lateral viscosity file name": {
                "value": "temp-viscosity-prefactor.txt",
                "default_value": "temp-viscosity-prefactor.txt",
                "documentation": "The file name of the lateral viscosity data. ",
                "pattern": "392",
                "pattern_description": "[Anything]"
            },
            "Material file format": {
                "value": "perplex",
                "default_value": "perplex",
                "documentation": "The material file format to be read in the property tables.",
                "pattern": "412",
                "pattern_description": "[Selection perplex|hefesto ]"
            },
            "Material file names": {
                "value": "pyr-ringwood88.txt",
                "default_value": "pyr-ringwood88.txt",
                "documentation": "The file names of the material data (material data is assumed to be in order with the ordering of the compositional fields). Note that there are three options on how many files need to be listed here: 1. If only one file is provided, it is used for the whole model domain, and compositional fields are ignored. 2. If there is one more file name than the number of compositional fields, then the first file is assumed to define a `background composition' that is modified by the compositional fields. If there are exactly as many files as compositional fields, the fields are assumed to represent the fractions of different materials and the average property is computed as a sum of the value of the compositional field times the material property of that field.",
                "pattern": "410",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "Maximum latent heat substeps": {
                "value": "1",
                "default_value": "1",
                "documentation": "The maximum number of substeps over the temperature pressure range to calculate the averaged enthalpy gradient over a cell.",
                "pattern": "415",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Maximum lateral viscosity variation": {
                "value": "1e2",
                "default_value": "1e2",
                "documentation": "The relative cutoff value for lateral viscosity variations caused by temperature deviations. The viscosity may vary laterally by this factor squared.",
                "pattern": "397",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum thermal conductivity": {
                "value": "1000",
                "default_value": "1000",
                "documentation": "The maximum thermal conductivity that is allowed in the model. Larger values will be cut off.",
                "pattern": "408",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Maximum viscosity": {
                "value": "1e23",
                "default_value": "1e23",
                "documentation": "The maximum viscosity that is allowed in the viscosity calculation. Larger values will be cut off.",
                "pattern": "396",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum viscosity": {
                "value": "1e19",
                "default_value": "1e19",
                "documentation": "The minimum viscosity that is allowed in the viscosity calculation. Smaller values will be cut off.",
                "pattern": "395",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Number lateral average bands": {
                "value": "10",
                "default_value": "10",
                "documentation": "Number of bands to compute laterally averaged temperature within.",
                "pattern": "394",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Pressure dependencies of thermal conductivity": {
                "value": "3.3e-10, 3.4e-10, 3.6e-10, 1.05e-10",
                "default_value": "3.3e-10, 3.4e-10, 3.6e-10, 1.05e-10",
                "documentation": "A list of values that determine the linear scaling of the thermal conductivity with the pressure in the 'p-T-dependent' Thermal conductivity formulation. Units: \\si{\\watt\\per\\meter\\per\\kelvin\\per\\pascal}.",
                "pattern": "404",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Radial viscosity file name": {
                "value": "radial-visc.txt",
                "default_value": "radial-visc.txt",
                "documentation": "The file name of the radial viscosity data. ",
                "pattern": "391",
                "pattern_description": "[Anything]"
            },
            "Reference temperatures for thermal conductivity": {
                "value": "300, 300, 300, 1200",
                "default_value": "300, 300, 300, 1200",
                "documentation": "A list of values of reference temperatures used to determine the temperature-dependence of the thermal conductivity in the 'p-T-dependent' Thermal conductivity formulation. Units: \\si{\\kelvin}.",
                "pattern": "405",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Reference thermal conductivities": {
                "value": "2.47, 3.81, 3.52, 4.9",
                "default_value": "2.47, 3.81, 3.52, 4.9",
                "documentation": "A list of base values of the thermal conductivity for each of the horizontal layers in the 'p-T-dependent' Thermal conductivity formulation. Pressure- and temperature-dependence will be appliedon top of this base value, according to the parameters 'Pressure dependencies of thermal conductivity' and 'Reference temperatures for thermal conductivity'. Units: \\si{\\watt\\per\\meter\\per\\kelvin}",
                "pattern": "403",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Saturation prefactors": {
                "value": "0, 0, 0, 1",
                "default_value": "0, 0, 0, 1",
                "documentation": "A list of values that indicate how a given layer in the conductivity formulation should take into account the effects of saturation on the temperature-dependence of the thermal conducitivity. This factor is multiplied with a saturation function based on the theory of Roufosse and Klemens, 1974. A value of 1 reproduces the formulation of Stackhouse et al. (2015), a value of 0 reproduces the formulation of Tosi et al., (2013). Units: none.",
                "pattern": "407",
                "pattern_description": "[List of <[Double 0...1 (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal conductivity": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "The value of the thermal conductivity $k$. Only used in case the 'constant' Thermal conductivity formulation is selected. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "400",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivity exponents": {
                "value": "0.48, 0.56, 0.61, 1.0",
                "default_value": "0.48, 0.56, 0.61, 1.0",
                "documentation": "A list of exponents in the temperature-dependent term of the 'p-T-dependent' Thermal conductivity formulation. Note that this exponent is not used (and should have a value of 1) in the formulation of Stackhouse et al. (2015). Units: none.",
                "pattern": "406",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal conductivity formulation": {
                "value": "constant",
                "default_value": "constant",
                "documentation": "Which law should be used to compute the thermal conductivity. The 'constant' law uses a constant value for the thermal conductivity. The 'p-T-dependent' formulation uses equations from Stackhouse et al. (2015): First-principles calculations of the lattice thermal conductivity of the lower mantle (https:\/\/doi.org\/10.1016\/j.epsl.2015.06.050), and Tosi et al. (2013): Mantle dynamics with pressure- and temperature-dependent thermal expansivity and conductivity (https:\/\/doi.org\/10.1016\/j.pepi.2013.02.004) to compute the thermal conductivity in dependence of temperature and pressure. The thermal conductivity parameter sets can be chosen in such a way that either the Stackhouse or the Tosi relations are used. The conductivity description can consist of several layers with different sets of parameters. Note that the Stackhouse parametrization is only valid for the lower mantle (bridgmanite).",
                "pattern": "401",
                "pattern_description": "[Selection constant|p-T-dependent ]"
            },
            "Thermal conductivity transition depths": {
                "value": "410000, 520000, 660000",
                "default_value": "410000, 520000, 660000",
                "documentation": "A list of depth values that indicate where the transitions between the different conductivity parameter sets should occur in the 'p-T-dependent' Thermal conductivity formulation (in most cases, this will be the depths of major mantle phase transitions). Units: \\si{\\meter}.",
                "pattern": "402",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Use lateral average temperature for viscosity": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to use the laterally averaged temperature instead of the adiabatic temperature as reference for the viscosity calculation. This ensures that the laterally averaged viscosities remain more or less constant over the model runtime. This behavior might or might not be desired.",
                "pattern": "393",
                "pattern_description": "[Bool]"
            },
            "Viscosity averaging scheme": {
                "value": "harmonic",
                "default_value": "harmonic",
                "documentation": "Method to average viscosities over multiple compositional fields. One of arithmetic, harmonic, geometric or maximum composition.",
                "pattern": "399",
                "pattern_description": "[Selection arithmetic|harmonic|geometric|maximum composition ]"
            }
        },
        "Visco Plastic": {
            "Activation energies for Peierls creep": {
                "value": "320e3",
                "default_value": "320e3",
                "documentation": "List of activation energies, $E$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\joule\\per\\mole}.",
                "pattern": "479",
                "pattern_description": "[Anything]"
            },
            "Activation energies for diffusion creep": {
                "value": "375e3",
                "default_value": "375e3",
                "documentation": "List of activation energies, $E_a$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\joule\\per\\mole}.",
                "pattern": "465",
                "pattern_description": "[Anything]"
            },
            "Activation energies for dislocation creep": {
                "value": "530e3",
                "default_value": "530e3",
                "documentation": "List of activation energies, $E_a$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\joule\\per\\mole}.",
                "pattern": "470",
                "pattern_description": "[Anything]"
            },
            "Activation volumes for Peierls creep": {
                "value": "1.4e-5",
                "default_value": "1.4e-5",
                "documentation": "List of activation volumes, $V$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\meter\\cubed\\per\\mole}.",
                "pattern": "480",
                "pattern_description": "[Anything]"
            },
            "Activation volumes for diffusion creep": {
                "value": "6e-6",
                "default_value": "6e-6",
                "documentation": "List of activation volumes, $V_a$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\meter\\cubed\\per\\mole}.",
                "pattern": "466",
                "pattern_description": "[Anything]"
            },
            "Activation volumes for dislocation creep": {
                "value": "1.4e-5",
                "default_value": "1.4e-5",
                "documentation": "List of activation volumes, $V_a$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\meter\\cubed\\per\\mole}.",
                "pattern": "471",
                "pattern_description": "[Anything]"
            },
            "Adiabat temperature gradient for viscosity": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "Add an adiabatic temperature gradient to the temperature used in the flow law so that the activation volume is consistent with what one would use in a earth-like (compressible) model. Default is set so this is off. Note that this is a linear approximation of the real adiabatic gradient, which is okay for the upper mantle, but is not really accurate for the lower mantle. Using a pressure gradient of 32436 Pa\/m, then a value of 0.3 K\/km = 0.0003 K\/m = 9.24e-09 K\/Pa gives an earth-like adiabat.Units: \\si{\\kelvin\\per\\pascal}.",
                "pattern": "495",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Allow negative pressures in plasticity": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to allow negative pressures to be used in the computation of plastic yield stresses and viscosities. Setting this parameter to true may be advantageous in models without gravity where the dynamic stresses are much higher than the lithostatic pressure. If false, the minimum pressure in the plasticity formulation will be set to zero.",
                "pattern": "460",
                "pattern_description": "[Bool]"
            },
            "Angles of internal friction": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "List of angles of internal friction, $\\phi$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. For a value of zero, in 2d the von Mises criterion is retrieved. Angles higher than 30 degrees are harder to solve numerically. Units: degrees.",
                "pattern": "489",
                "pattern_description": "[Anything]"
            },
            "Apply strict stress cutoff for Peierls creep": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether the cutoff stresses for Peierls creep are used as the minimum stresses in the Peierls rheology",
                "pattern": "486",
                "pattern_description": "[Bool]"
            },
            "Cohesion strain weakening factors": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "List of cohesion strain weakening factors for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "432",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Cohesions": {
                "value": "1e20",
                "default_value": "1e20",
                "documentation": "List of cohesions, $C$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. The extremely large default cohesion value (1e20 Pa) prevents the viscous stress from exceeding the yield stress. Units: \\si{\\pascal}.",
                "pattern": "490",
                "pattern_description": "[Anything]"
            },
            "Constant viscosity prefactors": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "List of constant viscosity prefactors (i.e., multiplicative factors) for background material and compositional fields, for a total of N+1 where N is the number of compositional fields. Units: none.",
                "pattern": "488",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Cutoff stresses for Peierls creep": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "List of the Stress thresholds below which the strain rate is solved for as a quadratic function of stress to aid with convergence when stress exponent n=0. Units: \\si{\\pascal}",
                "pattern": "485",
                "pattern_description": "[Anything]"
            },
            "Define thermal conductivities": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to directly define thermal conductivities for each compositional field instead of calculating the values through the specified thermal diffusivities, densities, and heat capacities. ",
                "pattern": "497",
                "pattern_description": "[Bool]"
            },
            "Define transition by depth instead of pressure": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to list phase transitions by depth or pressure. If this parameter is true, then the input file will use Phase transitions depths and Phase transition widths to define the phase transition. If it is false, the parameter file will read in phase transition data from Phase transition pressures and Phase transition pressure widths.",
                "pattern": "420",
                "pattern_description": "[Bool]"
            },
            "Densities": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "List of densities for background mantle and compositional fields,for a total of N+M+1 values, where N is the number of compositional fields and M is the number of phases. If only one value is given, then all use the same value. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "426",
                "pattern_description": "[Anything]"
            },
            "Dynamic angles of internal friction": {
                "value": "2",
                "default_value": "2",
                "documentation": "List of dynamic angles of internal friction, $\\phi$, for background material and compositional fields, for a total of N$+$1 values, where N is the number of compositional fields. Dynamic angles of friction are used as the current friction angle when the effective strain rate is well above the 'dynamic characteristic strain rate'. Units: \\si{\\degree}.",
                "pattern": "442",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Dynamic characteristic strain rate": {
                "value": "1e-12",
                "default_value": "1e-12",
                "documentation": "The characteristic strain rate value at which the angle of friction is equal to $\\mu = (\\mu_s+\\mu_d)\/2$. When the effective strain rate is very high, the dynamic angle of friction is taken, when it is very low, the static angle of internal friction is used. Around the dynamic characteristic strain rate, there is a smooth gradient from the static to the dynamic angle of internal friction. Units: \\si{\\per\\second}.",
                "pattern": "441",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Dynamic friction smoothness exponent": {
                "value": "1",
                "default_value": "1",
                "documentation": "An exponential factor in the equation for the calculation of the friction angle when a static and a dynamic angle of internal friction are specified. A factor of 1 returns the equation to Equation (13) in \\cite{van_dinther_seismic_2013}. A factor between 0 and 1 makes the curve of the friction angle vs. the strain rate smoother, while a factor $>$ 1 makes the change between static and dynamic friction angle more steplike. Units: none.",
                "pattern": "443",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Elastic damper viscosity": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "Viscosity of a viscous damper that acts in parallel with the elastic element to stabilize behavior. Units: \\si{\\pascal\\second}",
                "pattern": "452",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Elastic shear moduli": {
                "value": "75.0e9",
                "default_value": "75.0e9",
                "documentation": "List of elastic shear moduli, $G$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. The default value of 75 GPa is representative of mantle rocks. Units: Pa.",
                "pattern": "448",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "End plasticity strain weakening intervals": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "List of strain weakening interval final strains for the cohesion and friction angle parameters of the background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "431",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "End prefactor strain weakening intervals": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "List of strain weakening interval final strains for the diffusion and dislocation prefactor parameters of the background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "435",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Fixed elastic time step": {
                "value": "1.e3",
                "default_value": "1.e3",
                "documentation": "The fixed elastic time step $dte$. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "450",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Friction mechanism": {
                "value": "none",
                "default_value": "none",
                "documentation": "Whether to make the friction angle dependent on strain rate or not. This rheology is intended to be used together with the visco-plastic rheology model.\n\n\\item ``none'': No dependence of the friction angle is applied. \n\n\\item ``dynamic friction'': The friction angle is rate dependent.When 'dynamic angles of internal friction' are specified, the friction angle will be weakened for high strain rates with: $\\mu = \\mu_d + \\frac{\\mu_s-\\mu_d}{1+\\frac{\\dot{\\epsilon}_{ii}}{\\dot{\\epsilon}_C}}^x$  where $\\mu_s$ and $\\mu_d$ are the friction angles at low and high strain rates, respectively. $\\dot{\\epsilon}_{ii}$ is the second invariant of the strain rate and $\\dot{\\epsilon}_C$ is the 'dynamic characteristic strain rate' where $\\mu = (\\mu_s+\\mu_d)\/2$. The 'dynamic friction smoothness exponent' x controls how smooth or step-like the change from $\\mu_s$ to $\\mu_d$ is. The equation is modified after Equation (13) in \\cite{van_dinther_seismic_2013}. $\\mu_s$ and $\\mu_d$ can be specified by setting 'Angles of internal friction' and 'Dynamic angles of internal friction', respectively. This relationship is similar to rate-and-state friction constitutive relationships, which are applicable to the strength of rocks during earthquakes.\n\n\\item ``function'': Specify the friction angle as a function of space and time for each compositional field.",
                "pattern": "440",
                "pattern_description": "[Selection none|dynamic friction|function ]"
            },
            "Friction strain weakening factors": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "List of friction strain weakening factors for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "433",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Grain size": {
                "value": "1e-3",
                "default_value": "1e-3",
                "documentation": "Units: \\si{\\meter}.",
                "pattern": "467",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Grain size exponents for diffusion creep": {
                "value": "3.",
                "default_value": "3.",
                "documentation": "List of grain size exponents, $m_{\\text{diffusion}}$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: None.",
                "pattern": "464",
                "pattern_description": "[Anything]"
            },
            "Heat capacities": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "List of specific heats $C_p$ for background mantle and compositional fields,for a total of N+M+1 values, where N is the number of compositional fields and M is the number of phases. If only one value is given, then all use the same value. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "428",
                "pattern_description": "[Anything]"
            },
            "Include Peierls creep": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to include Peierls creep in the rheological formulation.",
                "pattern": "487",
                "pattern_description": "[Bool]"
            },
            "Maximum Peierls strain rate iterations": {
                "value": "40",
                "default_value": "40",
                "documentation": "Maximum number of iterations to find the correct Peierls strain rate.",
                "pattern": "476",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Maximum viscosity": {
                "value": "1e28",
                "default_value": "1e28",
                "documentation": "Upper cutoff for effective viscosity. Units: \\si{\\pascal\\second}. List with as many components as active compositional fields (material data is assumed to be in order with the ordering of the fields). ",
                "pattern": "456",
                "pattern_description": "[Anything]"
            },
            "Maximum yield stress": {
                "value": "1e12",
                "default_value": "1e12",
                "documentation": "Limits the maximum value of the yield stress determined by the Drucker-Prager plasticity parameters. Default value is chosen so this is not automatically used. Values of 100e6--1000e6 $Pa$ have been used in previous models. Units: \\si{\\pascal}.",
                "pattern": "491",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum strain rate": {
                "value": "1.0e-20",
                "default_value": "1.0e-20",
                "documentation": "Stabilizes strain dependent viscosity. Units: \\si{\\per\\second}.",
                "pattern": "453",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum viscosity": {
                "value": "1e17",
                "default_value": "1e17",
                "documentation": "Lower cutoff for effective viscosity. Units: \\si{\\pascal\\second}. List with as many components as active compositional fields (material data is assumed to be in order with the ordering of the fields). ",
                "pattern": "455",
                "pattern_description": "[Anything]"
            },
            "Peierls creep flow law": {
                "value": "viscosity approximation",
                "default_value": "viscosity approximation",
                "documentation": "Select what type of Peierls creep flow law to use. Currently, the available options are 'exact', which uses a Newton-Raphson iterative method to find the stress and then compute viscosity, and 'viscosity approximation', in which viscosity is an explicit function of the strain rate invariant, rather than stress. ",
                "pattern": "474",
                "pattern_description": "[Selection viscosity approximation|exact ]"
            },
            "Peierls fitting parameters": {
                "value": "0.17",
                "default_value": "0.17",
                "documentation": "List of fitting parameters $\\gamma$ between stress $\\sigma$ and the Peierls stress $\\sigma_{\\text{peierls}}$ for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: none",
                "pattern": "482",
                "pattern_description": "[Anything]"
            },
            "Peierls glide parameters p": {
                "value": "0.5",
                "default_value": "0.5",
                "documentation": "List of the first Peierls creep glide parameters, $p$, for background and compositional fields for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: none",
                "pattern": "483",
                "pattern_description": "[Anything]"
            },
            "Peierls glide parameters q": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "List of the second Peierls creep glide parameters, $q$, for background and compositional fields for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: none",
                "pattern": "484",
                "pattern_description": "[Anything]"
            },
            "Peierls strain rate residual tolerance": {
                "value": "1e-22",
                "default_value": "1e-22",
                "documentation": "Tolerance for the iterative solve to find the correct Peierls creep strain rate.",
                "pattern": "475",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Peierls stresses": {
                "value": "5.e9",
                "default_value": "5.e9",
                "documentation": "List of stress limits for Peierls creep $\\sigma_{\\text{peierls}}$ for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\pascal}",
                "pattern": "481",
                "pattern_description": "[Anything]"
            },
            "Phase transition Clapeyron slopes": {
                "value": "",
                "default_value": "",
                "documentation": "A list of Clapeyron slopes for each phase transition. A positive Clapeyron slope indicates that the phase transition will occur in a greater depth, if the temperature is higher than the one given in Phase transition temperatures and in a smaller depth, if the temperature is smaller than the one given in Phase transition temperatures. For negative slopes the other way round. List must have the same number of entries as Phase transition depths. Units: \\si{\\pascal\\per\\kelvin}.",
                "pattern": "424",
                "pattern_description": "[Anything]"
            },
            "Phase transition depths": {
                "value": "",
                "default_value": "",
                "documentation": "A list of depths where phase transitions occur. Values must monotonically increase. Units: \\si{\\meter}.",
                "pattern": "416",
                "pattern_description": "[Anything]"
            },
            "Phase transition pressure widths": {
                "value": "",
                "default_value": "",
                "documentation": "A list of widths for each phase transition, in terms of pressure. The phase functions are scaled with these values, leading to a jump between phases for a value of zero and a gradual transition for larger values. List must have the same number of entries as Phase transition pressures. Define transition by depth instead of pressure must be set to false to use this parameter. Units: \\si{\\pascal}.",
                "pattern": "419",
                "pattern_description": "[Anything]"
            },
            "Phase transition pressures": {
                "value": "",
                "default_value": "",
                "documentation": "A list of pressures where phase transitions occur. Values must monotonically increase. Define transition by depth instead of pressure must be set to false to use this parameter. Units: \\si{\\pascal}.",
                "pattern": "418",
                "pattern_description": "[Anything]"
            },
            "Phase transition temperature lower limits": {
                "value": "-1.7976931348623157e+308",
                "default_value": "-1.7976931348623157e+308",
                "documentation": "A list of lower temperature limits for each phase transition. Below this temperature the respective phase transition is deactivated. The default value means there is no lower limit for any phase transition. List must have the same number of entries as Phase transition depths. When the optional temperature limits are applied, the user has to be careful about the consistency between adjacent phases. Phase transitions should be continuous in pressure-temperature space. We recommend producing a phase diagram with simple model setups to check the implementation as a starting point.Units: \\si{\\kelvin}.",
                "pattern": "423",
                "pattern_description": "[Anything]"
            },
            "Phase transition temperature upper limits": {
                "value": "1.7976931348623157e+308",
                "default_value": "1.7976931348623157e+308",
                "documentation": "A list of upper temperature limits for each phase transition. Above this temperature the respective phase transition is deactivated. The default value means there is no upper limit for any phase transitions. List must have the same number of entries as Phase transition depths. When the optional temperature limits are applied, the user has to be careful about the consistency between adjacent phases. Phase transitions should be continuous in pressure-temperature space. We recommend producing a phase diagram with simple model setups to check the implementation as a starting point.Units: \\si{\\kelvin}.",
                "pattern": "422",
                "pattern_description": "[Anything]"
            },
            "Phase transition temperatures": {
                "value": "",
                "default_value": "",
                "documentation": "A list of temperatures where phase transitions occur. Higher or lower temperatures lead to phase transition occurring in smaller or greater depths than given in Phase transition depths, depending on the Clapeyron slope given in Phase transition Clapeyron slopes. List must have the same number of entries as Phase transition depths. Units: \\si{\\kelvin}.",
                "pattern": "421",
                "pattern_description": "[Anything]"
            },
            "Phase transition widths": {
                "value": "",
                "default_value": "",
                "documentation": "A list of widths for each phase transition, in terms of depth. The phase functions are scaled with these values, leading to a jump between phases for a value of zero and a gradual transition for larger values. List must have the same number of entries as Phase transition depths. Units: \\si{\\meter}.",
                "pattern": "417",
                "pattern_description": "[Anything]"
            },
            "Plastic damper viscosity": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "Viscosity of the damper that acts in parallel with the plastic viscosity to produce mesh-independent behavior at sufficient resolutions. Units: \\si{\\pascal\\second}",
                "pattern": "493",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Prefactor strain weakening factors": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "List of viscous strain weakening factors for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "436",
                "pattern_description": "[List of <[Double 0...1 (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Prefactors for Frank Kamenetskii": {
                "value": "1.e21",
                "default_value": "1.e21",
                "documentation": "A viscosity prefactor for the viscosity approximation, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None",
                "pattern": "473",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Prefactors for Peierls creep": {
                "value": "1.4e-19",
                "default_value": "1.4e-19",
                "documentation": "List of viscosity prefactors, $A$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\pascal}$^{-n_{\\text{peierls}}}$ \\si{\\per\\second}",
                "pattern": "477",
                "pattern_description": "[Anything]"
            },
            "Prefactors for diffusion creep": {
                "value": "1.5e-15",
                "default_value": "1.5e-15",
                "documentation": "List of viscosity prefactors, $A$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\per\\pascal\\meter}$^{m_{\\text{diffusion}}}$\\si{\\per\\second}.",
                "pattern": "462",
                "pattern_description": "[Anything]"
            },
            "Prefactors for dislocation creep": {
                "value": "1.1e-16",
                "default_value": "1.1e-16",
                "documentation": "List of viscosity prefactors, $A$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\pascal}$^{-n_{\\text{dislocation}}}$ \\si{\\per\\second}.",
                "pattern": "468",
                "pattern_description": "[Anything]"
            },
            "Reference strain rate": {
                "value": "1.0e-15",
                "default_value": "1.0e-15",
                "documentation": "Reference strain rate for first time step. Units: \\si{\\per\\second}.",
                "pattern": "454",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. Units: \\si{\\kelvin}.",
                "pattern": "425",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Specific heats": {
                "alias": "Heat capacities",
                "deprecation_status": "false"
            },
            "Stabilization time scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "A stabilization factor for the elastic stresses that influences how fast elastic stresses adjust to deformation. 1.0 is equivalent to no stabilization and may lead to oscillatory motion. Setting the factor to 2 avoids oscillations, but still enables an immediate elastic response. However, in complex models this can lead to problems of convergence, in which case the factor needs to be increased slightly. Setting the factor to infinity is equivalent to not applying elastic stresses at all. The factor is multiplied with the computational time step to create a time scale. ",
                "pattern": "451",
                "pattern_description": "[Double 1...MAX_DOUBLE (inclusive)]"
            },
            "Start plasticity strain weakening intervals": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "List of strain weakening interval initial strains for the cohesion and friction angle parameters of the background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: None.",
                "pattern": "430",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Start prefactor strain weakening intervals": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "List of strain weakening interval initial strains for the diffusion and dislocation prefactor parameters of the background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "434",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Strain healing mechanism": {
                "value": "no healing",
                "default_value": "no healing",
                "documentation": "Whether to apply strain healing to plastic yielding and viscosity terms, and if yes, which method to use. The following methods are available:\n\n\\item ``no healing'': No strain healing is applied. \n\n\\item ``temperature dependent'': Purely temperature dependent strain healing applied to plastic yielding and viscosity terms, similar to the temperature-dependent Frank Kamenetskii formulation, computes strain healing as removing strain as a function of temperature, time, and a user-defined healing rate and prefactor as done in Fuchs and Becker, 2019, for mantle convection",
                "pattern": "437",
                "pattern_description": "[Selection no healing|temperature dependent ]"
            },
            "Strain healing temperature dependent prefactor": {
                "value": "15.",
                "default_value": "15.",
                "documentation": "Prefactor for temperature dependent strain healing. Units: None",
                "pattern": "439",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Strain healing temperature dependent recovery rate": {
                "value": "1.e-15",
                "default_value": "1.e-15",
                "documentation": "Recovery rate prefactor for temperature dependent strain healing. Units: $1\/s$",
                "pattern": "438",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Strain weakening mechanism": {
                "value": "default",
                "default_value": "default",
                "documentation": "Whether to apply strain weakening to viscosity, cohesion and internal angleof friction based on accumulated finite strain, and if yes, which method to use. The following methods are available:\n\n\\item ``none'': No strain weakening is applied. \n\n\\item ``finite strain tensor'': The full finite strain tensor is tracked, and its second invariant is used to weaken both the plastic yield stress (specifically, the cohesion and friction angle) and the pre-yield viscosity that arises from diffusion and\/or dislocation creep.\n\n\\item ``total strain'': The finite strain is approximated as the product of the second invariant of the strain rate in each time step and the time step size, and this quantity is integrated and tracked over time. It is used to weaken both the plastic yield stress (specifically, the cohesion and friction angle) and the pre-yield viscosity.\n\n\\item ``plastic weakening with plastic strain only'': The finite strain is approximated as the product of the second invariant of the strain ratein each time step and the time step size in regions where material is plastically yielding. This quantity is integrated and tracked over time, and used to weaken the cohesion and friction angle. The pre-yield viscosity is not weakened.\n\n\\item ``plastic weakening with total strain only'': The finite strain is approximated as the product of the second invariant of the strain rate in each time step and the time step size, and this quantity is integrated and tracked over time. It is used to weaken the plastic yield stress (specifically, the cohesion and internal friction angle). The pre-yield viscosity is not weakened.\n\n\\item ``plastic weakening with plastic strain and viscous weakening with viscous strain'': Both the finite strain accumulated by plastic deformation and by viscous deformation are computed separately (each approximated as the product of the second invariant of the corresponding strain rate in each time step and the time step size). The plastic strain is used to weaken the plastic yield stress (specifically, the cohesion and yield angle), and the viscous strain is used to weaken the pre-yield viscosity.\n\n\\item ``viscous weakening with viscous strain only'': The finite strain is approximated as the product of the second invariant of the strain rate in each time step and the time step size in regions where material is not plastically yielding. This quantity is integrated and tracked over time, and used to weaken the pre-yield viscosity. The cohesion and friction angle are not weakened.\n\n\\item ``default'': The default option has the same behavior as ``none'', but is there to make sure that the original parameters for specifying the strain weakening mechanism (``Use plastic\/viscous strain weakening'') are still allowed, but to guarantee that one uses either the old parameter names or the new ones, never both.\n\nIf a compositional field named 'noninitial\\_plastic\\_strain' is included in the parameter file, this field will automatically be excluded from from volume fraction calculation and track the cumulative plastic strain with the initial plastic strain values removed.",
                "pattern": "429",
                "pattern_description": "[Selection none|finite strain tensor|total strain|plastic weakening with plastic strain only|plastic weakening with total strain only|plastic weakening with plastic strain and viscous weakening with viscous strain|viscous weakening with viscous strain only|default ]"
            },
            "Stress exponents for Peierls creep": {
                "value": "2.0",
                "default_value": "2.0",
                "documentation": "List of stress exponents, $n_{\\text{peierls}}$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "478",
                "pattern_description": "[Anything]"
            },
            "Stress exponents for diffusion creep": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "List of stress exponents, $n_{\\text{diffusion}}$, for background mantle and compositional fields, for a total of N+1 values, where N is the number of compositional fields. The stress exponent for diffusion creep is almost always equal to one. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "463",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Stress exponents for dislocation creep": {
                "value": "3.5",
                "default_value": "3.5",
                "documentation": "List of stress exponents, $n_{\\text{dislocation}}$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: None.",
                "pattern": "469",
                "pattern_description": "[Anything]"
            },
            "Stress limiter exponents": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "List of stress limiter exponents, $n_{\\text{lim}}$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. Units: none.",
                "pattern": "494",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal conductivities": {
                "value": "3.0",
                "default_value": "3.0",
                "documentation": "List of thermal conductivities, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "498",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal diffusivities": {
                "value": "0.8e-6",
                "default_value": "0.8e-6",
                "documentation": "List of thermal diffusivities, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value.  Units: \\si{\\meter\\squared\\per\\second}.",
                "pattern": "496",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal expansivities": {
                "value": "0.000035",
                "default_value": "0.000035",
                "documentation": "List of thermal expansivities for background mantle and compositional fields,for a total of N+M+1 values, where N is the number of compositional fields and M is the number of phases. If only one value is given, then all use the same value. Units: \\si{\\per\\kelvin}.",
                "pattern": "427",
                "pattern_description": "[Anything]"
            },
            "Use adiabatic pressure in creep viscosity": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to use the adiabatic pressure instead of the full pressure (default) when calculating creep (diffusion, dislocation, and peierls) viscosity. This may be helpful in models where the full pressure has an unusually large negative value arising from large negative dynamic pressure, resulting in solver convergence issue and in some cases a viscosity of zero.",
                "pattern": "461",
                "pattern_description": "[Bool]"
            },
            "Use fixed elastic time step": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Select whether the material time scale in the viscoelastic constitutive relationship uses the regular numerical time step or a separate fixed elastic time step throughout the model run. The fixed elastic time step is always used during the initial time step. If a fixed elastic time step is used throughout the model run, a stress averaging scheme is applied to account for differences with the numerical time step. An alternative approach is to limit the maximum time step size so that it is equal to the elastic time step. The default value of this parameter is 'unspecified', which throws an exception during runtime. In order for the model to run the user must select 'true' or 'false'.",
                "pattern": "449",
                "pattern_description": "[Selection true|false|unspecified ]"
            },
            "Use plastic damper": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to use a plastic damper when computing the Drucker-Prager plastic viscosity. The damper acts to stabilize the plastic shear band width and remove associated mesh-dependent behavior at sufficient resolutions.",
                "pattern": "492",
                "pattern_description": "[Bool]"
            },
            "Viscosity averaging scheme": {
                "value": "harmonic",
                "default_value": "harmonic",
                "documentation": "When more than one compositional field is present at a point with different viscosities, we need to come up with an average viscosity at that point.  Select a weighted harmonic, arithmetic, geometric, or maximum composition.",
                "pattern": "457",
                "pattern_description": "[Selection arithmetic|harmonic|geometric|maximum composition ]"
            },
            "Viscosity ratios for Frank Kamenetskii": {
                "value": "15.",
                "default_value": "15.",
                "documentation": "An adjusted viscosity ratio, $E$, for the viscosity approximation, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: None",
                "pattern": "472",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Viscous flow law": {
                "value": "composite",
                "default_value": "composite",
                "documentation": "Select what type of viscosity law to use between diffusion, dislocation, frank kamenetskii, and composite options. Soon there will be an option to select a specific flow law for each assigned composition ",
                "pattern": "458",
                "pattern_description": "[Selection diffusion|dislocation|frank kamenetskii|composite ]"
            },
            "Yield mechanism": {
                "value": "drucker",
                "default_value": "drucker",
                "documentation": "Select what type of yield mechanism to use between Drucker Prager and stress limiter options.",
                "pattern": "459",
                "pattern_description": "[Selection drucker|limiter ]"
            },
            "Friction function": {
                "Coordinate system": {
                    "value": "cartesian",
                    "default_value": "cartesian",
                    "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `cartesian', `spherical', and `depth'. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle. `depth' will create a function, in which only the first parameter is non-zero, which is interpreted to be the depth of the point.",
                    "pattern": "444",
                    "pattern_description": "[Selection cartesian|spherical|depth ]"
                },
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "447",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "0",
                    "default_value": "0",
                    "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                    "pattern": "446",
                    "pattern_description": "[Anything]"
                },
                "Variable names": {
                    "value": "x,y,t",
                    "default_value": "x,y,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "445",
                    "pattern_description": "[Anything]"
                }
            }
        },
        "Viscoelastic": {
            "Densities": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "List of densities for background mantle and compositional fields,for a total of N+M+1 values, where N is the number of compositional fields and M is the number of phases. If only one value is given, then all use the same value. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "500",
                "pattern_description": "[Anything]"
            },
            "Elastic damper viscosity": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "Viscosity of a viscous damper that acts in parallel with the elastic element to stabilize behavior. Units: \\si{\\pascal\\second}",
                "pattern": "507",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Elastic shear moduli": {
                "value": "75.0e9",
                "default_value": "75.0e9",
                "documentation": "List of elastic shear moduli, $G$, for background material and compositional fields, for a total of N+1 values, where N is the number of compositional fields. The default value of 75 GPa is representative of mantle rocks. Units: Pa.",
                "pattern": "503",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Fixed elastic time step": {
                "value": "1.e3",
                "default_value": "1.e3",
                "documentation": "The fixed elastic time step $dte$. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "505",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Heat capacities": {
                "value": "1250.",
                "default_value": "1250.",
                "documentation": "List of specific heats $C_p$ for background mantle and compositional fields,for a total of N+M+1 values, where N is the number of compositional fields and M is the number of phases. If only one value is given, then all use the same value. Units: \\si{\\joule\\per\\kelvin\\per\\kilogram}.",
                "pattern": "502",
                "pattern_description": "[Anything]"
            },
            "Reference temperature": {
                "value": "293.",
                "default_value": "293.",
                "documentation": "The reference temperature $T_0$. Units: \\si{\\kelvin}.",
                "pattern": "499",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Specific heats": {
                "alias": "Heat capacities",
                "deprecation_status": "false"
            },
            "Stabilization time scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "A stabilization factor for the elastic stresses that influences how fast elastic stresses adjust to deformation. 1.0 is equivalent to no stabilization and may lead to oscillatory motion. Setting the factor to 2 avoids oscillations, but still enables an immediate elastic response. However, in complex models this can lead to problems of convergence, in which case the factor needs to be increased slightly. Setting the factor to infinity is equivalent to not applying elastic stresses at all. The factor is multiplied with the computational time step to create a time scale. ",
                "pattern": "506",
                "pattern_description": "[Double 1...MAX_DOUBLE (inclusive)]"
            },
            "Thermal conductivities": {
                "value": "4.7",
                "default_value": "4.7",
                "documentation": "List of thermal conductivities for background mantle and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\watt\\per\\meter\\per\\kelvin}.",
                "pattern": "509",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Thermal expansivities": {
                "value": "0.000035",
                "default_value": "0.000035",
                "documentation": "List of thermal expansivities for background mantle and compositional fields,for a total of N+M+1 values, where N is the number of compositional fields and M is the number of phases. If only one value is given, then all use the same value. Units: \\si{\\per\\kelvin}.",
                "pattern": "501",
                "pattern_description": "[Anything]"
            },
            "Use fixed elastic time step": {
                "value": "unspecified",
                "default_value": "unspecified",
                "documentation": "Select whether the material time scale in the viscoelastic constitutive relationship uses the regular numerical time step or a separate fixed elastic time step throughout the model run. The fixed elastic time step is always used during the initial time step. If a fixed elastic time step is used throughout the model run, a stress averaging scheme is applied to account for differences with the numerical time step. An alternative approach is to limit the maximum time step size so that it is equal to the elastic time step. The default value of this parameter is 'unspecified', which throws an exception during runtime. In order for the model to run the user must select 'true' or 'false'.",
                "pattern": "504",
                "pattern_description": "[Selection true|false|unspecified ]"
            },
            "Viscosities": {
                "value": "1.e21",
                "default_value": "1.e21",
                "documentation": "List of viscosities for background mantle and compositional fields, for a total of N+1 values, where N is the number of compositional fields. If only one value is given, then all use the same value. Units: \\si{\\pascal\\second}.",
                "pattern": "508",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Viscosity averaging scheme": {
                "value": "harmonic",
                "default_value": "harmonic",
                "documentation": "When more than one compositional field is present at a point with different viscosities, we need to come up with an average viscosity at that point.  Select a weighted harmonic, arithmetic, geometric, or maximum composition.",
                "pattern": "510",
                "pattern_description": "[Selection arithmetic|harmonic|geometric|maximum composition  ]"
            }
        }
    },
    "Melt settings": {
        "Average melt velocity": {
            "value": "true",
            "default_value": "true",
            "documentation": "Whether to cell-wise average the material properties that are used to compute the melt velocity or not. The melt velocity is computed as the sum of the solid velocity and the phase separation flux $ - K_D \/ \\phi (\\nabla p_f - \\rho_f \\mathbf g)$. If this parameter is set to true, $K_D$ and $\\phi$ will be averaged cell-wise in the computation of the phase separation flux. This is useful because in some models the melt velocity can have spikes close to the interface between regions of melt and no melt, as both $K_D$ and $\\phi$ go to zero for vanishing melt fraction. As the melt velocity is used for computing the time step size, and in models that use heat transport by melt or shear heating of melt, setting this parameter to true can speed up the model and make it mode stable. In computations where accuracy and convergence behavior of the melt velocity is important (like in benchmark cases with an analytical solution), this parameter should probably be set to 'false'.",
            "pattern": "102",
            "pattern_description": "[Bool]"
        },
        "Heat advection by melt": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether to use a porosity weighted average of the melt and solid velocity to advect heat in the temperature equation or not. If this is set to true, additional terms are assembled on the left-hand side of the temperature advection equation. Only used if Include melt transport is true. If this is set to false, only the solid velocity is used (as in models without melt migration).",
            "pattern": "100",
            "pattern_description": "[Bool]"
        },
        "Include melt transport": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether to include the transport of melt into the model or not. If this is set to true, two additional pressures (the fluid pressure and the compaction pressure) will be added to the finite element. Including melt transport in the simulation also requires that there is one compositional field that has the name `porosity'. This field will be used for computing the additional pressures and the melt velocity, and has a different advection equation than other compositional fields, as it is effectively advected with the melt velocity.",
            "pattern": "48",
            "pattern_description": "[Bool]"
        },
        "Melt scaling factor threshold": {
            "value": "1e-7",
            "default_value": "1e-7",
            "documentation": "The factor by how much the Darcy coefficient K\\_D in a cell can be smaller than the reference Darcy coefficient for this cell still to be considered a melt cell (for which the melt transport equations are solved). For smaller Darcy coefficients, the Stokes equations (without melt) are solved instead. Only used if ``Include melt transport'' is true. ",
            "pattern": "99",
            "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
        },
        "Use discontinuous compaction pressure": {
            "value": "true",
            "default_value": "true",
            "documentation": "Whether to use a discontinuous element for the compaction pressure or not. From our preliminary tests, continuous elements seem to work better in models where the porosity is > 0 everywhere in the domain, and discontinuous elements work better in models where in parts of the domain the porosity = 0.",
            "pattern": "101",
            "pattern_description": "[Bool]"
        }
    },
    "Mesh deformation": {
        "Additional tangential mesh velocity boundary indicators": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list of names denoting those boundaries where there the mesh is allowed to move tangential to the boundary. All tangential mesh movements along those boundaries that have tangential material velocity boundary conditions are allowed by default, this parameters allows to generate mesh movements along other boundaries that are open, or have prescribed material velocities or tractions.\n\nThe names of the boundaries listed here can either be numbers (in which case they correspond to the numerical boundary indicators assigned by the geometry object), or they can correspond to any of the symbolic names the geometry object may have provided for each part of the boundary. You may want to compare this with the documentation of the geometry model you use in your model.",
            "pattern": "117",
            "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
        },
        "Mesh deformation boundary indicators": {
            "value": "top: free surface",
            "default_value": "",
            "documentation": "A comma separated list of names denoting those boundaries where there the mesh is allowed to move according to the specified mesh deformation objects. \n\nThe names of the boundaries listed here can either be numbers (in which case they correspond to the numerical boundary indicators assigned by the geometry object), or they can correspond to any of the symbolic names the geometry object may have provided for each part of the boundary. You may want to compare this with the documentation of the geometry model you use in your model. \n\nThe format is id1: object1 \\& object2, id2: object3 \\& object2, where objects are one of `ascii data': Implementation of a model in which the initial mesh deformation (initial topography) is derived from a file containing data in ascii format. The following geometry models are currently supported: box, chunk, spherical. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `Topography [m]' in a 2d model and  `x', `y', `Topography [m]' in a 3d model, which means that there has to be a single column containing the topography. Note that the data in the input file needs to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the assumed grid changes. `x' will be replaced by the azimuth angle in radians  and `y' by the polar angle in radians measured positive from the north pole. The grid will be assumed to be a longitude-colatitude grid. Note that the order of spherical coordinates is `phi', `theta' and not `theta', `phi', since this allows for dimension independent expressions.\n\n`boundary function': A plugin, which prescribes the surface mesh to deform according to an analytically prescribed function. Note that the function prescribes a deformation velocity, i.e. the return value of this plugin is later multiplied by the time step length to compute the displacement increment in this time step. Although the function's time variable is interpreted as years when Use years in output instead of seconds is set to true, the boundary deformation velocity should still be given in m\/s. The format of the functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`diffusion': A plugin that computes the deformation of surface vertices according to the solution of the hillslope diffusion problem. Specifically, at the end of each timestep, or after a specific number of timesteps, this plugin solves the following equation: \\begin{align*}  \\frac{\\partial h}{\\partial t} = \\kappa \\left( \\frac{\\partial^{2} h}{\\partial x^{2}} + \\frac{\\partial^{2} h}{\\partial y^{2}} \\right), \\end{align*} where $\\kappa$ is the hillslope diffusion coefficient (diffusivity), and $h(x,y)$ the height of a point along the top boundary with respect to the surface of the unperturbed domain. \n\nUsing this definition, the plugin then solves for one time step, i.e., using as initial condition $h(t_{n-1})$ the current surface elevation, and computing $h(t_n)$ from it by solving the equation above over the time interval $t_n-t_{n-1}$. From this, one can then compute a surface velocity $v = \\frac{h(t_n)-h(t_{n-1})}{t_n-t_{n-1}}$. \n\nThis surface velocity is used to deform the surface and as a boundary condition for solving the Laplace equation to determine the mesh velocity in the domain interior. Diffusion can be applied every timestep, mimicking surface processes of erosion and deposition, or at a user-defined timestep interval to purely smooth the surface topography to avoid too great a distortion of mesh elements when a free surface is also used.\n\n`free surface': A plugin that computes the deformation of surface vertices according to the solution of the flow problem. In particular this means if the surface of the domain is left open to flow, this flow will carry the mesh with it. The implementation was described in \\cite{rose_freesurface}, with the stabilization of the free surface originally described in \\cite{KMM2010}.",
            "pattern": "118",
            "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/geometry-model\/initial-topography-model\/ascii-data\/test\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/geometry-model\/initial-topography-model\/ascii-data\/test\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "124",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "box_3d_%s.0.txt",
                "default_value": "box_3d_%s.0.txt",
                "documentation": "The file name of the model data.",
                "pattern": "125",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "126",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Boundary function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "123",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0; 0",
                "default_value": "0; 0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "122",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "121",
                "pattern_description": "[Anything]"
            }
        },
        "Diffusion": {
            "Hillslope transport coefficient": {
                "value": "1e-6",
                "default_value": "1e-6",
                "documentation": "The hillslope transport coefficient $\\kappa$ used to diffuse the free surface, either as a  stabilization step or to mimic erosional and depositional processes. Units: $\\si{m^2\/s}$. ",
                "pattern": "127",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Time steps between diffusion": {
                "value": "1",
                "default_value": "1",
                "documentation": "The number of time steps between each application of diffusion.",
                "pattern": "128",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            }
        },
        "Free surface": {
            "Free surface stabilization theta": {
                "value": "0.5",
                "default_value": "0.5",
                "documentation": "Theta parameter described in \\cite{KMM2010}. An unstabilized free surface can overshoot its equilibrium position quite easily and generate unphysical results.  One solution is to use a quasi-implicit correction term to the forces near the free surface.  This parameter describes how much the free surface is stabilized with this term, where zero is no stabilization, and one is fully implicit.",
                "pattern": "119",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "Surface velocity projection": {
                "value": "normal",
                "default_value": "normal",
                "documentation": "After each time step the free surface must be advected in the direction of the velocity field. Mass conservation requires that the mesh velocity is in the normal direction of the surface. However, for steep topography or large curvature, advection in the normal direction can become ill-conditioned, and instabilities in the mesh can form. Projection of the mesh velocity onto the local vertical direction can preserve the mesh quality better, but at the cost of slightly poorer mass conservation of the domain.",
                "pattern": "120",
                "pattern_description": "[Selection normal|vertical ]"
            }
        }
    },
    "Mesh refinement": {
        "Adapt by fraction of cells": {
            "value": "false",
            "default_value": "false",
            "documentation": "Use fraction of the total number of cells instead of fraction of the total error as the limit for refinement and coarsening.",
            "pattern": "57",
            "pattern_description": "[Bool]"
        },
        "Additional refinement times": {
            "value": "",
            "default_value": "",
            "documentation": "A list of times so that if the end time of a time step is beyond this time, an additional round of mesh refinement is triggered. This is mostly useful to make sure we can get through the initial transient phase of a simulation on a relatively coarse mesh, and then refine again when we are in a time range that we are interested in and where we would like to use a finer mesh. Units: Each element of the list has units years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
            "pattern": "59",
            "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
        },
        "Coarsening fraction": {
            "value": "0.05",
            "default_value": "0.05",
            "documentation": "Cells are sorted from largest to smallest by their total error (determined by the Strategy). Then the cells with the smallest error (bottom of this sorted list) that account for the given fraction of the error are coarsened.",
            "pattern": "56",
            "pattern_description": "[Double 0...1 (inclusive)]"
        },
        "Initial adaptive refinement": {
            "value": "0",
            "default_value": "0",
            "documentation": "The number of adaptive refinement steps performed after initial global refinement but while still within the first time step. These refinement steps (n) are added to the value for initial global refinement (m) so that the final mesh has cells that are at most on refinement level $n+m$.",
            "pattern": "53",
            "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
        },
        "Initial global refinement": {
            "value": "5",
            "default_value": "2",
            "documentation": "The number of global refinement steps performed on the initial coarse mesh, before the problem is first solved there.\n\nNote that it is possible to supply conflicting refinement and coarsening settings, such as an 'Initial global refinement' of 4 and a 'Maximum refinement function' strategy that limits the refinement locally to 2. In this case, the tagging strategies such as the 'Maximum refinement function' will remove refinement flags in each initial global refinement step, such that the resulting mesh is not necessarily uniform or of the level given by the 'Initial global refinement' parameter.",
            "pattern": "52",
            "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
        },
        "Minimum refinement level": {
            "value": "0",
            "default_value": "0",
            "documentation": "The minimum refinement level each cell should have, and that can not be exceeded by coarsening. Should not be higher than the 'Initial global refinement' parameter.",
            "pattern": "58",
            "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
        },
        "Normalize individual refinement criteria": {
            "value": "true",
            "default_value": "true",
            "documentation": "If multiple refinement criteria are specified in the ``Strategy'' parameter, then they need to be combined somehow to form the final refinement indicators. This is done using the method described by the ``Refinement criteria merge operation'' parameter which can either operate on the raw refinement indicators returned by each strategy (i.e., dimensional quantities) or using normalized values where the indicators of each strategy are first normalized to the interval $[0,1]$ (which also makes them non-dimensional). This parameter determines whether this normalization will happen.",
            "pattern": "332",
            "pattern_description": "[Bool]"
        },
        "Refinement criteria merge operation": {
            "value": "max",
            "default_value": "max",
            "documentation": "If multiple mesh refinement criteria are computed for each cell (by passing a list of more than element to the \\texttt{Strategy} parameter in this section of the input file) then one will have to decide which criteria should win when deciding which cells to refine. The operation that determines how to combine these competing criteria is the one that is selected here. The options are:\n\n\\begin{itemize}\n\\item \\texttt{plus}: Add the various error indicators together and refine those cells on which the sum of indicators is largest.\n\\item \\texttt{max}: Take the maximum of the various error indicators and refine those cells on which the maximal indicators is largest.\n\\end{itemize}The refinement indicators computed by each strategy are modified by the ``Normalize individual refinement criteria'' and ``Refinement criteria scale factors'' parameters.",
            "pattern": "334",
            "pattern_description": "[Selection plus|max ]"
        },
        "Refinement criteria scaling factors": {
            "value": "",
            "default_value": "",
            "documentation": "A list of scaling factors by which every individual refinement criterion will be multiplied by. If only a single refinement criterion is selected (using the ``Strategy'' parameter, then this parameter has no particular meaning. On the other hand, if multiple criteria are chosen, then these factors are used to weigh the various indicators relative to each other. \n\nIf ``Normalize individual refinement criteria'' is set to true, then the criteria will first be normalized to the interval $[0,1]$ and then multiplied by the factors specified here. You will likely want to choose the factors to be not too far from 1 in that case, say between 1 and 10, to avoid essentially disabling those criteria with small weights. On the other hand, if the criteria are not normalized to $[0,1]$ using the parameter mentioned above, then the factors you specify here need to take into account the relative numerical size of refinement indicators (which in that case carry physical units).\n\nYou can experimentally play with these scaling factors by choosing to output the refinement indicators into the graphical output of a run.\n\nIf the list of indicators given in this parameter is empty, then this indicates that they should all be chosen equal to one. If the list is not empty then it needs to have as many entries as there are indicators chosen in the ``Strategy'' parameter.",
            "pattern": "333",
            "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
        },
        "Refinement fraction": {
            "value": "0.3",
            "default_value": "0.3",
            "documentation": "Cells are sorted from largest to smallest by their total error (determined by the Strategy). Then the cells with the largest error (top of this sorted list) that account for given fraction of the error are refined.",
            "pattern": "55",
            "pattern_description": "[Double 0...1 (inclusive)]"
        },
        "Run postprocessors on initial refinement": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether or not the postprocessors should be executed after each of the initial adaptive refinement cycles that are run at the start of the simulation. This is useful for plotting\/analyzing how the mesh refinement parameters are working for a particular model.",
            "pattern": "60",
            "pattern_description": "[Bool]"
        },
        "Skip setup initial conditions on initial refinement": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether or not the initial conditions should be set up during the adaptive refinement cycles that are run at the start of the simulation.",
            "pattern": "62",
            "pattern_description": "[Bool]"
        },
        "Skip solvers on initial refinement": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether or not solvers should be executed during the initial adaptive refinement cycles that are run at the start of the simulation.",
            "pattern": "61",
            "pattern_description": "[Bool]"
        },
        "Strategy": {
            "value": "temperature",
            "default_value": "thermal energy density",
            "documentation": "A comma separated list of mesh refinement criteria that will be run whenever mesh refinement is required. The results of each of these criteria, i.e., the refinement indicators they produce for all the cells of the mesh will then be normalized to a range between zero and one and the results of different criteria will then be merged through the operation selected in this section.\n\nThe following criteria are available:\n\n`artificial viscosity': A mesh refinement criterion that computes refinement indicators from the artificial viscosity of the temperature or compositional fields based on user specified weights.\n\n`boundary': A class that implements a mesh refinement criterion which always flags all cells on specified boundaries for refinement. This is useful to provide high accuracy for processes at or close to the edge of the model domain.\n\nTo use this refinement criterion, you may want to combine it with other refinement criteria, setting the 'Normalize individual refinement criteria' flag and using the `max' setting for 'Refinement criteria merge operation'.\n\n`compaction length': A mesh refinement criterion for models with melt transport that computes refinement indicators based on the compaction length, defined as $\\delta = \\sqrt{\\frac{(\\xi + 4 \\eta\/3) k}{\\eta_f}}$. $\\xi$ is the bulk viscosity, $\\eta$ is the shear viscosity, $k$ is the permeability and $\\eta_f$ is the melt viscosity. If the cell width or height exceeds a multiple (which is specified as an input parameter) of this compaction length, the cell is marked for refinement.\n\n`composition': A mesh refinement criterion that computes refinement indicators from the compositional fields. If there is more than one compositional field, then it simply takes the sum of the indicators computed from each of the compositional field.\n\nThe way these indicators are computed is by evaluating the `Kelly error indicator' on each compositional field. This error indicator takes the finite element approximation of the compositional field and uses it to compute an approximation of the second derivatives of the composition for each cell. This approximation is then multiplied by an appropriate power of the cell's diameter to yield an indicator for how large the error is likely going to be on this cell. This construction rests on the observation that for many partial differential equations, the error on each cell is proportional to some power of the cell's diameter times the second derivatives of the solution on that cell.\n\nFor complex equations such as those we solve here, this observation may not be strictly true in the mathematical sense, but it often yields meshes that are surprisingly good.\n\n`composition approximate gradient': A mesh refinement criterion that computes refinement indicators from the gradients of compositional fields. If there is more than one compositional field, then it simply takes the sum of the indicators times a user-specified weight for each field.\n\nIn contrast to the `composition gradient' refinement criterion, the current criterion does not compute the gradient at quadrature points on each cell, but by a finite difference approximation between the centers of cells. Consequently, it also works if the compositional fields are computed using discontinuous finite elements.\n\n`composition gradient': A mesh refinement criterion that computes refinement indicators from the gradients of compositional fields. If there is more than one compositional field, then it simply takes the sum of the indicators times a user-specified weight for each field.\n\nThis refinement criterion computes the gradient of the compositional field at quadrature points on each cell, and then averages them in some way to obtain a refinement indicator for each cell. This will give a reasonable approximation of the true gradient of the compositional field if you are using a continuous finite element.\n\nOn the other hand, for discontinuous finite elements (see the `Use discontinuous composition discretization' parameter in the `Discretization' section), the gradient at quadrature points does not include the contribution of jumps in the compositional field between cells, and consequently will not be an accurate approximation of the true gradient. As an extreme example, consider the case of using piecewise constant finite elements for compositional fields; in that case, the gradient of the solution at quadrature points inside each cell will always be exactly zero, even if the finite element solution is different from each cell to the next. Consequently, the current refinement criterion will likely not be useful in this situation. That said, the `composition approximate gradient' refinement criterion exists for exactly this purpose.\n\n`composition threshold': A mesh refinement criterion that computes refinement indicators from the compositional fields. If any field exceeds the threshold given in the input file, the cell is marked for refinement.\n\n`density': A mesh refinement criterion that computes refinement indicators from a field that describes the spatial variability of the density, $\\rho$. Because this quantity may not be a continuous function ($\\rho$ and $C_p$ may be discontinuous functions along discontinuities in the medium, for example due to phase changes), we approximate the gradient of this quantity to refine the mesh. The error indicator defined here takes the magnitude of the approximate gradient and scales it by $h_K^{1+d\/2}$ where $h_K$ is the diameter of each cell and $d$ is the dimension. This scaling ensures that the error indicators converge to zero as $h_K\\rightarrow 0$ even if the energy density is discontinuous, since the gradient of a discontinuous function grows like $1\/h_K$.\n\n`isosurfaces': A mesh refinement criterion that computes coarsening and refinement indicators between two isosurfaces of specific field entries (e.g. temperature, composition).\n\nThe way these indicators are derived between pairs of isosurfaces is by checking whether the solutions of specific fields are within the ranges of the isosurface values given. If these conditions hold, then coarsening and refinement indicators are set such that the mesh refinement levels lies within the range of levels given. Usage of this plugin allows the user to put a conditional minimum and maximum refinement function onto fields that they are interested in.\n\nFor now, only temperature and compositional fields are allowed as field entries. The key words could be 'Temperature' or one of the names of the compositional fields which are either specified by user or set up as C\\_0, C\\_1, etc.\n\nUsage: A list of isosurfaces separated by semi-colons (;). Each isosurface entry consists of multiple entries separated by a comma. The first two entries indicate the minimum and maximum refinement levels respectively. The entries after the first two describe the fields the isosurface applies to, followed by a colon (:), which again is followed by the minimum and maximum field values separated by a bar (|). An example for two isosurface entries is '0, 2, Temperature: 300 | 600; 2, 2, C\\_1: 0.5 | 1'. If both isoterm entries are triggered at the same location and the current refinement level is 1, it means that the first isoline will not set any flag and the second isoline will set a refinement flag. This means the cell will be refined. If both the coarsening and refinement flags are set, preference is given to refinement. \n\nThe minimum and maximum refinement levels per isosurface can be provided in absolute values relative to the global minimum and maximum refinement. This is done with the 'min' and 'max' key words. For example: 'set Isosurfaces = max-2,  max,    Temperature: 0 | 600 ; min + 1,min+2, Temperature: 1600 | 3000,   C\\_2 : 0.0 | 0.5'.\n\n`maximum refinement function': A mesh refinement criterion that ensures a maximum refinement level described by an explicit formula with the depth or position as argument. Which coordinate representation is used is determined by an input parameter. Whatever the coordinate system chosen, the function you provide in the input file will by default depend on variables `x', `y' and `z' (if in 3d). However, the meaning of these symbols depends on the coordinate system. In the Cartesian coordinate system, they simply refer to their natural meaning. If you have selected `depth' for the coordinate system, then `x' refers to the depth variable and `y' and `z' will simply always be zero. If you have selected a spherical coordinate system, then `x' will refer to the radial distance of the point to the origin, `y' to the azimuth angle and `z' to the polar angle measured positive from the north pole. Note that the order of spherical coordinates is r,phi,theta and not r,theta,phi, since this allows for dimension independent expressions. Each coordinate system also includes a final `t' variable which represents the model time, evaluated in years if the 'Use years in output instead of seconds' parameter is set, otherwise evaluated in seconds. After evaluating the function, its values are rounded to the nearest integer.\n\nThe format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`minimum refinement function': A mesh refinement criterion that ensures a minimum refinement level described by an explicit formula with the depth or position as argument. Which coordinate representation is used is determined by an input parameter. Whatever the coordinate system chosen, the function you provide in the input file will by default depend on variables `x', `y' and `z' (if in 3d). However, the meaning of these symbols depends on the coordinate system. In the Cartesian coordinate system, they simply refer to their natural meaning. If you have selected `depth' for the coordinate system, then `x' refers to the depth variable and `y' and `z' will simply always be zero. If you have selected a spherical coordinate system, then `x' will refer to the radial distance of the point to the origin, `y' to the azimuth angle and `z' to the polar angle measured positive from the north pole. Note that the order of spherical coordinates is r,phi,theta and not r,theta,phi, since this allows for dimension independent expressions. Each coordinate system also includes a final `t' variable which represents the model time, evaluated in years if the 'Use years in output instead of seconds' parameter is set, otherwise evaluated in seconds. After evaluating the function, its values are rounded to the nearest integer.\n\nThe format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`nonadiabatic temperature': A mesh refinement criterion that computes refinement indicators from the excess temperature(difference between temperature and adiabatic temperature.\n\n`nonadiabatic temperature threshold': A mesh refinement criterion that computes refinement indicators from the temperature difference between the actual temperature and the adiabatic conditions (the nonadiabatic temperature). If the temperature anomaly exceeds the threshold given in the input file, the cell is marked for refinement.\n\n`particle density': A mesh refinement criterion that computes refinement indicators based on the density of particles. In practice this plugin equilibrates the number of particles per cell, leading to fine cells in high particle density regions and coarse cells in low particle density regions. This plugin is mostly useful for models with inhomogeneous particle density, e.g. when tracking an initial interface with a high particle density, or when the spatial particle density denotes the region of interest. Additionally, this plugin tends to balance the computational load between processes in parallel computations, because the particle and mesh density is more aligned.\n\n`slope': A class that implements a mesh refinement criterion intended for use with deforming mesh boundaries, like the free surface. It calculates a local slope based on the angle between the surface normal and the local gravity vector. Cells with larger angles are marked for refinement.\n\nTo use this refinement criterion, you may want to combine it with other refinement criteria, setting the 'Normalize individual refinement criteria' flag and using the `max' setting for 'Refinement criteria merge operation'.\n\n`strain rate': A mesh refinement criterion that computes the refinement indicators equal to the strain rate norm computed at the center of the elements.\n\n`temperature': A mesh refinement criterion that computes refinement indicators from the temperature field.\n\nThe way these indicators are computed is by evaluating the `Kelly error indicator' on the temperature field. This error indicator takes the finite element approximation of the temperature field and uses it to compute an approximation of the second derivatives of the temperature for each cell. This approximation is then multiplied by an appropriate power of the cell's diameter to yield an indicator for how large the error is likely going to be on this cell. This construction rests on the observation that for many partial differential equations, the error on each cell is proportional to some power of the cell's diameter times the second derivatives of the solution on that cell.\n\nFor complex equations such as those we solve here, this observation may not be strictly true in the mathematical sense, but it often yields meshes that are surprisingly good.\n\n`thermal energy density': A mesh refinement criterion that computes refinement indicators from a field that describes the spatial variability of the thermal energy density, $\\rho C_p T$. Because this quantity may not be a continuous function ($\\rho$ and $C_p$ may be discontinuous functions along discontinuities in the medium, for example due to phase changes), we approximate the gradient of this quantity to refine the mesh. The error indicator defined here takes the magnitude of the approximate gradient and scales it by $h_K^{1.5}$ where $h_K$ is the diameter of each cell. This scaling ensures that the error indicators converge to zero as $h_K\\rightarrow 0$ even if the energy density is discontinuous, since the gradient of a discontinuous function grows like $1\/h_K$.\n\n`topography': A class that implements a mesh refinement criterion, which always flags all cells in the uppermost layer for refinement. This is useful to provide high accuracy for processes at or close to the surface.\n\nTo use this refinement criterion, you may want to combine it with other refinement criteria, setting the 'Normalize individual refinement criteria' flag and using the `max' setting for 'Refinement criteria merge operation'.\n\n`velocity': A mesh refinement criterion that computes refinement indicators from the velocity field.\n\nThe way these indicators are computed is by evaluating the `Kelly error indicator' on the velocity field. This error indicator takes the finite element approximation of the velocity field and uses it to compute an approximation of the second derivatives of the velocity for each cell. This approximation is then multiplied by an appropriate power of the cell's diameter to yield an indicator for how large the error is likely going to be on this cell. This construction rests on the observation that for many partial differential equations, the error on each cell is proportional to some power of the cell's diameter times the second derivatives of the solution on that cell.\n\nFor complex equations such as those we solve here, this observation may not be strictly true in the mathematical sense, but it often yields meshes that are surprisingly good.\n\n`viscosity': A mesh refinement criterion that computes refinement indicators from a field that describes the spatial variability of the logarithm of the viscosity, $\\log\\eta$. (We choose the logarithm of the viscosity because it can vary by orders of magnitude.)Because this quantity may not be a continuous function ($\\eta$ may be a discontinuous function along discontinuities in the medium, for example due to phase changes), we approximate the gradient of this quantity to refine the mesh. The error indicator defined here takes the magnitude of the approximate gradient and scales it by $h_K^{1+d\/2}$ where $h_K$ is the diameter of each cell and $d$ is the dimension. This scaling ensures that the error indicators converge to zero as $h_K\\rightarrow 0$ even if the viscosity is discontinuous, since the gradient of a discontinuous function grows like $1\/h_K$.\n\n`volume of fluid interface': A class that implements a mesh refinement criterion, which ensures a minimum level of refinement near the volume of fluid interface boundary.",
            "pattern": "331",
            "pattern_description": "[MultipleSelection artificial viscosity|boundary|compaction length|composition|composition approximate gradient|composition gradient|composition threshold|density|isosurfaces|maximum refinement function|minimum refinement function|nonadiabatic temperature|nonadiabatic temperature threshold|particle density|slope|strain rate|temperature|thermal energy density|topography|velocity|viscosity|volume of fluid interface ]"
        },
        "Time steps between mesh refinement": {
            "value": "0",
            "default_value": "10",
            "documentation": "The number of time steps after which the mesh is to be adapted again based on computed error indicators. If 0 then the mesh will never be changed.",
            "pattern": "54",
            "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
        },
        "Artificial viscosity": {
            "Compositional field scaling factors": {
                "value": "",
                "default_value": "",
                "documentation": "A list of scaling factors by which every individual compositional field will be multiplied. These factors are used to weigh the various indicators relative to each other and to the temperature. \n\nIf the list of scaling factors given in this parameter is empty, then this indicates that they should all be chosen equal to 0. If the list is not empty then it needs to have as many entries as there are compositional fields.",
                "pattern": "350",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Temperature scaling factor": {
                "value": "0.0",
                "default_value": "0.0",
                "documentation": "A scaling factor for the artificial viscosity  of the temperature equation. Use 0.0 to disable.",
                "pattern": "349",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Boundary": {
            "Boundary refinement indicators": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of names denoting those boundaries where there should be mesh refinement.\n\nThe names of the boundaries listed here can either be numbers (in which case they correspond to the numerical boundary indicators assigned by the geometry object), or they can correspond to any of the symbolic names the geometry object may have provided for each part of the boundary. You may want to compare this with the documentation of the geometry model you use in your model.",
                "pattern": "351",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Compaction length": {
            "Mesh cells per compaction length": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "The desired ratio between compaction length and size of the mesh cells, or, in other words, how many cells the mesh should (at least) have per compaction length. Every cell where this ratio is smaller than the value specified by this parameter (in places with fewer mesh cells per compaction length) is marked for refinement.",
                "pattern": "352",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Composition": {
            "Compositional field scaling factors": {
                "value": "",
                "default_value": "",
                "documentation": "A list of scaling factors by which every individual compositional field will be multiplied. If only a single compositional field exists, then this parameter has no particular meaning. On the other hand, if multiple criteria are chosen, then these factors are used to weigh the various indicators relative to each other. \n\nIf the list of scaling factors given in this parameter is empty, then this indicates that they should all be chosen equal to one. If the list is not empty then it needs to have as many entries as there are compositional fields.",
                "pattern": "353",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Composition approximate gradient": {
            "Compositional field scaling factors": {
                "value": "",
                "default_value": "",
                "documentation": "A list of scaling factors by which every individual compositional field gradient will be multiplied. If only a single compositional field exists, then this parameter has no particular meaning. On the other hand, if multiple criteria are chosen, then these factors are used to weigh the various indicators relative to each other. \n\nIf the list of scaling factors given in this parameter is empty, then this indicates that they should all be chosen equal to one. If the list is not empty then it needs to have as many entries as there are compositional fields.",
                "pattern": "354",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Composition gradient": {
            "Compositional field scaling factors": {
                "value": "",
                "default_value": "",
                "documentation": "A list of scaling factors by which every individual compositional field gradient will be multiplied. If only a single compositional field exists, then this parameter has no particular meaning. On the other hand, if multiple criteria are chosen, then these factors are used to weigh the various indicators relative to each other. \n\nIf the list of scaling factors given in this parameter is empty, then this indicates that they should all be chosen equal to one. If the list is not empty then it needs to have as many entries as there are compositional fields.",
                "pattern": "338",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Composition threshold": {
            "Compositional field thresholds": {
                "value": "",
                "default_value": "",
                "documentation": "A list of thresholds that every individual compositional field will be evaluated against.",
                "pattern": "339",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Isosurfaces": {
            "Isosurfaces": {
                "value": "",
                "default_value": "",
                "documentation": "A list of isosurfaces separated by semi-colons (;). Each isosurface entry consists of multiple entries separated by a comma. The first two entries indicate the minimum and maximum refinement levels respectively. The entries after the first two describe the fields the isosurface applies to, followed by a colon (:), which is again followed by the minimum and maximum property values separated by bar (|). An example for an isosurface is '0, 2, Temperature: 300 | 600; 2, 2, C\\_1: 0.5 | 1'. In this example the mesh refinement is kept between level 0 and level 2 if the temperature is between 300 and 600 and at level 2 when the compositional field C\\_1 is between 0.5 and 1. If both happen at the same location and the current refinement level is 1, it means that the first isoline will not set any flag and the second isoline will set a refinement flag. This means the cell will be refined. If both the coarsening and refinement flags are set, preference is given to refinement. \n\nThe first two entries for each isosurface, describing the minimum and maximum grid levels, can be two numbers or contain one of the key values 'min' and 'max'. This indicates the key will be replaced with the global minimum and maximum refinement levels. The 'min' and 'max' keys also accept adding values to be added or subtracted from them respectively. This is done by adding a '+' or '-' and a number behind them (e.g. min+2 or max-1). Note that you can't subtract a value from a minimum value or add a value to the maximum value. If, for example, `max-4` drops below the minimum or `min+4` goes above the maximum, it will simply use the global minimum and maximum values respectively. The same holds for any mesh refinement level below the global minimum or above the global maximum.",
                "pattern": "340",
                "pattern_description": "[Anything]"
            }
        },
        "Maximum refinement function": {
            "Coordinate system": {
                "value": "depth",
                "default_value": "depth",
                "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `depth', `cartesian' and `spherical'. `depth' will create a function, in which only the first variable is non-zero, which is interpreted to be the depth of the point. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle.",
                "pattern": "341",
                "pattern_description": "[Selection depth|cartesian|spherical ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "344",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "343",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "342",
                "pattern_description": "[Anything]"
            }
        },
        "Minimum refinement function": {
            "Coordinate system": {
                "value": "depth",
                "default_value": "depth",
                "documentation": "A selection that determines the assumed coordinate system for the function variables. Allowed values are `depth', `cartesian' and `spherical'. `depth' will create a function, in which only the first variable is non-zero, which is interpreted to be the depth of the point. `spherical' coordinates are interpreted as r,phi or r,phi,theta in 2d\/3d respectively with theta being the polar angle.",
                "pattern": "345",
                "pattern_description": "[Selection depth|cartesian|spherical ]"
            },
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "348",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "347",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "346",
                "pattern_description": "[Anything]"
            }
        },
        "Nonadiabatic temperature threshold": {
            "Temperature anomaly type": {
                "value": "absolute value",
                "default_value": "absolute value",
                "documentation": "What type of temperature anomaly should be considered when evaluating against the threshold: Only negative anomalies (negative only), only positive anomalies (positive only) or the absolute value of the nonadiabatic temperature.",
                "pattern": "337",
                "pattern_description": "[Selection negative only|positive only|absolute value ]"
            },
            "Threshold": {
                "value": "100",
                "default_value": "100",
                "documentation": "A threshold that the nonadiabatic temperature will be evaluated against. Units: \\si{\\kelvin}",
                "pattern": "336",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Volume of fluid interface": {
            "Strict coarsening": {
                "value": "false",
                "default_value": "false",
                "documentation": "If true, then explicitly coarsen any cells not neighboring the VolumeOfFluid interface.",
                "pattern": "335",
                "pattern_description": "[Bool]"
            }
        }
    },
    "Nullspace removal": {
        "Remove nullspace": {
            "value": "",
            "default_value": "",
            "documentation": "Choose none, one or several from \n\n\\begin{itemize} \\item net rotation \\item angular momentum \\item net translation \\item net surface rotation\\item linear momentum \\item net x translation \\item net y translation \\item net z translation \\item linear x momentum \\item linear y momentum \\item linear z momentum \\end{itemize}\n\nThese are a selection of operations to remove certain parts of the nullspace from the velocity after solving. For some geometries and certain boundary conditions the velocity field is not uniquely determined but contains free translations and\/or rotations. Depending on what you specify here, these non-determined modes will be removed from the velocity field at the end of the Stokes solve step.\n\n\nThe ``angular momentum'' option removes a rotation such that the net angular momentum is zero. The ``linear * momentum'' options remove translations such that the net momentum in the relevant direction is zero.  The ``net rotation'' option removes the net rotation of the whole domain, the ``net surface rotation'' option removes the net rotation of the top surface, and the ``net * translation'' options remove the net translations in the relevant directions.  For most problems there should not be a significant difference between the momentum and rotation\/translation versions of nullspace removal, although the momentum versions are more physically motivated. They are equivalent for constant density simulations, and approximately equivalent when the density variations are small.\n\nNote that while more than one operation can be selected it only makes sense to pick one rotational and one translational operation.",
            "pattern": "51",
            "pattern_description": "[MultipleSelection net rotation|angular momentum|net surface rotation|net translation|linear momentum|net x translation|net y translation|net z translation|linear x momentum|linear y momentum|linear z momentum ]"
        }
    },
    "Postprocess": {
        "List of postprocessors": {
            "value": "visualization, velocity statistics, topography",
            "default_value": "",
            "documentation": "A comma separated list of postprocessor objects that should be run at the end of each time step. Some of these postprocessors will declare their own parameters which may, for example, include that they will actually do something only every so many time steps or years. Alternatively, the text `all' indicates that all available postprocessors should be run after each time step.\n\nThe following postprocessors are available:\n\n`Stokes residual': A postprocessor that outputs the Stokes residuals during the iterative solver algorithm into a file stokes_residuals.txt in the output directory.\n\n`basic statistics': A postprocessor that outputs some simplified statistics like the Rayleigh number and other quantities that only make sense in certain model setups. The output is written after completing initial adaptive refinement steps. The postprocessor assumes a point at the surface at the adiabatic surface temperature and pressure is a reasonable reference condition for computing these properties. Furthermore, the Rayleigh number is computed using the model depth (i.e. not the radius of the Earth), as we need a definition that is geometry independent. Take care when comparing these values to published studies and make sure they use the same definitions.\n\n`boundary densities': A postprocessor that computes the laterally averaged density at the top and bottom of the domain.\n\n`boundary pressures': A postprocessor that computes the laterally averaged pressure at the top and bottom of the domain.\n\n`boundary strain rate residual statistics': A postprocessor that computes some statistics about the surface strain rate residual along the top boundary. The residual is the difference between the second invariant of the model strain rate and the second strain rate invariant read from the input data file. Currently, the strain residual statistics, i.e., min, max and the rms magnitude, are computed at the top surface.\n\n`boundary velocity residual statistics': A postprocessor that computes some statistics about the velocity residual along the top boundary. The velocity residual is the difference between the model solution velocities and the input velocities (GPlates model or ascii data). Currently, the velocity residual statistics, i.e., min, max and the rms magnitude, is computed at the top surface.\n\n`command': A postprocessor that executes a command line process.\n\n`composition statistics': A postprocessor that computes some statistics about the compositional fields, if present in this simulation. In particular, it computes maximal and minimal values of each field, as well as the total mass contained in this field as defined by the integral $m_i(t) = \\int_\\Omega c_i(\\mathbf x,t) \\; \\text{d}x$.\n\n`composition velocity statistics': A postprocessor that computes the root mean square velocity over the area spanned by each compositional field (i.e. where the field values are larger or equal to 0.5.\n\n`core statistics': A postprocessor that computes some statistics about the core evolution. (Working only with dynamic core boundary temperature plugin)\n\n`crystal preferred orientation': A Postprocessor that writes out CPO specific particle data.It can write out the CPO data as it is stored (raw) and\/or as arandom draw volume weighted representation. The latter oneis recommended for plotting against real data. For both representationsthe specific output fields and their order can be set.The work of this postprocessor should better be done by the main particles postprocessor, however we need to be able to process the data before outputing it, which does not work with that postprocessor. If this is added to the other postprocessor in the future this one becomes obsolete.\n\n`depth average': A postprocessor that computes depth averaged quantities and writes them into a file <depth_average.ext> in the output directory, where the extension of the file is determined by the output format you select. In addition to the output format, a number of other parameters also influence this postprocessor, and they can be set in the section \\texttt{Postprocess\/Depth average} in the input file.\n\nIn the output files, the $x$-value of each data point corresponds to the depth, whereas the $y$-value corresponds to the simulation time. The time is provided in seconds or, if the global ``Use years in output instead of seconds'' parameter is set, in years.\n\n`domain volume statistics': A postprocessor that computes the total area (in 2d) or volume (in 3d) of the computational domain. \n\n`dynamic topography': A postprocessor that computes a measure of dynamic topography based on the stress at the surface and bottom. The data is written into text files named `dynamic\\_topography.NNNNN' in the output directory, where NNNNN is the number of the time step.\n\nThe exact approach works as follows: At the centers of all cells that sit along the top surface, we evaluate the stress and evaluate the component of it in the direction in which gravity acts. In other words, we compute $\\sigma_{rr}={\\hat g}^T(2 \\eta \\varepsilon(\\mathbf u)- \\frac 13 (\\textrm{div}\\;\\mathbf u)I)\\hat g - p_d$ where $\\hat g = \\mathbf g\/\\|\\mathbf g\\|$ is the direction of the gravity vector $\\mathbf g$ and $p_d=p-p_a$ is the dynamic pressure computed by subtracting the adiabatic pressure $p_a$ from the total pressure $p$ computed as part of the Stokes solve. From this, the dynamic topography is computed using the formula $h=\\frac{\\sigma_{rr}}{(\\mathbf g \\cdot \\mathbf n)  \\rho}$ where $\\rho$ is the density at the cell center. For the bottom surface we chose the convection that positive values are up (out) and negative values are in (down), analogous to the deformation of the upper surface. Note that this implementation takes the direction of gravity into account, which means that reversing the flow in backward advection calculations will not reverse the instantaneous topography because the reverse flow will be divided by the reverse surface gravity.  \nThe file format then consists of lines with Euclidean coordinates followed by the corresponding topography value.\n\n(As a side note, the postprocessor chooses the cell center instead of the center of the cell face at the surface, where we really are interested in the quantity, since this often gives better accuracy. The results should in essence be the same, though.)\n\n`entropy viscosity statistics': A postprocessor that computes the maximum and volume averagedentropy viscosity stabilization for the temperature field.\n\n`geoid': A postprocessor that computes a representation of the geoid based on the density structure in the mantle, as well as the topography at the surface and core mantle boundary (CMB) if desired. The topography is based on the dynamic topography postprocessor in case of no free surface, and based on the real surface from the geometry model in case of a free surface. The geoid is computed from a spherical harmonic expansion, so the geometry of the domain must be a 3d spherical shell.\n\n`global statistics': A postprocessor that outputs all the global statistics information, e.g. the time of the simulation, the timestep number, number of degrees of freedom and solver iterations for each timestep. The postprocessor can output different formats, the first printing one line in the statistics file per nonlinear solver iteration (if a nonlinear solver scheme is selected). The second prints one line per timestep, summing the information about all nonlinear iterations in this line. Note that this postprocessor is always active independent on whether or not it is selected in the parameter file.\n\n`gravity calculation': A postprocessor that computes gravity, gravity anomalies, gravity potential and gravity gradients for a set of points (e.g. satellites) in or above the model surface for either a user-defined range of latitudes, longitudes and radius or a list of point coordinates.Spherical coordinates in the output file are radius, colatitude and colongitude. Gravity is here based on the density distribution from the material model (and non adiabatic). This means that the density may come directly from an ascii file. This postprocessor also computes theoretical gravity and its derivatives, which corresponds to the analytical solution of gravity in the same geometry but filled with a reference density. The reference density is also used to determine density anomalies for computing gravity anomalies. Thus one must carefully evaluate the meaning of the gravity anomaly output, because the solution may not reflect the actual gravity anomaly (due to differences in the assumed reference density). On way to guarantee correct gravity anomalies is to subtract gravity of a certain point from the average gravity on the map. Another way is to directly use density anomalies for this postprocessor.The average- minimum- and maximum gravity acceleration and potential are written into the statistics file.\n\n`heat flux densities': A postprocessor that computes some statistics about the heat flux density for each boundary id. The heat flux density across each boundary is computed in outward direction, i.e., from the domain to the outside. The heat flux is computed as sum of advective heat flux and conductive heat flux through Neumann boundaries, both computed as integral over the boundary area, and conductive heat flux through Dirichlet boundaries, which is computed using the consistent boundary flux method as described in ``Gresho, Lee, Sani, Maslanik, Eaton (1987). The consistent Galerkin FEM for computing derived boundary quantities in thermal and or fluids problems. International Journal for Numerical Methods in Fluids, 7(4), 371-394.''\n\nNote that the ``heat flux statistics'' postprocessor computes the same quantity as the one here, but not divided by the area of the surface. In other words, it computes the \\textit{total} heat flux through each boundary.\n\n`heat flux map': A postprocessor that computes the heat flux density across each boundary in outward direction, i.e., from the domain to the outside. The heat flux is computed as sum of advective heat flux and conductive heat flux through Neumann boundaries, both computed as integral over the boundary area, and conductive heat flux through Dirichlet boundaries, which is computed using the consistent boundary flux method as described in ``Gresho, Lee, Sani, Maslanik, Eaton (1987). The consistent Galerkin FEM for computing derived boundary quantities in thermal and or fluids problems. International Journal for Numerical Methods in Fluids, 7(4), 371-394.''\n\n`heat flux statistics': A postprocessor that computes some statistics about the heat flux density across each boundary in outward direction, i.e., from the domain to the outside. The heat flux is computed as sum of advective heat flux and conductive heat flux through Neumann boundaries, both computed as integral over the boundary area, and conductive heat flux through Dirichlet boundaries, which is computed using the consistent boundary flux method as described in ``Gresho, Lee, Sani, Maslanik, Eaton (1987). The consistent Galerkin FEM for computing derived boundary quantities in thermal and or fluids problems. International Journal for Numerical Methods in Fluids, 7(4), 371-394.''The point-wise heat flux can be obtained from the heat flux map postprocessor, which outputs the heat flux to a file, or the heat flux map visualization postprocessor, which outputs the heat flux for visualization. \n\nAs stated, this postprocessor computes the \\textit{outbound} heat flux. If you are interested in the opposite direction, for example from the core into the mantle when the domain describes the mantle, then you need to multiply the result by -1.\n\n\\note{In geodynamics, the term ``heat flux'' is often understood to be the quantity $- k \\nabla T$, which is really a heat flux \\textit{density}, i.e., a vector-valued field. In contrast to this, the current postprocessor only computes the integrated flux over each part of the boundary. Consequently, the units of the quantity computed here are $W=\\frac{J}{s}$.}\n\nThe ``heat flux densities'' postprocessor computes the same quantity as the one here, but divided by the area of the surface.\n\n`heating statistics': A postprocessor that computes some statistics about heating, averaged by volume. \n\n`load balance statistics': A postprocessor that computes statistics about the distribution of cells, and if present particles across subdomains. In particular, it computes maximal, average and minimal number of cells across all ranks. If there are particles it also computes the maximal, average, and minimum number of particles across all ranks, and maximal, average, and minimal ratio between local number of particles and local number of cells across all processes. All of these numbers can be useful to assess the load balance between different MPI ranks, as the difference between the minimal and maximal load should be as small as possible.\n\n`mass flux statistics': A postprocessor that computes some statistics about the mass flux across boundaries. For each boundary indicator (see your geometry description for which boundary indicators are used), the mass flux is computed in outward direction, i.e., from the domain to the outside, using the formula $\\int_{\\Gamma_i} \\rho \\mathbf v \\cdot \\mathbf n$ where $\\Gamma_i$ is the part of the boundary with indicator $i$, $\\rho$ is the density as reported by the material model, $\\mathbf v$ is the velocity, and $\\mathbf n$ is the outward normal. \n\nAs stated, this postprocessor computes the \\textit{outbound} mass flux. If you are interested in the opposite direction, for example from the core into the mantle when the domain describes the mantle, then you need to multiply the result by -1.\n\n\\note{In geodynamics, the term ``mass flux'' is often understood to be the quantity $\\rho \\mathbf v$, which is really a mass flux \\textit{density}, i.e., a vector-valued field. In contrast to this, the current postprocessor only computes the integrated flux over each part of the boundary. Consequently, the units of the quantity computed here are $\\frac{kg}{s}$.}\n\n`material statistics': A postprocessor that computes some statistics about the material properties. In particular, it computes the volume-averages of the density and viscosity, and the total mass in the model. Specifically, it implements the following formulas in each time step: $\\left<\\rho\\right> = \\frac{1}{|\\Omega|} \\int_\\Omega \\rho(\\mathbf x) \\, \\text{d}x$, $\\left<\\eta\\right> = \\frac{1}{|\\Omega|} \\int_\\Omega \\eta(\\mathbf x) \\, \\text{d}x$, $M = \\int_\\Omega \\rho(\\mathbf x) \\, \\text{d}x$, where $|\\Omega|$ is the volume of the domain.\n\n`matrix statistics': A postprocessor that computes some statistics about the matrices. In particular, it outputs total memory consumption, total non-zero elements, and non-zero elements per block, for system matrix and system preconditioner matrix.\n\n`maximum depth of field': A postprocessor that for each compositional field outputs the largest depth at which a quadrature point is found where the field has a value of 0.5 or larger. For fields that do not represent materials, but for example track a certain quantity like strain, this value of 0.5 does not necessarily make sense. \n\n`melt statistics': A postprocessor that computes some statistics about the melt (volume) fraction. If the material model does not implement a melt fraction function, the output is set to zero.\n\n`memory statistics': A postprocessor that computes some statistics about the memory consumption. In particular, it computes the memory usage of the system matrix, triangulation, p4est, DoFHandler, current constraints, solution vector, and peak virtual memory usage, all in MB. It also outputs the memory usage of the system matrix to the screen.\n\n`mobility statistics': A postprocessor that computes some statistics about mobility following Tackley (2000) and Lourenco et al. (2020).\n\n`particle count statistics': A postprocessor that computes some statistics about the particle distribution, if present in this simulation. In particular, it computes minimal, average and maximal values of particles per cell in the global domain.\n\n`particles': A Postprocessor that creates particles that follow the velocity field of the simulation. The particles can be generated and propagated in various ways and they can carry a number of constant or time-varying properties. The postprocessor can write output positions and properties of all particles at chosen intervals, although this is not mandatory. It also allows other parts of the code to query the particles for information.\n\n`point values': A postprocessor that evaluates the solution (i.e., velocity, pressure, temperature, and compositional fields along with other fields that are treated as primary variables) at the end of every time step or after a user-specified time interval at a given set of points and then writes this data into the file <point\\_values.txt> in the output directory. The points at which the solution should be evaluated are specified in the section \\texttt{Postprocess\/Point values} in the input file.\n\nIn the output file, data is organized as (i) time, (ii) the 2 or 3 coordinates of the evaluation points, and (iii) followed by the values of the solution vector at this point. The time is provided in seconds or, if the global ``Use years in output instead of seconds'' parameter is set, in years. In the latter case, the velocity is also converted to meters\/year, instead of meters\/second.\n\n\\note{Evaluating the solution of a finite element field at arbitrarily chosen points is an expensive process. Using this postprocessor will only be efficient if the number of evaluation points or output times is relatively small. If you need a very large number of evaluation points, you should consider extracting this information from the visualization program you use to display the output of the `visualization' postprocessor.}\n\n`pressure statistics': A postprocessor that computes some statistics about the pressure field.\n\n`rotation statistics': A postprocessor that computes some statistics about the rotational velocity of the model (i.e. integrated net rotation and angular momentum). In 2d we assume the model to be a cross-section through an infinite domain in z direction, with a zero z-velocity. Thus, the z-axis is the only possible rotation axis and both moment of inertia and angular momentum are scalar instead of tensor quantities.\n\n`sea level': A postprocessor that computes the sea level for glacial isostatic adjustmentmodeling. When ice melts and enters the ocean, the ocean water needs to beredistributed in a gravitationally consistent way. With the updated surfaceloading (ocean and ice) the free surface deformation needs to be computediteratively before moving to the next time step. A postprocessor intended for use with a deforming top surface. After every step it computes the sea level based on the topography, ocean basin, ice melt, perturbed gravitational potential of the Earth model and gravitational potential of the ice load, relative to a reference datum (initial radius for a spherical shell geometry model). The sea level computation is based on \\cite{Martinec2018}. If 'SeaLevel.Output to file' is set to true, also outputs sea level into text files named `sea_level.NNNNN' in the output directory, where NNNNN is the number of the time step. \n\nThe file format then consists of lines with Euclidean coordinates followed by the corresponding sea level value. Sea level is printed\/written in meters. \n\n`spherical velocity statistics': A postprocessor that computes radial, tangential and total RMS velocity.\n\n`temperature statistics': A postprocessor that computes some statistics about the temperature field.\n\n`topography': A postprocessor intended for use with a deforming top surface.  After every step it loops over all the vertices on the top surface and determines the maximum and minimum topography relative to a reference datum (initial box height for a box geometry model or initial radius for a sphere\/spherical shell geometry model). If 'Topography.Output to file' is set to true, also outputs topography into text files named `topography.NNNNN' in the output directory, where NNNNN is the number of the time step.\nThe file format then consists of lines with Euclidean coordinates followed by the corresponding topography value.Topography is printed\/written in meters.\n\n`velocity boundary statistics': A postprocessor that computes some statistics about the velocity along the boundaries. For each boundary indicator (see your geometry description for which boundary indicators are used), the min and max velocity magnitude is computed.\n\n`velocity statistics': A postprocessor that computes the root mean square and maximum velocity in the computational domain.\n\n`viscous dissipation statistics': A postprocessor that outputs the viscous rate of dissipation of energy for each compositional field (where the field has a value of 0.5 or more) as well as over the whole domain. When all the fields represent lithologies and there is no background field, the sum of the individual field's dissipation should equal that over the whole domain. The viscous dissipation is computed as: $\\int_{V}\\left(\\sigma^\\prime \\dot{\\epsilon}^\\prime \\right)$, where $\\sigma^\\prime$  is the deviatoric stress and $\\dot{\\epsilon}^\\prime$ the deviatoric strain rate.Note then when shear heating is included in the temperature equation, it is better to use the 'heating statistics' postprocessor.\n\n`visualization': A postprocessor that takes the solution and writes it into files that can be read by a graphical visualization program. Additional run time parameters are read from the parameter subsection 'Visualization'.\n\n`volume of fluid statistics': A postprocessor that computes some statistics about the volume-of-fluid fields.",
            "pattern": "129",
            "pattern_description": "[MultipleSelection Stokes residual|basic statistics|boundary densities|boundary pressures|boundary strain rate residual statistics|boundary velocity residual statistics|command|composition statistics|composition velocity statistics|core statistics|crystal preferred orientation|depth average|domain volume statistics|dynamic topography|entropy viscosity statistics|geoid|global statistics|gravity calculation|heat flux densities|heat flux map|heat flux statistics|heating statistics|load balance statistics|mass flux statistics|material statistics|matrix statistics|maximum depth of field|melt statistics|memory statistics|mobility statistics|particle count statistics|particles|point values|pressure statistics|rotation statistics|sea level|spherical velocity statistics|temperature statistics|topography|velocity boundary statistics|velocity statistics|viscous dissipation statistics|visualization|volume of fluid statistics ]"
        },
        "Run postprocessors on nonlinear iterations": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether or not the postprocessors should be executed after each of the nonlinear iterations done within one time step. As this is mainly an option for the purposes of debugging, it is not supported when the 'Time between graphical output' is larger than zero, or when the postprocessor is not intended to be run more than once per timestep.",
            "pattern": "63",
            "pattern_description": "[Bool]"
        },
        "Boundary strain rate residual statistics": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/postprocess\/boundary-strain-rate-residual\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/postprocess\/boundary-strain-rate-residual\/",
                "documentation": "The name of a directory that contains the ascii data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "319",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "box_3d_boundary_strain_rate.txt",
                "default_value": "box_3d_boundary_strain_rate.txt",
                "documentation": "The file name of the input surface strain rate an ascii data. The file has one column in addition to the coordinate columns corresponding to the second invariant of strain rate. ",
                "pattern": "320",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model.",
                "pattern": "321",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            }
        },
        "Boundary velocity residual statistics": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/boundary-velocity\/gplates\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/boundary-velocity\/gplates\/",
                "documentation": "The name of a directory that contains the GPlates model or the ascii data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "322",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "current_day.gpml",
                "default_value": "current_day.gpml",
                "documentation": "The file name of the input velocity as a GPlates model or an ascii data. For the GPlates model, provide file in the same format as described in the 'gplates' boundary velocity plugin. For the ascii data, provide file in the same format as described in  'ascii data' initial composition plugin.",
                "pattern": "323",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/year set this factor to 0.01.",
                "pattern": "324",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Use ascii data": {
                "value": "false",
                "default_value": "false",
                "documentation": "Use ascii data files (e.g., GPS) for computing residual velocities instead of GPlates data.",
                "pattern": "326",
                "pattern_description": "[Bool]"
            },
            "Use spherical unit vectors": {
                "value": "false",
                "default_value": "false",
                "documentation": "Specify velocity as r, phi, and theta components instead of x, y, and z. Positive velocities point up, east, and north (in 3d) or out and clockwise (in 2d). This setting only makes sense for spherical geometries.GPlates data is always interpreted to be in east and north directions and is not affected by this parameter.",
                "pattern": "325",
                "pattern_description": "[Bool]"
            }
        },
        "Command": {
            "Command": {
                "value": "",
                "default_value": "",
                "documentation": "Command to execute.",
                "pattern": "329",
                "pattern_description": "[Anything]"
            },
            "Run on all processes": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to run command from all processes (true), or only on process 0 (false).",
                "pattern": "328",
                "pattern_description": "[Bool]"
            },
            "Terminate on failure": {
                "value": "false",
                "default_value": "false",
                "documentation": "Select whether \\aspect{} should terminate if the command returns a non-zero exit status.",
                "pattern": "327",
                "pattern_description": "[Bool]"
            }
        },
        "Composition velocity statistics": {
            "Names of selected compositional fields": {
                "value": "",
                "default_value": "",
                "documentation": "A list of names for each of the compositional fields that you want to compute the combined RMS velocity for.",
                "pattern": "330",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Crystal Preferred Orientation": {
            "Compress cpo data files": {
                "value": "true",
                "default_value": "true",
                "documentation": "Wether to compress the raw and weighted cpo data output files with zlib.",
                "pattern": "295",
                "pattern_description": "[Bool]"
            },
            "Random number seed": {
                "value": "1",
                "default_value": "1",
                "documentation": "The seed used to generate random numbers. This will make sure that results are reproducable as long as the problem is run with the same amount of MPI processes. It is implemented as final seed = random number seed + MPI Rank. ",
                "pattern": "290",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Temporary output location": {
                "value": "",
                "default_value": "",
                "documentation": "On large clusters it can be advantageous to first write the output to a temporary file on a local file system and later move this file to a network file system. If this variable is set to a non-empty string it will be interpreted as a temporary storage location.",
                "pattern": "292",
                "pattern_description": "[Anything]"
            },
            "Time between data output": {
                "value": "1e8",
                "default_value": "1e8",
                "documentation": "The time interval between each generation of output files. A value of zero indicates that output should be generated every time step.\n\nUnits: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "289",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Write in background thread": {
                "value": "false",
                "default_value": "false",
                "documentation": "File operations can potentially take a long time, blocking the progress of the rest of the model run. Setting this variable to `true' moves this process into background threads, while the rest of the model continues.",
                "pattern": "291",
                "pattern_description": "[Bool]"
            },
            "Write out draw volume weighted cpo data": {
                "value": "olivine Euler angles,enstatite Euler angles",
                "default_value": "olivine Euler angles,enstatite Euler angles",
                "documentation": "A list containing the what part of the random draw volume weighted particle cpo data needs to be written out after the particle id. after using a random draw volume weighting. The random draw volume weigthing uses a uniform random distribution This writes out the raw cpo data files for each MPI process. It can write out the following data: olivine volume fraction, olivine rotation matrix, olivine Euler angles, enstatite volume fraction, enstatite rotation matrix, enstatite Euler angles. \nNote that the rotation matrix and Euler angles both contain the same information, but in a different format. Euler angles are recommended over the rotation matrix since they only require to write 3 values instead of 9. If the list is empty, this file will not be written. Furthermore, the entries will be written out in the order given, and if entries are entered muliple times, they will be written out multiple times.",
                "pattern": "294",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "Write out raw cpo data": {
                "value": "olivine volume fraction,olivine Euler angles,enstatite volume fraction,enstatite Euler angles",
                "default_value": "olivine volume fraction,olivine Euler angles,enstatite volume fraction,enstatite Euler angles",
                "documentation": "A list containing what particle cpo data needs to be written out after the particle id. This writes out the raw cpo data files for each MPI process. It can write out the following data: olivine volume fraction, olivine rotation matrix, olivine Euler angles, enstatite volume fraction, enstatite rotation matrix, enstatite Euler angles. \nNote that the rotation matrix and Euler angles both contain the same information, but in a different format. Euler angles are recommended over the rotation matrix since they only require to write 3 values instead of 9. If the list is empty, this file will not be written.Furthermore, the entries will be written out in the order given, and if entries are entered muliple times, they will be written out multiple times.",
                "pattern": "293",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            }
        },
        "Depth average": {
            "Depth boundaries of zones": {
                "value": "",
                "default_value": "",
                "documentation": "The depth boundaries of zones within which we are to compute averages. By default this list is empty and we subdivide the entire domain into equidistant depth zones and compute averages within each of these zones. If this list is not empty it has to contain one more entry than the 'Number of zones' parameter, representing the upper and lower depth boundary of each zone. It is not necessary to cover the whole depth-range (i.e. you can select to only average in a single layer by choosing 2 arbitrary depths as the boundaries of that layer).",
                "pattern": "298",
                "pattern_description": "[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "List of output variables": {
                "value": "all",
                "default_value": "all",
                "documentation": "A comma separated list which specifies which quantities to average in each depth slice. It defaults to averaging all available quantities, but this can be an expensive operation, so you may want to select only a few.\n\nSpecifically, the sinking velocity is defined as the scalar product of the velocity and a unit vector in the direction of gravity, if positive (being zero if this product is negative, which would correspond to an upward velocity). The rising velocity is the opposite: the scalar product of the velocity and a unit vector in the direction opposite of gravity, if positive (being zero for downward velocities). \n\nList of options:\nall|temperature|composition|adiabatic temperature|adiabatic pressure|adiabatic density|adiabatic density derivative|velocity magnitude|sinking velocity|rising velocity|Vs|Vp|log viscosity|viscosity|vertical heat flux|vertical mass flux|composition mass",
                "pattern": "300",
                "pattern_description": "[MultipleSelection all|temperature|composition|adiabatic temperature|adiabatic pressure|adiabatic density|adiabatic density derivative|velocity magnitude|sinking velocity|rising velocity|Vs|Vp|log viscosity|viscosity|vertical heat flux|vertical mass flux|composition mass ]"
            },
            "Number of zones": {
                "value": "10",
                "default_value": "10",
                "documentation": "The number of zones in depth direction within which we are to compute averages. By default, we subdivide the entire domain into 10 depth zones and compute temperature and other averages within each of these zones. However, if you have a very coarse mesh, it may not make much sense to subdivide the domain into so many zones and you may wish to choose less than this default. It may also make computations slightly faster. On the other hand, if you have an extremely highly resolved mesh, choosing more zones might also make sense.",
                "pattern": "297",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Output format": {
                "value": "gnuplot, txt",
                "default_value": "gnuplot, txt",
                "documentation": "A list of formats in which the output shall be produced. The format in which the output is generated also determines the extension of the file into which data is written. The list of possible output formats that can be given here is documented in the appendix of the manual where the current parameter is described. By default the output is written as gnuplot file (for plotting), and as a simple text file.",
                "pattern": "299",
                "pattern_description": "[MultipleSelection none|dx|ucd|gnuplot|povray|eps|gmv|tecplot|vtk|vtu|hdf5|svg|deal.II intermediate|txt ]"
            },
            "Time between graphical output": {
                "value": "1e8",
                "default_value": "1e8",
                "documentation": "The time interval between each generation of graphical output files. A value of zero indicates that output should be generated in each time step. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "296",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Dynamic core statistics": {
            "Excess entropy only": {
                "value": "false",
                "default_value": "false",
                "documentation": "Output the excess entropy only instead the each entropy terms.",
                "pattern": "288",
                "pattern_description": "[Bool]"
            }
        },
        "Dynamic topography": {
            "Density above": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Dynamic topography is calculated as the excess or lack of mass that is supported by mantle flow. This value depends on the density of material that is moved up or down, i.e. crustal rock, and the density of the material that is displaced (generally water or air). While the density of crustal rock is part of the material model, this parameter `Density above' allows the user to specify the density value of material that is displaced above the solid surface. By default this material is assumed to be air, with a density of 0. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "301",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Density below": {
                "value": "9900.",
                "default_value": "9900.",
                "documentation": "Dynamic topography is calculated as the excess or lack of mass that is supported by mantle flow. This value depends on the density of material that is moved up or down, i.e. mantle above CMB, and the density of the material that is displaced (generally outer core material). While the density of mantle rock is part of the material model, this parameter `Density below' allows the user to specify the density value of material that is displaced below the solid surface. By default this material is assumed to be outer core material with a density of 9900. Units: \\si{\\kilogram\\per\\meter\\cubed}.",
                "pattern": "302",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Output bottom": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to output a file containing the bottom (i.e., CMB) dynamic topography.",
                "pattern": "304",
                "pattern_description": "[Bool]"
            },
            "Output surface": {
                "value": "true",
                "default_value": "true",
                "documentation": "Whether to output a file containing the surface dynamic topography.",
                "pattern": "303",
                "pattern_description": "[Bool]"
            }
        },
        "Geoid": {
            "Also output the gravity anomaly": {
                "alias": "Output gravity anomaly",
                "deprecation_status": "false"
            },
            "Also output the spherical harmonic coefficients of CMB dynamic topography contribution": {
                "alias": "Output CMB topography contribution coefficients",
                "deprecation_status": "false"
            },
            "Also output the spherical harmonic coefficients of density anomaly contribution": {
                "alias": "Output density anomaly contribution coefficients",
                "deprecation_status": "false"
            },
            "Also output the spherical harmonic coefficients of geoid anomaly": {
                "alias": "Output geoid anomaly coefficients",
                "deprecation_status": "false"
            },
            "Also output the spherical harmonic coefficients of surface dynamic topography contribution": {
                "alias": "Output surface topography contribution coefficients",
                "deprecation_status": "false"
            },
            "Density above": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The density value above the surface boundary.",
                "pattern": "311",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Density below": {
                "value": "9900.",
                "default_value": "9900.",
                "documentation": "The density value below the CMB boundary.",
                "pattern": "312",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Include CMB topography contribution": {
                "value": "true",
                "default_value": "true",
                "documentation": "Option to include the contribution from CMB topography on geoid. The default is true.",
                "pattern": "307",
                "pattern_description": "[Bool]"
            },
            "Include surface topography contribution": {
                "value": "true",
                "default_value": "true",
                "documentation": "Option to include the contribution from surface topography on geoid. The default is true.",
                "pattern": "306",
                "pattern_description": "[Bool]"
            },
            "Include the contributon from dynamic topography": {
                "value": "true",
                "default_value": "true",
                "documentation": "Option to include the contribution from dynamic topography on geoid. The default is true.",
                "pattern": "305",
                "pattern_description": "[Bool]"
            },
            "Maximum degree": {
                "value": "20",
                "default_value": "20",
                "documentation": "This parameter can be a random positive integer. However, the value normally should not exceed the maximum degree of the initial perturbed temperature field. For example, if the initial temperature uses S40RTS, the maximum degree should not be larger than 40.",
                "pattern": "308",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Minimum degree": {
                "value": "2",
                "default_value": "2",
                "documentation": "This parameter normally is set to 2 since the perturbed gravitational potential at degree 1 always vanishes in a reference frame with the planetary center of mass same as the center of figure.",
                "pattern": "309",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Output CMB topography contribution coefficients": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to output the spherical harmonic coefficients of the CMB topography contribution to the maximum degree. The default is false. ",
                "pattern": "315",
                "pattern_description": "[Bool]"
            },
            "Output data in geographical coordinates": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to output the geoid anomaly in geographical coordinates (latitude and longitude). The default is false, so postprocess will output the data in geocentric coordinates (x,y,z) as normally.",
                "pattern": "310",
                "pattern_description": "[Bool]"
            },
            "Output density anomaly contribution coefficients": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to output the spherical harmonic coefficients of the density anomaly contribution to the maximum degree. The default is false. ",
                "pattern": "316",
                "pattern_description": "[Bool]"
            },
            "Output geoid anomaly coefficients": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to output the spherical harmonic coefficients of the geoid anomaly up to the maximum degree. The default is false, so postprocess will only output the geoid anomaly in grid format. ",
                "pattern": "313",
                "pattern_description": "[Bool]"
            },
            "Output gravity anomaly": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to output the free-air gravity anomaly up to the maximum degree. The unit of the output is in SI, hence $m\/s^2$ ($1mgal = 10^-5 m\/s^2$). The default is false. ",
                "pattern": "317",
                "pattern_description": "[Bool]"
            },
            "Output surface topography contribution coefficients": {
                "value": "false",
                "default_value": "false",
                "documentation": "Option to output the spherical harmonic coefficients of the surface topography contribution to the maximum degree. The default is false. ",
                "pattern": "314",
                "pattern_description": "[Bool]"
            }
        },
        "Global statistics": {
            "Write statistics for each nonlinear iteration": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to put every nonlinear iteration into a separate line in the statistics file (if true), or to output only one line per time step that contains the total number of iterations of the Stokes and advection linear system solver.",
                "pattern": "318",
                "pattern_description": "[Bool]"
            }
        },
        "Gravity calculation": {
            "List of latitude": {
                "value": "",
                "default_value": "",
                "documentation": "Parameter for the list of points sampling scheme: List of satellite latitude coordinates.",
                "pattern": "285",
                "pattern_description": "[List of <[Double -90...90 (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "List of longitude": {
                "value": "",
                "default_value": "",
                "documentation": "Parameter for the list of points sampling scheme: List of satellite longitude coordinates.",
                "pattern": "284",
                "pattern_description": "[List of <[Double -180...180 (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "List of radius": {
                "value": "",
                "default_value": "",
                "documentation": "Parameter for the list of points sampling scheme: List of satellite radius coordinates. Just specify one radius if all points values have the same radius. If not, make sure there are as many radius as longitude and latitude",
                "pattern": "283",
                "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
            },
            "Maximum latitude": {
                "value": "90",
                "default_value": "90",
                "documentation": "Parameter for the uniform distribution sampling scheme: Gravity may be calculated for a sets of points along the latitude between a minimum and maximum latitude.",
                "pattern": "280",
                "pattern_description": "[Double -90...90 (inclusive)]"
            },
            "Maximum longitude": {
                "value": "180.",
                "default_value": "180.",
                "documentation": "Parameter for the uniform distribution sampling scheme: Gravity may be calculated for a sets of points along the longitude between a minimum and maximum longitude.",
                "pattern": "279",
                "pattern_description": "[Double -180...180 (inclusive)]"
            },
            "Maximum radius": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Parameter for the map sampling scheme: Maximum radius can be defined in or outside the model.",
                "pattern": "276",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Minimum latitude": {
                "value": "-90.",
                "default_value": "-90.",
                "documentation": "Parameter for the uniform distribution sampling scheme: Gravity may be calculated for a sets of points along the latitude between a minimum and maximum latitude.",
                "pattern": "278",
                "pattern_description": "[Double -90...90 (inclusive)]"
            },
            "Minimum longitude": {
                "value": "-180.",
                "default_value": "-180.",
                "documentation": "Parameter for the uniform distribution sampling scheme: Gravity may be calculated for a sets of points along the longitude between a minimum and maximum longitude.",
                "pattern": "277",
                "pattern_description": "[Double -180...180 (inclusive)]"
            },
            "Minimum radius": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "Parameter for the map sampling scheme: Minimum radius may be defined in or outside the model. Prescribe a minimum radius for a sampling coverage at a specific height.",
                "pattern": "275",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Number points fibonacci spiral": {
                "value": "200",
                "default_value": "200",
                "documentation": "Parameter for the fibonacci spiral sampling scheme: This specifies the desired number of satellites per radius layer. The default value is 200. Note that sampling becomes more uniform with increasing number of satellites",
                "pattern": "270",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Number points latitude": {
                "value": "1",
                "default_value": "1",
                "documentation": "Parameter for the map sampling scheme: This specifies the number of points along the latitude (e.g. gravity map) between a minimum and maximum latitude.",
                "pattern": "274",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Number points longitude": {
                "value": "1",
                "default_value": "1",
                "documentation": "Parameter for the map sampling scheme: This specifies the number of points along the longitude (e.g. gravity map) between a minimum and maximum longitude.",
                "pattern": "273",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Number points radius": {
                "value": "1",
                "default_value": "1",
                "documentation": "Parameter for the map sampling scheme: This specifies the number of points along the radius (e.g. depth profile) between a minimum and maximum radius.",
                "pattern": "272",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Precision in gravity output": {
                "value": "12",
                "default_value": "12",
                "documentation": "Set the precision of gravity acceleration, potential and gradients in the gravity output and statistics file.",
                "pattern": "282",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Quadrature degree increase": {
                "value": "0",
                "default_value": "0",
                "documentation": "Quadrature degree increase over the velocity element degree may be required when gravity is calculated near the surface or inside the model. An increase in the quadrature element adds accuracy to the gravity solution from noise due to the model grid.",
                "pattern": "271",
                "pattern_description": "[Integer range -1...2147483647 (inclusive)]"
            },
            "Reference density": {
                "value": "3300.",
                "default_value": "3300.",
                "documentation": "Gravity anomalies may be computed using density anomalies relative to a reference density.",
                "pattern": "281",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Sampling scheme": {
                "value": "map",
                "default_value": "map",
                "documentation": "Choose the sampling scheme. By default, the map produces a grid of equally angled points between a minimum and maximum radius, longitude, and latitude. A list of points contains the specific coordinates of the satellites. The fibonacci spiral sampling scheme produces a uniformly distributed map on the surface of sphere defined by a minimum and\/or maximum radius.",
                "pattern": "269",
                "pattern_description": "[Selection map|list|list of points|fibonacci spiral ]"
            },
            "Time between gravity output": {
                "value": "1e8",
                "default_value": "1e8",
                "documentation": "The time interval between each generation of gravity output files. A value of 0 indicates that output should be generated in each time step. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "286",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Time steps between gravity output": {
                "value": "2147483647",
                "default_value": "2147483647",
                "documentation": "The maximum number of time steps between each generation of gravity output files.",
                "pattern": "287",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            }
        },
        "Memory statistics": {
            "Output peak virtual memory (VmPeak)": {
                "value": "true",
                "default_value": "true",
                "documentation": "If set to 'true', also output the peak virtual memory usage (computed as the maximum over all processors).",
                "pattern": "193",
                "pattern_description": "[Bool]"
            }
        },
        "Particles": {
            "Allow cells without particles": {
                "value": "false",
                "default_value": "false",
                "documentation": "By default, every cell needs to contain particles to use this interpolator plugin. If this parameter is set to true, cells are allowed to have no particles, In case both the current cell and its neighbors are empty, the interpolator will return 0 for the current cell's properties.",
                "pattern": "245",
                "pattern_description": "[Bool]"
            },
            "Data output format": {
                "value": "vtu",
                "default_value": "vtu",
                "documentation": "A comma separated list of file formats to be used for graphical output. The list of possible output formats that can be given here is documented in the appendix of the manual where the current parameter is described.",
                "pattern": "195",
                "pattern_description": "[MultipleSelection none|dx|ucd|gnuplot|povray|eps|gmv|tecplot|vtk|vtu|hdf5|svg|deal.II intermediate|ascii ]"
            },
            "Exclude output properties": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of particle properties that should \\textit{not} be output. If this list contains the entry `all', only the id of particles will be provided in graphical output files.",
                "pattern": "199",
                "pattern_description": "[Anything]"
            },
            "Integration scheme": {
                "value": "rk2",
                "default_value": "rk2",
                "documentation": "This parameter is used to decide which method to use to solve the equation that describes the position of particles, i.e., $\\frac{d}{dt}\\mathbf x_k(t) = \\mathbf u(\\mathbf x_k(t),t)$, where $k$ is an index that runs over all particles, and $\\mathbf u(\\mathbf x,t)$ is the velocity field that results from the Stokes equations.\n\nIn practice, the exact velocity $\\mathbf u(\\mathbf x,t)$ is of course not available, but only a numerical approximation $\\mathbf u_h(\\mathbf x,t)$. Furthermore, this approximation is only available at discrete time steps, $\\mathbf u^n(\\mathbf x)=\\mathbf u(\\mathbf x,t^n)$, and these need to be interpolated between time steps if the integrator for the equation above requires an evaluation at time points between the discrete time steps. If we denote this interpolation in time by $\\tilde{\\mathbf u}_h(\\mathbf x,t)$ where $\\tilde{\\mathbf u}_h(\\mathbf x,t^n)=\\mathbf u^n(\\mathbf x)$, then the equation the differential equation solver really tries to solve is $\\frac{d}{dt}\\tilde{\\mathbf x}_k(t) =  \\tilde{\\mathbf u}_h(\\mathbf x_k(t),t)$.\n\nAs a consequence of these considerations, if you try to assess convergence properties of an ODE integrator -- for example to verify that the RK4 integrator converges with fourth order --, it is important to recall that the integrator may not solve the equation you think it solves. If, for example, we call the numerical solution of the ODE $\\tilde{\\mathbf x}_{k,h}(t)$, then the error will typically satisfy a relationship like \\[  \\| \\tilde{\\mathbf x}_k(T) - \\tilde{\\mathbf x}_{k,h}(T) \\|  \\le  C(T) \\Delta t^p\\] where $\\Delta t$ is the time step and $p$ the convergence order of the method, and $C(T)$ is a (generally unknown) constant that depends on the end time $T$ at which one compares the solutions. On the other hand, an analytically computed trajectory would likely use the \\textit{exact} velocity, and one may be tempted to compute $\\| \\mathbf x_k(T) - \\tilde{\\mathbf x}_{k,h}(T) \\|$, but this quantity will, in the best case, only satisfy an estimate of the form \\[  \\| \\mathbf x_k(T) - \\tilde{\\mathbf x}_{k,h}(T) \\|  \\le  C_1(T) \\Delta t^p  + C_2(T) \\| \\mathbf u-\\mathbf u_h \\|  + C_3(T) \\| \\mathbf u_h-\\tilde{\\mathbf u}_h \\|\\] with appropriately chosen norms for the second and third term. These second and third terms typically converge to zero at relatively low rates (compared to the order $p$ of the integrator, which can often be chosen relatively high) in the mesh size $h$ and the time step size $\\\\Delta t$, limiting the overall accuracy of the ODE integrator.\n\nSelect one of the following models:\n\n`euler': Explicit Euler scheme integrator, where $y_{n+1} = y_n + \\Delta t \\, v(y_n)$. This requires only one integration substep per timestep.\n\n`rk2': Second Order Runge Kutta integrator $y_{n+1} = y_n + \\Delta t\\, v(t_{n+1\/2}, y_{n} + \\frac{1}{2} k_1)$ where $k_1 = \\Delta t\\, v(t_{n}, y_{n})$\n\n`rk4': Runge Kutta fourth order integrator, where $y_{n+1} = y_n + \\frac{1}{6} k_1 + \\frac{1}{3} k_2 + \\frac{1}{3} k_3 + \\frac{1}{6} k_4$ and $k_1$, $k_2$, $k_3$, $k_4$ are defined as usual.",
                "pattern": "236",
                "pattern_description": "[Selection euler|rk2|rk4 ]"
            },
            "Interpolation scheme": {
                "value": "cell average",
                "default_value": "cell average",
                "documentation": "Select one of the following models:\n\n`bilinear least squares': Uses linear least squares to obtain the slopes and center of a 2d or 3d plane from the particle positions and a particular property value on those particles. Interpolate this property onto a vector of points. If the limiter is enabled then it will ensure the interpolated properties do not exceed the range of the minimum and maximum of the values of the property on the particles. Note that deal.II must be configured with BLAS and LAPACK to support this operation.\n\n`cell average': Return the arithmetic average of all particle properties in the given cell, or in the neighboring cells if the given cell is empty. In case the neighboring cells are also empty, and 'Allow cells without particles' is set to true, the interpolator returns 0. Otherwise, an exception is thrown. \n\n`harmonic average': Return the harmonic average of all particle properties in the given cell. If the cell contains no particles, return the harmonic average of the properties in the neighboring cells. In case the neighboring cells are also empty, and 'Allow cells without particles' is set to true, the interpolator returns 0. Otherwise, an exception is thrown. \n\n`nearest neighbor': Return the properties of the nearest neighboring particle in the current cell, or nearest particle in nearest neighboring cell if current cell is empty. In case the neighboring cells are also empty, and 'Allow cells without particles' is set to true, the interpolator returns 0. Otherwise, an exception is thrown. \n\n`quadratic least squares': Interpolates particle properties onto a vector of points using a quadratic least squares method. Note that deal.II must be configured with BLAS\/LAPACK.",
                "pattern": "238",
                "pattern_description": "[Selection bilinear least squares|cell average|harmonic average|nearest neighbor|quadratic least squares ]"
            },
            "List of particle properties": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of particle properties that should be tracked. By default none is selected, which means only position, velocity and id of the particles are output. \n\nThe following properties are available:\n\n`composition': Implementation of a plugin in which the particle property is defined by the compositional fields in the model. This can be used to track solid compositionevolution over time.\n\n`cpo bingham average': This is a particle property plugin which computes the Bingham average for the Crystal Preferred Orientation particle property plugin so that it can be visualized.\n\n`cpo elastic tensor': A plugin in which the particle property tensor is defined as the Voigt average of the elastic tensors of the minerals in the textured rock.Currently only Olivine and Enstatite are supported.\n\n`crystal preferred orientation': The plugin manages and computes the evolution of Lattice\/Crystal Preferred Orientations (LPO\/CPO) on particles. Each ASPECT particle can be assigned many grains. Each grain is assigned a size and a orientation matrix. This allows for CPO evolution tracking with polycrystalline kinematic CrystalPreferredOrientation evolution models such as D-Rex (Kaminski and Ribe, 2001; Kaminski et al., 2004).\n\n`elastic stress': A plugin in which the particle property tensor is defined as the total elastic stress a particle has accumulated. See the viscoelastic material model documentation for more detailed information.\n\n`function': Implementation of a model in which the particle property is set by evaluating an explicit function at the initial position of each particle. The function is defined in the parameters in section ``Particles|Function''. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.\n\n`grain size': A plugin in which the particle property is defined as the evolving grain size of a particle. See the grain_size material model documentation for more detailed information.\n\n`initial composition': Implementation of a plugin in which the particle property is given as the initial composition at the particle's initial position. The particle gets as many properties as there are compositional fields.\n\n`initial position': Implementation of a plugin in which the particle property is given as the initial position of the particle. This property is vector-valued with as many components as there are space dimensions. In practice, it is often most useful to only visualize one of the components of this vector, or the magnitude of the vector. For example, in a spherical mantle simulation, the magnitude of this property equals the starting radius of a particle, and is thereby indicative of which part of the mantle a particle comes from.\n\n`integrated strain': A plugin in which the particle property tensor is defined as the deformation gradient tensor $\\mathbf F$ this particle has experienced. $\\mathbf F$ can be polar-decomposed into the left stretching tensor $\\mathbf L$ (the finite strain we are interested in), and the rotation tensor $\\mathbf Q$. See the corresponding cookbook in the manual for more detailed information.\n\n`integrated strain invariant': A plugin in which the particle property is defined as the finite strain invariant ($\\varepsilon_{ii}$). This property is calculated with the timestep ($dt$) and the second invariant of the deviatoric strain rate tensor ($\\dot{\\varepsilon}_{ii}$), where the value at time step $n$ is $\\varepsilon_{ii}^{n} = \\varepsilon_{ii}^{n-1} + dt\\dot{\\varepsilon}_{ii}$.\n\n`melt particle': Implementation of a plugin in which the particle property is defined as presence of melt above a threshold, which can be set as an input parameter. This property is set to 0 if melt is not present and set to 1 if melt is present.\n\n`pT path': Implementation of a plugin in which the particle property is defined as the current pressure and temperature at this position. This can be used to generate pressure-temperature paths of material points over time.\n\n`position': Implementation of a plugin in which the particle property is defined as the current position.\n\n`reference position': Implementation of a plugin in which the particle property is defined as the current reference position.\n\n`strain rate': Implementation of a plugin in which the time evolution of strain rate is saved and stored on the particles.\n\n`velocity': Implementation of a plugin in which the particle property is defined as the recent velocity at this position.\n\n`viscoplastic strain invariants': A plugin that calculates the finite strain invariant a particle has experienced and assigns it to either the plastic and\/or viscous strain field based on whether the material is plastically yielding, or the total strain field used in the visco plastic material model. The implementation of this property is equivalent to the implementation for compositional fields that is located in the plugin in \\texttt{benchmarks\/buiter\\_et\\_al\\_2008\\_jgr\/plugin\/},and is effectively the same as what the visco plastic material model uses for compositional fields.",
                "pattern": "246",
                "pattern_description": "[MultipleSelection composition|cpo bingham average|cpo elastic tensor|crystal preferred orientation|elastic stress|function|grain size|initial composition|initial position|integrated strain|integrated strain invariant|melt particle|pT path|position|reference position|strain rate|velocity|viscoplastic strain invariants ]"
            },
            "Load balancing strategy": {
                "value": "repartition",
                "default_value": "repartition",
                "documentation": "Strategy that is used to balance the computational load across processors for adaptive meshes.",
                "pattern": "200",
                "pattern_description": "[MultipleSelection none|remove particles|add particles|remove and add particles|repartition ]"
            },
            "Maximum particles per cell": {
                "value": "100",
                "default_value": "100",
                "documentation": "Upper limit for particle number per cell. This limit is useful for adaptive meshes to prevent coarse cells from slowing down the whole model. It will be checked and enforced after mesh refinement, after MPI transfer of particles and after particle movement. If there are \\texttt{n\\_number\\_of\\_particles} $>$ \\texttt{max\\_particles\\_per\\_cell} particles in one cell then \\texttt{n\\_number\\_of\\_particles} - \\texttt{max\\_particles\\_per\\_cell} particles in this cell are randomly chosen and destroyed.",
                "pattern": "202",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Minimum particles per cell": {
                "value": "0",
                "default_value": "0",
                "documentation": "Lower limit for particle number per cell. This limit is useful for adaptive meshes to prevent fine cells from being empty of particles. It will be checked and enforced after mesh refinement and after particle movement. If there are \\texttt{n\\_number\\_of\\_particles} $<$ \\texttt{min\\_particles\\_per\\_cell} particles in one cell then \\texttt{min\\_particles\\_per\\_cell} - \\texttt{n\\_number\\_of\\_particles} particles are generated and randomly placed in this cell. If the particles carry properties the individual property plugins control how the properties of the new particles are initialized.",
                "pattern": "201",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Number of grouped files": {
                "value": "16",
                "default_value": "16",
                "documentation": "VTU file output supports grouping files from several CPUs into a given number of files using MPI I\/O when writing on a parallel filesystem. Select 0 for no grouping. This will disable parallel file output and instead write one file per processor. A value of 1 will generate one big file containing the whole solution, while a larger value will create that many files (at most as many as there are MPI ranks).",
                "pattern": "196",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Number of particles": {
                "value": "1000",
                "default_value": "1000",
                "documentation": "Total number of particles to create (not per processor or per element). The number is parsed as a floating point number (so that one can specify, for example, '1e4' particles) but it is interpreted as an integer, of course.",
                "pattern": "232",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Particle generator name": {
                "value": "random uniform",
                "default_value": "random uniform",
                "documentation": "Select one of the following models:\n\n`ascii file': Generates a distribution of particles from coordinates specified in an Ascii data file. The file format is a simple text file, with as many columns as spatial dimensions and as many lines as particles to be generated. Initial comment lines starting with `#' will be discarded. Note that this plugin always generates as many particles as there are coordinates in the data file, the ``Postprocess\/Particles\/Number of particles'' parameter has no effect on this plugin. All of the values that define this generator are read from a section ``Postprocess\/Particles\/Generator\/Ascii file'' in the input file, see Section~\\ref{parameters:Postprocess\/Particles\/Generator\/Ascii_20file}.\n\n`probability density function': Generate a random distribution of particles over the entire simulation domain. The probability density is prescribed in the form of a user-prescribed function. The format of this function follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`. The return value of the function is always checked to be a non-negative probability density but it can be zero in parts of the domain.\n\n`quadrature points': Generates particles at the quadrature points of each active cell of the triangulation. Here, Gauss quadrature of degree (velocity\\_degree + 1), is used similarly to the assembly of Stokes matrix.\n\n`random uniform': Generates a random uniform distribution of particles over the entire simulation domain.\n\n`reference cell': Generates a uniform distribution of particles per cell and spatial direction in the unit cell and transforms each of the particles back to real region in the model domain. Uniform here means the particles will be generated with an equal spacing in each spatial dimension.\n\n`uniform box': Generate a uniform distribution of particles over a rectangular domain in 2d or 3d. Uniform here means the particles will be generated with an equal spacing in each spatial dimension. Note that in order to produce a regular distribution the number of generated particles might not exactly match the one specified in the input file.\n\n`uniform radial': Generate a uniform distribution of particles over a spherical domain in 2d or 3d. Uniform here means the particles will be generated with an equal spacing in each spherical spatial dimension, i.e., the particles are created at positions that increase linearly with equal spacing in radius, colatitude and longitude around a certain center point. Note that in order to produce a regular distribution the number of generated particles might not exactly match the one specified in the input file.",
                "pattern": "205",
                "pattern_description": "[Selection ascii file|probability density function|quadrature points|random uniform|reference cell|uniform box|uniform radial ]"
            },
            "Particle weight": {
                "value": "10",
                "default_value": "10",
                "documentation": "Weight that is associated with the computational load of a single particle. The sum of particle weights will be added to the sum of cell weights to determine the partitioning of the mesh if the `repartition' particle load balancing strategy is selected. The optimal weight depends on the used integrator and particle properties. In general for a more expensive integrator and more expensive properties a larger particle weight is recommended. Before adding the weights of particles, each cell already carries a weight of 1000 to account for the cost of field-based computations.",
                "pattern": "203",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Temporary output location": {
                "value": "",
                "default_value": "",
                "documentation": "On large clusters it can be advantageous to first write the output to a temporary file on a local file system and later move this file to a network file system. If this variable is set to a non-empty string it will be interpreted as a temporary storage location.",
                "pattern": "198",
                "pattern_description": "[Anything]"
            },
            "Time between data output": {
                "value": "1e8",
                "default_value": "1e8",
                "documentation": "The time interval between each generation of output files. A value of zero indicates that output should be generated every time step.\n\nUnits: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "194",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Update ghost particles": {
                "value": "false",
                "default_value": "false",
                "documentation": "Some particle interpolation algorithms require knowledge about particles in neighboring cells. To allow this, particles in ghost cells need to be exchanged between the processes neighboring this cell. This parameter determines whether this transport is happening.",
                "pattern": "204",
                "pattern_description": "[Bool]"
            },
            "Write in background thread": {
                "value": "false",
                "default_value": "false",
                "documentation": "File operations can potentially take a long time, blocking the progress of the rest of the model run. Setting this variable to `true' moves this process into a background thread, while the rest of the model continues.",
                "pattern": "197",
                "pattern_description": "[Bool]"
            },
            "CPO Bingham Average": {
                "Number of samples": {
                    "value": "0",
                    "default_value": "0",
                    "documentation": "This determines how many samples are taken when using the random draw volume averaging. Setting it to zero means that the number of samples is set to be equal to the number of grains.",
                    "pattern": "253",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Random number seed": {
                    "value": "1",
                    "default_value": "1",
                    "documentation": "The seed used to generate random numbers. This will make sure that results are reproducible as long as the problem is run with the same amount of MPI processes. It is implemented as final seed = Random number seed + MPI Rank. ",
                    "pattern": "252",
                    "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
                }
            },
            "Crystal Preferred Orientation": {
                "CPO derivatives algorithm": {
                    "value": "Spin tensor",
                    "default_value": "Spin tensor",
                    "documentation": "Options: Spin tensor",
                    "pattern": "259",
                    "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
                },
                "Number of grains per particle": {
                    "value": "50",
                    "default_value": "50",
                    "documentation": "The number of grains of each different mineral each particle contains.",
                    "pattern": "255",
                    "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
                },
                "Property advection max iterations": {
                    "value": "100",
                    "default_value": "100",
                    "documentation": "The Backward Euler property advection method involve internal iterations. This option allows for setting the maximum number of iterations. Note that when the iteration is ended by the max iteration amount an assert is thrown.",
                    "pattern": "258",
                    "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
                },
                "Property advection method": {
                    "value": "Backward Euler",
                    "default_value": "Backward Euler",
                    "documentation": "Options: Forward Euler, Backward Euler",
                    "pattern": "256",
                    "pattern_description": "[Anything]"
                },
                "Property advection tolerance": {
                    "value": "1e-10",
                    "default_value": "1e-10",
                    "documentation": "The Backward Euler property advection method involve internal iterations. This option allows for setting a tolerance. When the norm of tensor new - tensor old is smaller than this tolerance, the iteration is stopped.",
                    "pattern": "257",
                    "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                },
                "Random number seed": {
                    "value": "1",
                    "default_value": "1",
                    "documentation": "The seed used to generate random numbers. This will make sure that results are reproducible as long as the problem is run with the same number of MPI processes. It is implemented as final seed = user seed + MPI Rank. ",
                    "pattern": "254",
                    "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
                },
                "D-Rex 2004": {
                    "Exponents p": {
                        "value": "1.5",
                        "default_value": "1.5",
                        "documentation": "This is exponent p as defined in equation 11 of Kaminski et al., 2004. ",
                        "pattern": "266",
                        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                    },
                    "Mobility": {
                        "value": "50",
                        "default_value": "50",
                        "documentation": "The dimensionless intrinsic grain boundary mobility for both olivine and enstatite.",
                        "pattern": "263",
                        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                    },
                    "Nucleation efficiency": {
                        "value": "5",
                        "default_value": "5",
                        "documentation": "This is the dimensionless nucleation rate as defined in equation 8 of Kaminski et al., 2004. ",
                        "pattern": "267",
                        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                    },
                    "Stress exponents": {
                        "value": "3.5",
                        "default_value": "3.5",
                        "documentation": "This is the power law exponent that characterizes the rheology of the slip systems. It is used in equation 11 of Kaminski et al., 2004.",
                        "pattern": "265",
                        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                    },
                    "Threshold GBS": {
                        "value": "0.3",
                        "default_value": "0.3",
                        "documentation": "The Dimensionless Grain Boundary Sliding (GBS) threshold. This is a grain size threshold below which grain deform by GBS and become strain-free grains.",
                        "pattern": "268",
                        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                    },
                    "Volume fractions minerals": {
                        "value": "0.5, 0.5",
                        "default_value": "0.5, 0.5",
                        "documentation": "The volume fraction for the different minerals. There need to be the same amount of values as there are minerals",
                        "pattern": "264",
                        "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
                    }
                },
                "Initial grains": {
                    "Minerals": {
                        "value": "Olivine: Karato 2008, Enstatite",
                        "default_value": "Olivine: Karato 2008, Enstatite",
                        "documentation": "This determines what minerals and fabrics or fabric selectors are used used for the LPO\/CPO calculation. The options are Olivine: Passive, A-fabric, Olivine: B-fabric, Olivine: C-fabric, Olivine: D-fabric, Olivine: E-fabric, Olivine: Karato 2008 or Enstatite. Passive sets all RRSS entries to the maximum. The Karato 2008 selector selects a fabric based on stress and water content as defined in figure 4 of the Karato 2008 review paper (doi: 10.1146\/annurev.earth.36.031207.124120).",
                        "pattern": "261",
                        "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
                    },
                    "Model name": {
                        "value": "Uniform grains and random uniform rotations",
                        "default_value": "Uniform grains and random uniform rotations",
                        "documentation": "The model used to initialize the CPO for all particles. Currently 'Uniform grains and random uniform rotations' is the only valid option.",
                        "pattern": "260",
                        "pattern_description": "[Anything]"
                    },
                    "Volume fractions minerals": {
                        "value": "0.7, 0.3",
                        "default_value": "0.7, 0.3",
                        "documentation": "The volume fractions for the different minerals. There need to be the same number of values as there are minerals.Note that the currently implemented scheme is incompressible and does not allow chemical interaction or the formation of new phases",
                        "pattern": "262",
                        "pattern_description": "[List of <[Double 0...MAX_DOUBLE (inclusive)]> of length 0...4294967295 (inclusive)]"
                    }
                }
            },
            "Function": {
                "Function constants": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                    "pattern": "251",
                    "pattern_description": "[Anything]"
                },
                "Function expression": {
                    "value": "0",
                    "default_value": "0",
                    "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                    "pattern": "250",
                    "pattern_description": "[Anything]"
                },
                "Number of components": {
                    "value": "1",
                    "default_value": "1",
                    "documentation": "The number of function components where each component is described by a function expression delimited by a ';'.",
                    "pattern": "248",
                    "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
                },
                "Variable names": {
                    "value": "x,y,t",
                    "default_value": "x,y,t",
                    "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                    "pattern": "249",
                    "pattern_description": "[Anything]"
                }
            },
            "Generator": {
                "Ascii file": {
                    "Data directory": {
                        "value": "$ASPECT_SOURCE_DIR\/data\/particle\/generator\/ascii\/",
                        "default_value": "$ASPECT_SOURCE_DIR\/data\/particle\/generator\/ascii\/",
                        "documentation": "The name of a directory that contains the particle data. This path may either be absolute (if starting with a '\/') or relative to the current directory. The path may also include the special text '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT. ",
                        "pattern": "224",
                        "pattern_description": "[DirectoryName]"
                    },
                    "Data file name": {
                        "value": "particle.dat",
                        "default_value": "particle.dat",
                        "documentation": "The name of the particle file.",
                        "pattern": "225",
                        "pattern_description": "[Anything]"
                    }
                },
                "Probability density function": {
                    "Function constants": {
                        "value": "",
                        "default_value": "",
                        "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                        "pattern": "229",
                        "pattern_description": "[Anything]"
                    },
                    "Function expression": {
                        "value": "0",
                        "default_value": "0",
                        "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                        "pattern": "228",
                        "pattern_description": "[Anything]"
                    },
                    "Random cell selection": {
                        "value": "true",
                        "default_value": "true",
                        "documentation": "If true, particle numbers per cell are calculated randomly according to their respective probability density. This means particle numbers per cell can deviate statistically from the integral of the probability density. If false, first determine how many particles each cell should have based on the integral of the density over each of the cells, and then once we know how many particles we want on each cell, choose their locations randomly within each cell.",
                        "pattern": "233",
                        "pattern_description": "[Bool]"
                    },
                    "Random number seed": {
                        "value": "5432",
                        "default_value": "5432",
                        "documentation": "The seed for the random number generator that controls the particle generation. Keep constant to generate identical particle distributions in subsequent model runs. Change to get a different distribution. In parallel computations the seed is further modified on each process to ensure different particle patterns on different processes. Note that the number of particles per processor is not affected by the seed.",
                        "pattern": "234",
                        "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
                    },
                    "Variable names": {
                        "value": "x,y,t",
                        "default_value": "x,y,t",
                        "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                        "pattern": "227",
                        "pattern_description": "[Anything]"
                    }
                },
                "Reference cell": {
                    "Number of particles per cell per direction": {
                        "value": "2",
                        "default_value": "2",
                        "documentation": "List of number of particles to create per cell and spatial dimension. The size of the list is the number of spatial dimensions. If only one value is given, then each spatial dimension is set to the same value. The list of numbers are parsed as a floating point number (so that one can specify, for example, '1e4' particles) but it is interpreted as an integer, of course.",
                        "pattern": "235",
                        "pattern_description": "[List of <[Integer range 1...2147483647 (inclusive)]> of length 0...4294967295 (inclusive)]"
                    }
                },
                "Uniform box": {
                    "Maximum x": {
                        "value": "1.",
                        "default_value": "1.",
                        "documentation": "Maximum x coordinate for the region of particles.",
                        "pattern": "208",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    },
                    "Maximum y": {
                        "value": "1.",
                        "default_value": "1.",
                        "documentation": "Maximum y coordinate for the region of particles.",
                        "pattern": "210",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    },
                    "Maximum z": {
                        "value": "1.",
                        "default_value": "1.",
                        "documentation": "Maximum z coordinate for the region of particles.",
                        "pattern": "212",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    },
                    "Minimum x": {
                        "value": "0.",
                        "default_value": "0.",
                        "documentation": "Minimum x coordinate for the region of particles.",
                        "pattern": "207",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    },
                    "Minimum y": {
                        "value": "0.",
                        "default_value": "0.",
                        "documentation": "Minimum y coordinate for the region of particles.",
                        "pattern": "209",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    },
                    "Minimum z": {
                        "value": "0.",
                        "default_value": "0.",
                        "documentation": "Minimum z coordinate for the region of particles.",
                        "pattern": "211",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    }
                },
                "Uniform radial": {
                    "Center x": {
                        "value": "0.",
                        "default_value": "0.",
                        "documentation": "x coordinate for the center of the spherical region, where particles are generated.",
                        "pattern": "214",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    },
                    "Center y": {
                        "value": "0.",
                        "default_value": "0.",
                        "documentation": "y coordinate for the center of the spherical region, where particles are generated.",
                        "pattern": "215",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    },
                    "Center z": {
                        "value": "0.",
                        "default_value": "0.",
                        "documentation": "z coordinate for the center of the spherical region, where particles are generated.",
                        "pattern": "216",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    },
                    "Maximum latitude": {
                        "value": "180.",
                        "default_value": "180.",
                        "documentation": "Maximum latitude coordinate for the region of particles in degrees. Measured from the center position, and from the north pole.",
                        "pattern": "222",
                        "pattern_description": "[Double 0...180 (inclusive)]"
                    },
                    "Maximum longitude": {
                        "value": "360.",
                        "default_value": "360.",
                        "documentation": "Maximum longitude coordinate for the region of particles in degrees. Measured from the center position.",
                        "pattern": "220",
                        "pattern_description": "[Double -180...360 (inclusive)]"
                    },
                    "Maximum radius": {
                        "value": "1.",
                        "default_value": "1.",
                        "documentation": "Maximum radial coordinate for the region of particles. Measured from the center position.",
                        "pattern": "218",
                        "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                    },
                    "Minimum latitude": {
                        "value": "0.",
                        "default_value": "0.",
                        "documentation": "Minimum latitude coordinate for the region of particles in degrees. Measured from the center position, and from the north pole.",
                        "pattern": "221",
                        "pattern_description": "[Double 0...180 (inclusive)]"
                    },
                    "Minimum longitude": {
                        "value": "0.",
                        "default_value": "0.",
                        "documentation": "Minimum longitude coordinate for the region of particles in degrees. Measured from the center position.",
                        "pattern": "219",
                        "pattern_description": "[Double -180...360 (inclusive)]"
                    },
                    "Minimum radius": {
                        "value": "0.",
                        "default_value": "0.",
                        "documentation": "Minimum radial coordinate for the region of particles. Measured from the center position.",
                        "pattern": "217",
                        "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
                    },
                    "Radial layers": {
                        "value": "1",
                        "default_value": "1",
                        "documentation": "The number of radial shells of particles that will be generated around the central point.",
                        "pattern": "223",
                        "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
                    }
                }
            },
            "Integrator": {
                "RK2": {
                    "Higher order accurate in time": {
                        "value": "true",
                        "default_value": "true",
                        "documentation": "Whether to correctly evaluate old and current velocity solution to reach higher-order accuracy in time. If set to 'false' only the old velocity solution is evaluated to simulate a first order method in time. This is only recommended for benchmark purposes.",
                        "pattern": "237",
                        "pattern_description": "[Bool]"
                    }
                }
            },
            "Interpolator": {
                "Bilinear least squares": {
                    "Use boundary extrapolation": {
                        "value": "false",
                        "default_value": "false",
                        "documentation": "Extends the range used by 'Use linear least squares limiter' by linearly interpolating values at cell boundaries from neighboring cells. If more than one value is given, it will be treated as a list with one component per particle property. Enabling 'Use boundary extrapolation' requires enabling 'Use linear least squares limiter'.",
                        "pattern": "244",
                        "pattern_description": "[List of <[Bool]> of length 0...4294967295 (inclusive)]"
                    },
                    "Use linear least squares limiter": {
                        "value": "false",
                        "default_value": "false",
                        "documentation": "Limit the interpolation of particle properties onto the cell, so that the value of each property is no smaller than its minimum and no larger than its maximum on the particles of each cell, and the average of neighboring cells. If more than one value is given, it will be treated as a list with one component per particle property.",
                        "pattern": "243",
                        "pattern_description": "[List of <[Bool]> of length 0...4294967295 (inclusive)]"
                    }
                },
                "Quadratic least squares": {
                    "Use boundary extrapolation": {
                        "value": "false",
                        "default_value": "false",
                        "documentation": "Extends the range used by 'Use quadratic least squares limiter' by linearly interpolating values at cell boundaries from neighboring cells. If more than one value is given, it will be treated as a list with one component per particle property. Enabling 'Use boundary extrapolation' requires enabling 'Use quadratic least squares limiter'.",
                        "pattern": "242",
                        "pattern_description": "[List of <[Bool]> of length 0...4294967295 (inclusive)]"
                    },
                    "Use quadratic least squares limiter": {
                        "value": "true",
                        "default_value": "true",
                        "documentation": "Limit the interpolation of particle properties onto the cell, so that the value of each property is no smaller than its minimum and no larger than its maximum on the particles of each cell, and the average of neighboring cells. If more than one value is given, it will be treated as a list with one component per particle property.",
                        "pattern": "241",
                        "pattern_description": "[List of <[Bool]> of length 0...4294967295 (inclusive)]"
                    }
                }
            },
            "Melt particle": {
                "Threshold for melt presence": {
                    "value": "1e-3",
                    "default_value": "1e-3",
                    "documentation": "The minimum porosity that has to be present at the position of a particle for it to be considered a melt particle (in the sense that the melt presence property is set to 1).",
                    "pattern": "247",
                    "pattern_description": "[Double 0...1 (inclusive)]"
                }
            }
        },
        "Point values": {
            "Evaluation points": {
                "value": "",
                "default_value": "",
                "documentation": "The list of points at which the solution should be evaluated. Points need to be separated by semicolons, and coordinates of each point need to be separated by commas.",
                "pattern": "179",
                "pattern_description": "[List of <[List of <[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]> of length 2...2 (inclusive)]> of length 0...4294967295 (inclusive) separated by <;>]"
            },
            "Time between point values output": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The time interval between each generation of point values output. A value of zero indicates that output should be generated in each time step. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "178",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Use natural coordinates": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether or not the Evaluation points are specified in the natural coordinates of the geometry model, e.g. radius, lon, lat for the chunk model. Currently, natural coordinates for the spherical shell and sphere geometries are not supported. ",
                "pattern": "180",
                "pattern_description": "[Bool]"
            }
        },
        "Rotation statistics": {
            "Output full moment of inertia tensor": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to write the full moment of inertia tensor into the statistics output instead of its norm for the current rotation axis. This is a second-order symmetric tensor with 6 components in 3d. In 2d this option has no effect, because the rotation axis is fixed and thus the moment of inertia is always a scalar.",
                "pattern": "182",
                "pattern_description": "[Bool]"
            },
            "Use constant density of one": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to use a constant density of one for the computation of the angular momentum and moment of inertia. This is an approximation that assumes that the 'volumetric' rotation is equal to the 'mass' rotation. If this parameter is true this postprocessor computes 'net rotation' instead of 'angular momentum'.",
                "pattern": "181",
                "pattern_description": "[Bool]"
            }
        },
        "Sea level": {
            "Data directory ice height": {
                "value": "$ASPECT_SOURCE_DIR\/data\/postprocess\/sea-level\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/postprocess\/sea-level\/",
                "documentation": "The name of a directory that contains the ice height [m] ascii data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "187",
                "pattern_description": "[DirectoryName]"
            },
            "Data directory topography": {
                "value": "$ASPECT_SOURCE_DIR\/data\/postprocess\/sea-level\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/postprocess\/sea-level\/",
                "documentation": "The name of a directory that contains the topography ascii data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "185",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name ice height": {
                "value": "shell_3d_ice_top.0.txt",
                "default_value": "shell_3d_ice_top.0.txt",
                "documentation": "The file name of the ice height ascii data. For the ascii data, provide file in the same format as described in 'ascii data' initial composition plugin.",
                "pattern": "188",
                "pattern_description": "[Anything]"
            },
            "Data file name topography": {
                "value": "shell_3d_topo_top.0.txt",
                "default_value": "shell_3d_topo_top.0.txt",
                "documentation": "The file name of the topography ascii data. For the ascii data, provide file in the same format as described in 'ascii data' initial composition plugin.",
                "pattern": "186",
                "pattern_description": "[Anything]"
            },
            "Ice density": {
                "value": "931",
                "default_value": "931",
                "documentation": "The density of ice [kg\/m3]",
                "pattern": "183",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Output to file": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether or not to write sea level to a text file named named 'sea_level.NNNNN' in the output directory",
                "pattern": "189",
                "pattern_description": "[List of <[Bool]> of length 0...4294967295 (inclusive)]"
            },
            "Time between text output": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The time interval between each generation of text output files. A value of zero indicates that output should be generated in each time step. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "190",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Water density": {
                "value": "1000",
                "default_value": "1000",
                "documentation": "The density of water [kg\/m3]",
                "pattern": "184",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Topography": {
            "Output to file": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether or not to write topography to a text file named named 'topography.NNNNN' in the output directory",
                "pattern": "191",
                "pattern_description": "[Bool]"
            },
            "Time between text output": {
                "value": "0.",
                "default_value": "0.",
                "documentation": "The time interval between each generation of text output files. A value of zero indicates that output should be generated in each time step. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "192",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Visualization": {
            "Filter output": {
                "value": "false",
                "default_value": "false",
                "documentation": "deal.II offers the possibility to filter duplicate vertices for HDF5 output files. This merges the vertices of adjacent cells and therefore saves disk space, but misrepresents discontinuous output properties. Activating this function reduces the disk space by about a factor of $2^{dim}$ for HDF5 output, and currently has no effect on other output formats. \\note{\\textbf{Warning:} Setting this flag to true will result in visualization output that does not accurately represent discontinuous fields. This may be because you are using a discontinuous finite element for the pressure, temperature, or compositional variables, or because you use a visualization postprocessor that outputs quantities as discontinuous fields (e.g., the strain rate, viscosity, etc.). These will then all be visualized as \\textit{continuous} quantities even though, internally, \\aspect{} considers them as discontinuous fields.}",
                "pattern": "139",
                "pattern_description": "[Bool]"
            },
            "Interpolate output": {
                "value": "true",
                "default_value": "true",
                "documentation": "deal.II offers the possibility to linearly interpolate output fields of higher order elements to a finer resolution. This somewhat compensates the fact that most visualization software only offers linear interpolation between grid points and therefore the output file is a very coarse representation of the actual solution field. Activating this option increases the spatial resolution in each dimension by a factor equal to the polynomial degree used for the velocity finite element (usually 2). In other words, instead of showing one quadrilateral or hexahedron in the visualization per cell on which \\aspect{} computes, it shows multiple (for quadratic elements, it will describe each cell of the mesh on which we compute as $2\\times 2$ or $2\\times 2\\times 2$ cells in 2d and 3d, respectively; correspondingly more subdivisions are used if you use cubic, quartic, or even higher order elements for the velocity).\n\nThe effect of using this option can be seen in the following picture showing a variation of the output produced with the input files from Section~\\ref{sec:shell-simple-2d}:\n\n\\begin{center}  \\includegraphics[width=0.5\\textwidth]{viz\/parameters\/build-patches}\\end{center}Here, the left picture shows one visualization cell per computational cell (i.e., the option is switched off), and the right picture shows the same simulation with the option switched on (which is the default). The images show the same data, demonstrating that interpolating the solution onto bilinear shape functions as is commonly done in visualizing data loses information.\n\nOf course, activating this option also greatly increases the amount of data \\aspect{} will write to disk: approximately by a factor of 4 in 2d, and a factor of 8 in 3d, when using quadratic elements for the velocity, and correspondingly more for even higher order elements.",
                "pattern": "136",
                "pattern_description": "[Bool]"
            },
            "List of output variables": {
                "value": "material properties",
                "default_value": "",
                "documentation": "A comma separated list of visualization objects that should be run whenever writing graphical output. By default, the graphical output files will always contain the primary variables velocity, pressure, and temperature. However, one frequently wants to also visualize derived quantities, such as the thermodynamic phase that corresponds to a given temperature-pressure value, or the corresponding seismic wave speeds. The visualization objects do exactly this: they compute such derived quantities and place them into the output file. The current parameter is the place where you decide which of these additional output variables you want to have in your output file.\n\nThe following postprocessors are available:\n\n`ISA rotation timescale': A visualization output object that generates output showing the timescale for the rotation of grains toward the infinite strain axis. Kaminski and Ribe (see \\cite{Kaminski2002}) call this quantity $\\tau_\\text{ISA}$ and define it as $\\tau_\\text{ISA} \\approx \\frac{1}{\\dot{\\epsilon}}$ where $\\dot{\\epsilon}$ is the largest eigenvalue of the strain rate tensor. It can be used, along with the grain lag angle $\\Theta$, to calculate the grain orientation lag parameter.\n\nPhysical units: \\si{\\second}.\n\n`Vp anomaly': A visualization output object that generates output showing the percentage anomaly in the seismic compressional wave speed $V_p$ as a spatially variable function with one value per cell. This anomaly is either shown as a percentage anomaly relative to the reference profile given by adiabatic conditions (with the compositions given by the current composition, such that the reference could potentially change through time), or as a percentage change relative to the laterally averaged velocity at the depth of the cell. This velocity is calculated by linear interpolation between average values calculated within equally thick depth slices. The number of depth slices in the domain is user-defined. Typically, the best results will be obtained if the number of depth slices is balanced between being large enough to capture step changes in velocities, but small enough to maintain a reasonable number of evaluation points per slice. Bear in mind that lateral averaging subsamples the finite element mesh. Note that this plugin requires a material model that provides seismic velocities.\n\nPhysical units: None, the quantity being output is a fractional change provided as a percentage.\n\n`Vs anomaly': A visualization output object that generates output showing the percentage anomaly in the seismic shear wave speed $V_s$ as a spatially variable function with one value per cell. This anomaly is either shown as a percentage anomaly relative to the reference profile given by adiabatic conditions (with the compositions given by the current composition, such that the reference could potentially change through time), or as a percentage change relative to the laterally averaged velocity at the depth of the cell. This velocity is calculated by linear interpolation between average values calculated within equally thick depth slices. The number of depth slices in the domain is user-defined. Typically, the best results will be obtained if the number of depth slices is balanced between being large enough to capture step changes in velocities, but small enough to maintain a reasonable number of evaluation points per slice. Bear in mind that lateral averaging subsamples the finite element mesh. Note that this plugin requires a material model that provides seismic velocities.\n\nPhysical units: None, the quantity being output is a fractional change provided as a percentage.\n\n`adiabat': A visualization output object that generates adiabatic temperature, pressure, density, and density derivative (with regard to depth)as produced by the \\texttt{AdiabaticConditions} class.\n\nPhysical units: \\si{\\kelvin}, \\si{\\pascal}, \\si{\\kilo\\gram\\per\\meter\\cubed\\per\\meter}, respectively, for the four components.\n\n`artificial viscosity': A visualization output object that generates output showing the value of the artificial viscosity on each cell.\n\nPhysical units: \\si{\\watt\\per\\meter\\per\\kelvin}.\n\n`artificial viscosity composition': A visualization output object that generates output showing the value of the artificial viscosity for a compositional field on each cell.\n\nPhysical units: \\si{\\meter\\squared\\per\\second}.\n\n`boundary indicators': A visualization output object that generates output about the used boundary indicators. In a loop over the active cells, if a cell lies at a domain boundary, the boundary indicator of the face along the boundary is requested. In case the cell does not lie along any domain boundary, the cell is assigned the value of the largest used boundary indicator plus one. When a cell is situated in one of the corners of the domain, multiple faces will have a boundary indicator. This postprocessor returns the value of the first face along a boundary that is encountered in a loop over all the faces.\n\nPhysical units: None.\n\n`boundary strain rate residual': A visualization output object that generates output for the strain rate residual at the top surface. The residual is computed at each point at the surface as the difference between the strain rate invariant in the model and the input data, where the invariant is computed like in the 'strain rate' postprocessor. The user chooses the input data as ascii data files with coordinate columns and column corresponding to the surface strain rate norm.\n\nPhysical units: $\\frac{1}{\\text{s}}$ or $\\frac{1}{\\text{year}}$, depending on settings in the input file.\n\n`boundary velocity residual': A visualization output object that generates output for the velocity residual at the top surface. The residual is computed at each point at the surface as the difference between the modeled velocities and the input data velocities for each vector component. The user has an option to choose the input data as ascii data files (e.g. GPS velocities) with columns in the same format as described for the 'ascii data' initial temperature plugin or a velocity field computed from the GPlates program as described in the gplates boundary velocity plugin.\n\nPhysical units: $\\frac{\\text{m}}{\\text{s}}$ or $\\frac{\\text{m}}{\\text{year}}$, depending on settings in the input file.\n\n`compositional vector': A visualization output object that outputs vectors whose components are derived from compositional fields. Input parameters for this postprocessor are defined in section Postprocess\/Visualization\/Compositional fields as vectors.\n\nPhysical units: None.\n\n`depth': A visualization output postprocessor that outputs the depth for all points inside the domain, as determined by the geometry model.\n\nPhysical units: \\si{\\meter}.\n\n`dynamic topography': A visualization output object that generates output for the dynamic topography at the top and bottom of the model space. The approach to determine the dynamic topography requires us to compute the stress tensor and evaluate the component of it in the direction in which gravity acts. In other words, we compute $\\sigma_{rr}={\\hat g}^T(2 \\eta \\varepsilon(\\mathbf u)-\\frac 13 (\\textrm{div}\\;\\mathbf u)I)\\hat g - p_d$ where $\\hat g = \\mathbf g\/\\|\\mathbf g\\|$ is the direction of the gravity vector $\\mathbf g$ and $p_d=p-p_a$ is the dynamic pressure computed by subtracting the adiabatic pressure $p_a$ from the total pressure $p$ computed as part of the Stokes solve. From this, the dynamic topography is computed using the formula $h=\\frac{\\sigma_{rr}}{(\\mathbf g \\cdot \\mathbf n)  \\rho}$ where $\\rho$ is the density at the cell center. For the bottom surface we chose the convection that positive values are up (out) and negative values are in (down), analogous to the deformation of the upper surface. Note that this implementation takes the direction of gravity into account, which means that reversing the flow in backward advection calculations will not reverse the instantaneous topography because the reverse flow will be divided by the reverse surface gravity.\n\nStrictly speaking, the dynamic topography is of course a quantity that is only of interest at the surface. However, we compute it everywhere to make things fit into the framework within which we produce data for visualization. You probably only want to visualize whatever data this postprocessor generates at the surface of your domain and simply ignore the rest of the data generated.\n\nAlternatively, consider using the \"surface dynamic topography\" visualization postprocessor to only output the dynamic topography at the boundary of the domain.\n\nPhysical units: \\si{\\meter}.\n\n`error indicator': A visualization output object that generates output showing the estimated error or other mesh refinement indicator as a spatially variable function with one value per cell.\n\nPhysical units: None. (Strictly speaking, errors have physical units of course, but because error \\textit{indicators} can be computed from different solution components and other input, we consider error indicators unitless.)\n\n`geoid': Visualization for the geoid solution. The geoid is given by the equivalent water column height due to a gravity perturbation. \n\nPhysical units: \\si{\\meter}.\n\n`grain lag angle': A visualization output object that generates output showing the angle between the ~infinite strain axis and the flow velocity. Kaminski and Ribe (see \\cite{Kaminski2002}) call this quantity $\\Theta$ and define it as $\\Theta = \\cos^{-1}(\\hat{u}\\cdot\\hat{e})$  where $\\hat{u}=\\vec{u}\/|{u}|$, $\\vec{u}$ is the local flow velocity, and $\\hat{e}$ is the local infinite strain axis, which we calculate as the first eigenvector of the 'left stretch' tensor. $\\Theta$ can be used to calculate the grain orientation lag parameter.\n\nPhysical units: \\si{\\radian}.\n\n`gravity': A visualization output object that outputs the gravity vector.\n\nPhysical units: \\si {\\meter\\per\\second\\squared} .\n\n`heat flux map': A visualization output object that generates output for the heat flux density across the top and bottom boundary in outward direction. The heat flux is computed as sum of advective heat flux and conductive heat flux through Neumann boundaries, both computed as integral over the boundary area, and conductive heat flux through Dirichlet boundaries, which is computed using the consistent boundary flux method as described in ``Gresho, Lee, Sani, Maslanik, Eaton (1987). The consistent Galerkin FEM for computing derived boundary quantities in thermal and or fluids problems. International Journal for Numerical Methods in Fluids, 7(4), 371-394.'' If only conductive heat flux through Dirichlet boundaries is of interest, the postprocessor can produce output of higher resolution by evaluating the CBF solution vector point-wise instead of computing cell-wise averaged values.\n\nPhysical units: \\si{\\watt\\per\\meter\\squared}.\n\n`heating': A visualization output object that generates output for all the heating terms used in the energy equation.\n\nPhysical units: \\si{\\watt\\per\\cubic\\meter}.\n\n`material properties': A visualization output object that generates output for the material properties given by the material model. The current postprocessor allows to output a (potentially large) subset of all of the information provided by material models at once, with just a single material model evaluation per output point. Although individual properties can still be listed in the ``List of output variables'', this visualization plugin is called internally to avoid duplicated evaluations of the material model. \n\nIn almost all places inside \\aspect{}, the program can use ``averaged'' material properties, for example for the assembly of matrices and right hand side vectors. To accurately reflect the material parameters used internally, this visualization postprocessor averages in the same way as is used to do the assembly, and consequently the graphical output will reflect not pointwise properties, but averaged properties.\n\nPhysical units: Various.\n\n`maximum horizontal compressive stress': A plugin that computes the direction and magnitude of the maximum horizontal component of the compressive stress as a vector field. The direction of this vector can often be used to visualize the principal mode of deformation (e.g., at normal faults or extensional margins) and can be correlated with seismic anisotropy. Recall that the \\textit{compressive} stress is simply the negative stress, $\\sigma_c=-\\sigma=-\\left[     2\\eta (\\varepsilon(\\mathbf u)             - \\frac 13 (\\nabla \\cdot \\mathbf u) I)     + pI\\right]$.\n\nFollowing \\cite{LundTownend07}, we define the maximum horizontal stress direction as that \\textit{horizontal} direction $\\mathbf n$ that maximizes $\\mathbf n^T \\sigma_c \\mathbf n$. We call a vector \\textit{horizontal} if it is perpendicular to the gravity vector $\\mathbf g$.\n\nIn two space dimensions, $\\mathbf n$ is simply a vector that is horizontal (we choose one of the two possible choices). This direction is then scaled by the size of the horizontal stress in this direction, i.e., the plugin outputs the vector $\\mathbf w = (\\mathbf n^T \\sigma_c \\mathbf n) \\; \\mathbf n$.\n\nIn three space dimensions, given two horizontal, perpendicular, unit length, but otherwise arbitrarily chosen vectors $\\mathbf u,\\mathbf v$, we can express $\\mathbf n = (\\cos \\alpha)\\mathbf u + (\\sin\\alpha)\\mathbf v$ where $\\alpha$ maximizes the expression \\begin{align*}  f(\\alpha) = \\mathbf n^T \\sigma_c \\mathbf n  = (\\mathbf u^T \\sigma_c \\mathbf u)(\\cos\\alpha)^2    +2(\\mathbf u^T \\sigma_c \\mathbf v)(\\cos\\alpha)(\\sin\\alpha)    +(\\mathbf v^T \\sigma_c \\mathbf v)(\\sin\\alpha)^2.\\end{align*}\n\nThe maximum of $f(\\alpha)$ is attained where $f^\\prime(\\alpha)=0$. Evaluating the derivative and using trigonometric identities, one finds that $\\alpha$ has to satisfy the equation \\begin{align*}  \\tan(2\\alpha) = \\frac{2.0\\mathbf u^T \\sigma_c \\mathbf v}                          {\\mathbf u^T \\sigma_c \\mathbf u                            - \\mathbf v^T \\sigma_c \\mathbf v}.\\end{align*}Since the transform $\\alpha\\mapsto\\alpha+\\pi$ flips the direction of $\\mathbf n$, we only need to seek a solution to this equation in the interval $\\alpha\\in[0,\\pi)$. These are given by $\\alpha_1=\\frac 12 \\arctan \\frac{\\mathbf u^T \\sigma_c \\mathbf v}{\\mathbf u^T \\sigma_c \\mathbf u - \\mathbf v^T \\sigma_c \\mathbf v}$ and $\\alpha_2=\\alpha_1+\\frac{\\pi}{2}$, one of which will correspond to a minimum and the other to a maximum of $f(\\alpha)$. One checks the sign of $f^{\\prime\\prime}(\\alpha)=-2(\\mathbf u^T \\sigma_c \\mathbf u - \\mathbf v^T \\sigma_c \\mathbf v)\\cos(2\\alpha) - 2 (\\mathbf u^T \\sigma_c \\mathbf v) \\sin(2\\alpha)$ for each of these to determine the $\\alpha$ that maximizes $f(\\alpha)$, and from this immediately arrives at the correct form for the maximum horizontal stress $\\mathbf n$.\n\nThe description above computes a 3d \\textit{direction} vector $\\mathbf n$. If one were to scale this vector the same way as done in 2d, i.e., with the magnitude of the stress in this direction, one will typically get vectors whose length is principally determined by the hydrostatic pressure at a given location simply because the hydrostatic pressure is the largest component of the overall stress. On the other hand, the hydrostatic pressure does not determine any principal direction because it is an isotropic, anti-compressive force. As a consequence, there are often points in simulations (e.g., at the center of convection rolls) where the stress has no dominant horizontal direction, and the algorithm above will then in essence choose a random direction because the stress is approximately equal in all horizontal directions. If one scaled the output by the magnitude of the stress in this direction (i.e., approximately equal to the hydrostatic pressure at this point), one would get randomly oriented vectors at these locations with significant lengths.\n\nTo avoid this problem, we scale the maximal horizontal compressive stress direction $\\mathbf n$ by the \\textit{difference} between the stress in the maximal and minimal horizontal stress directions. In other words, let $\\mathbf n_\\perp=(\\sin \\alpha)\\mathbf u - (\\cos\\alpha)\\mathbf v$ be the horizontal direction perpendicular to $\\mathbf n$, then this plugin outputs the vector quantity $\\mathbf w = (\\mathbf n^T \\sigma_c \\mathbf n                -\\mathbf n^T_\\perp \\sigma_c \\mathbf n_\\perp)               \\; \\mathbf n$. In other words, the length of the vector produced indicates \\textit{how dominant} the direction of maximal horizontal compressive strength is.\n\nFig.~\\ref{fig:max-horizontal-compressive-stress} shows a simple example for this kind of visualization in 3d.\n\n\\begin{figure}  \\includegraphics[width=0.3\\textwidth]    {viz\/plugins\/maximum_horizontal_compressive_stress\/temperature.png}  \\hfill  \\includegraphics[width=0.3\\textwidth]    {viz\/plugins\/maximum_horizontal_compressive_stress\/velocity.png}  \\hfill  \\includegraphics[width=0.3\\textwidth]    {viz\/plugins\/maximum_horizontal_compressive_stress\/horizontal-stress.png}  \\caption{\\it Illustration of the `maximum horizontal     compressive stress' visualization plugin. The left     figure shows a ridge-like temperature anomaly. Together     with no-slip boundary along all six boundaries, this     results in two convection rolls (center). The maximal     horizontal compressive strength at the bottom center     of the domain is perpendicular to the ridge because     the flow comes together there from the left and right,     yielding a compressive force in left-right direction.     At the top of the model, the flow separates outward,     leading to a \\textit{negative} compressive stress     in left-right direction; because there is no flow     in front-back direction, the compressive strength     in front-back direction is zero, making the along-ridge     direction the dominant one. At the center of the     convection rolls, both horizontal directions yield     the same stress; the plugin therefore chooses an     essentially arbitrary horizontal vector, but then     uses a zero magnitude given that the difference     between the maximal and minimal horizontal stress     is zero at these points.}  \\label{fig:max-horizontal-compressive-stress}\\end{figure}\n\nPhysical units: \\si{\\pascal}.\n\n`melt fraction': A visualization output object that generates output for the melt fraction at the temperature and pressure of the current point. If the material model computes a melt fraction, this is the quantity that will be visualized. Otherwise, a specific parametrization for batch melting (as described in the following) will be used. It does not take into account latent heat. If there are no compositional fields, or no fields called 'pyroxenite',  this postprocessor will visualize the melt fraction of peridotite (calculated using the anhydrous model of Katz, 2003). If there is a compositional field called 'pyroxenite', the postprocessor assumes that this compositional field is the content of pyroxenite, and will visualize the melt fraction for a mixture of peridotite and pyroxenite (using the melting model of Sobolev, 2011 for pyroxenite). All the parameters that were used in these calculations can be changed in the input file, the most relevant maybe being the mass fraction of Cpx in peridotite in the Katz melting model (Mass fraction cpx), which right now has a default of 15\\%. The corresponding $p$-$T$-diagrams can be generated by running the tests melt\\_postprocessor\\_peridotite and melt\\_postprocessor\\_pyroxenite.\n\nPhysical units: None.\n\n`melt material properties': A visualization output object that generates output for melt related properties of the material model. Note that this postprocessor always outputs the compaction pressure, but can output a large range of additional properties, as selected in the ``List of properties'' parameter.\n\nPhysical units: Various, depending on what is being output.\n\n`named additional outputs': Some material models can compute quantities other than those that typically appear in the equations that \\aspect{} solves (such as the viscosity, density, etc). Examples of quantities material models may be able to compute are seismic velocities, or other quantities that can be derived from the state variables and the material coefficients such as the stress or stress anisotropies. These quantities are generically referred to as `named outputs' because they are given an explicit name different from the usual outputs of material models.\n\nThis visualization postprocessor outputs whatever quantities the material model can compute. What quantities these are is specific to the material model in use for a simulation, and for many models in fact does not contain any named outputs at all.\n\nPhysical units: Various, depending on what is being output.\n\n`nonadiabatic pressure': A visualization output object that generates output for the non-adiabatic component of the pressure.\n\nThe variable that is outputted this way is computed by taking the pressure at each point and subtracting from it the adiabatic pressure computed at the beginning of the simulation. Because the adiabatic pressure is one way of defining a static pressure background field, what this visualization postprocessor therefore produces is \\textit{one} way to compute a \\textit{dynamic pressure}. There are, however, other ways as well, depending on the choice of the ``background pressure''.\n\nPhysical units: \\si{\\pascal}.\n\n`nonadiabatic temperature': A visualization output object that generates output for the non-adiabatic component of the temperature.\n\nPhysical units: \\si{\\kelvin}.\n\n`particle count': A visualization output object that generates output about the number of particles per cell.\n\nPhysical units: None.\n\n`partition': A visualization output object that generates output for the parallel partition that every cell of the mesh is associated with.\n\nPhysical units: None.\n\n`principal stress': A visualization output object that outputs the principal stress values and directions, i.e., the eigenvalues and eigenvectors of the stress tensor. The postprocessor can either operate on the full stress tensor or only on the deviatoric stress tensor, depending on what run-time parameters are set.\n\nPhysical units: \\si{\\pascal}.\n\n`shear stress': A visualization output object that generates output for the 3 (in 2d) or 6 (in 3d) components of the shear stress tensor, i.e., for the components of the tensor $-2\\eta\\varepsilon(\\mathbf u)$ in the incompressible case and $-2\\eta\\left[\\varepsilon(\\mathbf u)-\\tfrac 13(\\textrm{tr}\\;\\varepsilon(\\mathbf u))\\mathbf I\\right]$ in the compressible case. If elasticity is used, the elastic contribution is being accounted for. The shear stress differs from the full stress tensor by the absence of the pressure. Note that the convention of positive compressive stress is followed.\n\nPhysical units: \\si{\\pascal}.\n\n`spd factor': A visualization output object that generates output for the spd factor. The spd factor is a factor which scales a part of the Jacobian used for the Newton solver to make sure that the Jacobian remains positive definite.\n\nPhysical units: None.\n\n`spherical velocity components': A visualization output object that outputs the polar coordinates components $v_r$ and $v_\\phi$ of the velocity field in 2d and the spherical coordinates components $v_r$, $v_{\\phi}$ and $v_{\\theta}$ of the velocity field in 3d.\n\nPhysical units: $\\frac{\\text{m}}{\\text{s}}$ or $\\frac{\\text{m}}{\\text{year}}$, depending on settings in the input file.\n\n`strain rate': A visualization output object that generates output for the norm of the strain rate, i.e., for the quantity $\\sqrt{\\varepsilon(\\mathbf u):\\varepsilon(\\mathbf u)}$ in the incompressible case and $\\sqrt{[\\varepsilon(\\mathbf u)-\\tfrac 13(\\textrm{tr}\\;\\varepsilon(\\mathbf u))\\mathbf I]:[\\varepsilon(\\mathbf u)-\\tfrac 13(\\textrm{tr}\\;\\varepsilon(\\mathbf u))\\mathbf I]}$ in the compressible case.\n\nPhysical units: \\si{\\per\\second}.\n\n`strain rate tensor': A visualization output object that generates output for the 4 (in 2d) or 9 (in 3d) components of the strain rate tensor, i.e., for the components of the tensor $\\varepsilon(\\mathbf u)$ in the incompressible case and $\\varepsilon(\\mathbf u)-\\tfrac 13(\\textrm{tr}\\;\\varepsilon(\\mathbf u))\\mathbf I$ in the compressible case.\n\nPhysical units: \\si{\\per\\second}.\n\n`stress': A visualization output object that generates output for the 3 (in 2d) or 6 (in 3d) components of the stress tensor, i.e., for the components of the tensor $-2\\eta\\varepsilon(\\mathbf u)+pI$ in the incompressible case and $-2\\eta\\left[\\varepsilon(\\mathbf u)-\\tfrac 13(\\textrm{tr}\\;\\varepsilon(\\mathbf u))\\mathbf I\\right]+pI$ in the compressible case. If elasticity is used, the elastic contribution is being accounted for. Note that the convention of positive compressive stress is followed.\n\nPhysical units: \\si{\\pascal}.\n\n`stress second invariant': A visualization output object that outputs the second moment invariant of the deviatoric stress tensor.\n\nPhysical units: \\si{\\pascal}.\n\n`surface dynamic topography': A visualization output object that generates output for the dynamic topography at the top and bottom of the model space. The approach to determine the dynamic topography requires us to compute the stress tensor and evaluate the component of it in the direction in which gravity acts. In other words, we compute $\\sigma_{rr}={\\hat g}^T(2 \\eta \\varepsilon(\\mathbf u)-\\frac 13 (\\textrm{div}\\;\\mathbf u)I)\\hat g - p_d$ where $\\hat g = \\mathbf g\/\\|\\mathbf g\\|$ is the direction of the gravity vector $\\mathbf g$ and $p_d=p-p_a$ is the dynamic pressure computed by subtracting the adiabatic pressure $p_a$ from the total pressure $p$ computed as part of the Stokes solve. From this, the dynamic topography is computed using the formula $h=\\frac{\\sigma_{rr}}{(\\mathbf g \\cdot \\mathbf n)  \\rho}$ where $\\rho$ is the density at the cell center. For the bottom surface we chose the convection that positive values are up (out) and negative values are in (down), analogous to the deformation of the upper surface. Note that this implementation takes the direction of gravity into account, which means that reversing the flow in backward advection calculations will not reverse the instantaneous topography because the reverse flow will be divided by the reverse surface gravity.\n\nIn contrast to the `dynamic topography' visualization postprocessor, this plugin really only evaluates the dynamic topography at faces of cells that are adjacent to `bottom' and `top' boundaries, and only outputs information on the surface of the domain, rather than padding the information with zeros in the interior of the domain.\n\nPhysical units: \\si{\\meter}.\n\n`surface strain rate tensor': A visualization output object that generates output on the surface of the domain for the 4 (in 2d) or 9 (in 3d) components of the strain rate tensor, i.e., for the components of the tensor $\\varepsilon(\\mathbf u)$ in the incompressible case and $\\varepsilon(\\mathbf u)-\\tfrac 13(\\textrm{tr}\\;\\varepsilon(\\mathbf u))\\mathbf I$ in the compressible case.Note that both in 2d and in 3d the output tensor will have 9 elements, but that in 2d, only 4 are filled. \n\nPhysical units: \\si{\\per\\second}.\n\n`surface stress': A visualization output object that generates output on the surface of the domain for the 3 (in 2d) or 6 (in 3d) components of the stress tensor, i.e., for the components of the tensor $-2\\eta\\varepsilon(\\mathbf u)+pI$ in the incompressible case and $-2\\eta\\left[\\varepsilon(\\mathbf u)-\\tfrac 13(\\textrm{tr}\\;\\varepsilon(\\mathbf u))\\mathbf I\\right]+pI$ in the compressible case. If elasticity is included, its contribution is accounted for. Note that the convention of positive compressive stress is followed.The stress outputted on the surface of the domain will equal the stress on the surface of the volume output if the parameter 'Point-wise stress and strain' in the Visualization subsection is set to true. \n\nPhysical units: \\si{\\pascal}.\n\n`temperature anomaly': A visualization output postprocessor that outputs the temperature minus the depth-average of the temperature.The average temperature is calculated using the lateral averaging function from the ``depth average'' postprocessor and interpolated linearly between the layers specified through ``Number of depth slices''.\n\nPhysical units: \\si{\\kelvin}.\n\n`vertical heat flux': A visualization output object that generates output for the heat flux in the vertical direction, which is the sum of the advective and the conductive heat flux, with the sign convention of positive flux upwards.\n\nPhysical units: \\si{\\watt\\per\\square\\meter}.\n\n`volume of fluid values': A visualization output object that outputs the volume fraction and optionally a level set field and the interface normal vectors of volume of fluid fields.\n\nPhysical units: None.\n\n`volumetric strain rate': A visualization output object that generates output for the volumetric strain rate, i.e., for the quantity $\\nabla\\cdot\\mathbf u = \\textrm{div}\\; \\mathbf u = \\textrm{trace}\\; \\varepsilon(\\mathbf u)$. This should be zero (in some average sense) in incompressible convection models, but can be non-zero in compressible models and models with melt transport.\n\nPhysical units: \\si{\\per\\second}.",
                "pattern": "143",
                "pattern_description": "[MultipleSelection ISA rotation timescale|Vp anomaly|Vs anomaly|adiabat|artificial viscosity|artificial viscosity composition|boundary indicators|boundary strain rate residual|boundary velocity residual|compositional vector|depth|dynamic topography|error indicator|geoid|grain lag angle|gravity|heat flux map|heating|material properties|maximum horizontal compressive stress|melt fraction|melt material properties|named additional outputs|nonadiabatic pressure|nonadiabatic temperature|particle count|partition|principal stress|shear stress|spd factor|spherical velocity components|strain rate|strain rate tensor|stress|stress second invariant|surface dynamic topography|surface strain rate tensor|surface stress|temperature anomaly|vertical heat flux|volume of fluid values|volumetric strain rate|density|specific heat|thermal conductivity|thermal diffusivity|thermal expansivity|viscosity ]"
            },
            "Number of grouped files": {
                "value": "16",
                "default_value": "16",
                "documentation": "VTU file output supports grouping files from several CPUs into a given number of files using MPI I\/O when writing on a parallel filesystem. Select 0 for no grouping. This will disable parallel file output and instead write one file per processor. A value of 1 will generate one big file containing the whole solution, while a larger value will create that many files (at most as many as there are MPI ranks).",
                "pattern": "133",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Output format": {
                "value": "vtu",
                "default_value": "vtu",
                "documentation": "The file format to be used for graphical output. The list of possible output formats that can be given here is documented in the appendix of the manual where the current parameter is described.",
                "pattern": "132",
                "pattern_description": "[Selection none|dx|ucd|gnuplot|povray|eps|gmv|tecplot|vtk|vtu|hdf5|svg|deal.II intermediate|parallel deal.II intermediate ]"
            },
            "Output mesh displacement": {
                "value": "false",
                "default_value": "false",
                "documentation": "For computations with deforming meshes, ASPECT uses an Arbitrary-Lagrangian-Eulerian formulation to handle deforming the domain. The displacement vector from the reference configuration may be written as an output field by setting this parameter to true.",
                "pattern": "141",
                "pattern_description": "[Bool]"
            },
            "Output mesh velocity": {
                "value": "false",
                "default_value": "false",
                "documentation": "For computations with deforming meshes, ASPECT uses an Arbitrary-Lagrangian-Eulerian formulation to handle deforming the domain, so the mesh has its own velocity field.  This may be written as an output field by setting this parameter to true.",
                "pattern": "140",
                "pattern_description": "[Bool]"
            },
            "Output undeformed mesh": {
                "value": "false",
                "default_value": "false",
                "documentation": "For computations with deforming meshes, ASPECT uses an Arbitrary-Lagrangian-Eulerian formulation to handle deforming the domain. By default, we output the deformed mesh. If this setting is set to true, the mesh will be written in the reference state without deformation instead. If you output the mesh displacement, you can obtain the deformed mesh by using the 'warp by vector' ParaView filter.",
                "pattern": "142",
                "pattern_description": "[Bool]"
            },
            "Point-wise stress and strain": {
                "value": "false",
                "default_value": "false",
                "documentation": "If set to true, quantities related to stress and strain are computed in each vertex. Otherwise, an average per cell is computed.",
                "pattern": "137",
                "pattern_description": "[Bool]"
            },
            "Temporary output location": {
                "value": "",
                "default_value": "",
                "documentation": "On large clusters it can be advantageous to first write the output to a temporary file on a local file system and later move this file to a network file system. If this variable is set to a non-empty string it will be interpreted as a temporary storage location.",
                "pattern": "135",
                "pattern_description": "[Anything]"
            },
            "Time between graphical output": {
                "value": "1.e6",
                "default_value": "1e8",
                "documentation": "The time interval between each generation of graphical output files. A value of zero indicates that output should be generated in each time step. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "130",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Time steps between graphical output": {
                "value": "2147483647",
                "default_value": "2147483647",
                "documentation": "The maximum number of time steps between each generation of graphical output files.",
                "pattern": "131",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Write higher order output": {
                "value": "false",
                "default_value": "false",
                "documentation": "deal.II offers the possibility to write vtu files with higher order representations of the output data. This means each cell will correctly show the higher order representation of the output data instead of the linear interpolation between vertices that ParaView and VisIt usually show. Note that activating this option is safe and recommended, but requires that (i) ``Output format'' is set to ``vtu'', (ii) ``Interpolate output'' is set to true, (iii) you use a sufficiently new version of Paraview or VisIt to read the files (Paraview version 5.5 or newer, and VisIt version to be determined), and (iv) you use deal.II version 9.1.0 or newer. \nThe effect of using this option can be seen in the following picture:\n\n\\begin{center}  \\includegraphics[width=0.5\\textwidth]{viz\/parameters\/higher-order-output}\\end{center}The top figure shows the plain output without interpolation or higher order output. The middle figure shows output that was interpolated as discussed for the ``Interpolate output'' option. The bottom panel shows higher order output that achieves better accuracy than the interpolated output at a lower memory cost.",
                "pattern": "138",
                "pattern_description": "[Bool]"
            },
            "Write in background thread": {
                "value": "false",
                "default_value": "false",
                "documentation": "File operations can potentially take a long time, blocking the progress of the rest of the model run. Setting this variable to `true' moves this process into a background thread, while the rest of the model continues.",
                "pattern": "134",
                "pattern_description": "[Bool]"
            },
            "Artificial viscosity composition": {
                "Name of compositional field": {
                    "value": "",
                    "default_value": "",
                    "documentation": "The name of the compositional field whose output should be visualized. ",
                    "pattern": "177",
                    "pattern_description": "[Anything]"
                }
            },
            "Compositional fields as vectors": {
                "Names of fields": {
                    "value": "",
                    "default_value": "",
                    "documentation": "A list of sets of compositional fields which should be output as vectors. Sets are separated from each other by semicolons and vector components within each set are separated by commas (e.g. $vec1_x$, $vec1_y$ ; $vec2_x$, $vec2_y$) where each name must be a defined named compositional field. If only one name is given in a set, it is interpreted as the first in a sequence of dim consecutive compositional fields.",
                    "pattern": "176",
                    "pattern_description": "[Anything]"
                },
                "Names of vectors": {
                    "value": "",
                    "default_value": "",
                    "documentation": "Names of vectors as they will appear in the output.",
                    "pattern": "175",
                    "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
                }
            },
            "Heat flux map": {
                "Output point wise heat flux": {
                    "value": "false",
                    "default_value": "false",
                    "documentation": "A boolean flag that controls whether to output the heat flux map as a point wise value, or as a cell-wise averaged value. The point wise output is more accurate, but it currently omits prescribed heat flux values at boundaries and advective heat flux that is caused by velocities non-tangential to boundaries. If you do not use these two features it is recommended to switch this setting on to benefit from the increased output resolution.",
                    "pattern": "154",
                    "pattern_description": "[Bool]"
                }
            },
            "Material properties": {
                "List of material properties": {
                    "value": "density, viscosity",
                    "default_value": "density,thermal expansivity,specific heat,viscosity",
                    "documentation": "A comma separated list of material properties that should be written whenever writing graphical output. By default, the material properties will always contain the density, thermal expansivity, specific heat and viscosity. The following material properties are available:\n\nviscosity|density|thermal expansivity|specific heat|thermal conductivity|thermal diffusivity|compressibility|entropy derivative temperature|entropy derivative pressure|reaction terms|melt fraction",
                    "pattern": "155",
                    "pattern_description": "[MultipleSelection viscosity|density|thermal expansivity|specific heat|thermal conductivity|thermal diffusivity|compressibility|entropy derivative temperature|entropy derivative pressure|reaction terms|melt fraction ]"
                }
            },
            "Melt fraction": {
                "A1": {
                    "value": "1085.7",
                    "default_value": "1085.7",
                    "documentation": "Constant parameter in the quadratic function that approximates the solidus of peridotite. Units: \\si{\\degreeCelsius}.",
                    "pattern": "157",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "A2": {
                    "value": "1.329e-7",
                    "default_value": "1.329e-7",
                    "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the solidus of peridotite. \\si{\\degreeCelsius\\per\\pascal}.",
                    "pattern": "158",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "A3": {
                    "value": "-5.1e-18",
                    "default_value": "-5.1e-18",
                    "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the solidus of peridotite. \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                    "pattern": "159",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "B1": {
                    "value": "1475.0",
                    "default_value": "1475.0",
                    "documentation": "Constant parameter in the quadratic function that approximates the lherzolite liquidus used for calculating the fraction of peridotite-derived melt. Units: \\si{\\degreeCelsius}.",
                    "pattern": "160",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "B2": {
                    "value": "8.0e-8",
                    "default_value": "8.0e-8",
                    "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the  lherzolite liquidus used for calculating the fraction of peridotite-derived melt. \\si{\\degreeCelsius\\per\\pascal}.",
                    "pattern": "161",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "B3": {
                    "value": "-3.2e-18",
                    "default_value": "-3.2e-18",
                    "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the  lherzolite liquidus used for calculating the fraction of peridotite-derived melt. \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                    "pattern": "162",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "C1": {
                    "value": "1780.0",
                    "default_value": "1780.0",
                    "documentation": "Constant parameter in the quadratic function that approximates the liquidus of peridotite. Units: \\si{\\degreeCelsius}.",
                    "pattern": "163",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "C2": {
                    "value": "4.50e-8",
                    "default_value": "4.50e-8",
                    "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the liquidus of peridotite. \\si{\\degreeCelsius\\per\\pascal}.",
                    "pattern": "164",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "C3": {
                    "value": "-2.0e-18",
                    "default_value": "-2.0e-18",
                    "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the liquidus of peridotite. \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                    "pattern": "165",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "D1": {
                    "value": "976.0",
                    "default_value": "976.0",
                    "documentation": "Constant parameter in the quadratic function that approximates the solidus of pyroxenite. Units: \\si{\\degreeCelsius}.",
                    "pattern": "170",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "D2": {
                    "value": "1.329e-7",
                    "default_value": "1.329e-7",
                    "documentation": "Prefactor of the linear pressure term in the quadratic function that approximates the solidus of pyroxenite. Note that this factor is different from the value given in Sobolev, 2011, because they use the potential temperature whereas we use the absolute temperature. \\si{\\degreeCelsius\\per\\pascal}.",
                    "pattern": "171",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "D3": {
                    "value": "-5.1e-18",
                    "default_value": "-5.1e-18",
                    "documentation": "Prefactor of the quadratic pressure term in the quadratic function that approximates the solidus of pyroxenite. \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                    "pattern": "172",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "E1": {
                    "value": "663.8",
                    "default_value": "663.8",
                    "documentation": "Prefactor of the linear depletion term in the quadratic function that approximates the melt fraction of pyroxenite. \\si{\\degreeCelsius\\per\\pascal}.",
                    "pattern": "173",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "E2": {
                    "value": "-611.4",
                    "default_value": "-611.4",
                    "documentation": "Prefactor of the quadratic depletion term in the quadratic function that approximates the melt fraction of pyroxenite. \\si{\\degreeCelsius\\per\\pascal\\squared}.",
                    "pattern": "174",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "Mass fraction cpx": {
                    "value": "0.15",
                    "default_value": "0.15",
                    "documentation": "Mass fraction of clinopyroxene in the peridotite to be molten. Units: non-dimensional.",
                    "pattern": "169",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "beta": {
                    "value": "1.5",
                    "default_value": "1.5",
                    "documentation": "Exponent of the melting temperature in the melt fraction calculation. Units: non-dimensional.",
                    "pattern": "168",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "r1": {
                    "value": "0.5",
                    "default_value": "0.5",
                    "documentation": "Constant in the linear function that approximates the clinopyroxene reaction coefficient. Units: non-dimensional.",
                    "pattern": "166",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                },
                "r2": {
                    "value": "8e-11",
                    "default_value": "8e-11",
                    "documentation": "Prefactor of the linear pressure term in the linear function that approximates the clinopyroxene reaction coefficient. Units: \\si{\\per\\pascal}.",
                    "pattern": "167",
                    "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
                }
            },
            "Melt material properties": {
                "List of properties": {
                    "value": "compaction viscosity,permeability",
                    "default_value": "compaction viscosity,permeability",
                    "documentation": "A comma separated list of melt properties that should be written whenever writing graphical output. The following material properties are available:\n\ncompaction viscosity|fluid viscosity|permeability|fluid density|fluid density gradient|is melt cell|darcy coefficient|darcy coefficient no cutoff|compaction length",
                    "pattern": "156",
                    "pattern_description": "[MultipleSelection compaction viscosity|fluid viscosity|permeability|fluid density|fluid density gradient|is melt cell|darcy coefficient|darcy coefficient no cutoff|compaction length ]"
                }
            },
            "Principal stress": {
                "Use deviatoric stress": {
                    "value": "false",
                    "default_value": "false",
                    "documentation": "Whether to use the deviatoric stress tensor instead of the full stress tensor to compute principal stress directions and values.",
                    "pattern": "149",
                    "pattern_description": "[Bool]"
                }
            },
            "Temperature anomaly": {
                "Number of depth slices": {
                    "value": "20",
                    "default_value": "20",
                    "documentation": "Number of depth slices used to define average temperature.",
                    "pattern": "144",
                    "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
                },
                "Use maximal temperature for bottom": {
                    "value": "true",
                    "default_value": "true",
                    "documentation": "If true, use the specified boundary temperatures as average temperatures at the surface. If false, extrapolate the temperature gradient between the first and second cells to the surface. This option will only work for models with a fixed surface temperature. ",
                    "pattern": "145",
                    "pattern_description": "[Bool]"
                },
                "Use minimal temperature for surface": {
                    "value": "true",
                    "default_value": "true",
                    "documentation": "Whether to use the minimal specified boundary temperature as the bottom boundary temperature. This option will only work for models with a fixed bottom boundary temperature. ",
                    "pattern": "146",
                    "pattern_description": "[Bool]"
                }
            },
            "Volume of Fluid": {
                "Output interface normals": {
                    "value": "false",
                    "default_value": "false",
                    "documentation": "Include the internal data for the interface normal on the unit cells.",
                    "pattern": "148",
                    "pattern_description": "[Bool]"
                },
                "Output interface reconstruction contour": {
                    "value": "false",
                    "default_value": "false",
                    "documentation": "Include fields defined such that the 0 contour is the fluid interface.",
                    "pattern": "147",
                    "pattern_description": "[Bool]"
                }
            },
            "Vp anomaly": {
                "Average velocity scheme": {
                    "value": "reference profile",
                    "default_value": "reference profile",
                    "documentation": "Scheme to compute the average velocity-depth profile. The reference profile option evaluates the conditions along the reference adiabat according to the material model. The lateral average option instead calculates a lateral average from subdivision of the mesh. The lateral average option may produce spurious results where there are sharp velocity changes.",
                    "pattern": "152",
                    "pattern_description": "[Selection reference profile|lateral average ]"
                },
                "Number of depth slices": {
                    "value": "50",
                    "default_value": "50",
                    "documentation": "Number of depth slices used to define average seismic compressional wave velocities from which anomalies are calculated. Units: non-dimensional.",
                    "pattern": "153",
                    "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
                }
            },
            "Vs anomaly": {
                "Average velocity scheme": {
                    "value": "reference profile",
                    "default_value": "reference profile",
                    "documentation": "Scheme to compute the average velocity-depth profile. The reference profile option evaluates the conditions along the reference adiabat according to the material model. The lateral average option instead calculates a lateral average from subdivision of the mesh. The lateral average option may produce spurious results where there are sharp velocity changes.",
                    "pattern": "150",
                    "pattern_description": "[Selection reference profile|lateral average ]"
                },
                "Number of depth slices": {
                    "value": "50",
                    "default_value": "50",
                    "documentation": "Number of depth slices used to define average seismic shear wave velocities from which anomalies are calculated. Units: non-dimensional.",
                    "pattern": "151",
                    "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
                }
            }
        }
    },
    "Prescribed Stokes solution": {
        "Model name": {
            "value": "unspecified",
            "default_value": "unspecified",
            "documentation": "Select one of the following models:\n\n`ascii data': Implementation of a model in which the velocity is derived from files containing data in ascii format. Note the required format of the input data: The first lines may contain any number of comments if they begin with `#', but one of these lines needs to contain the number of grid points in each dimension as for example `# POINTS: 3 3'. The order of the data columns has to be `x', `y', `v${}_x$' , `v${}_y$' in a 2d model and  `x', `y', `z', `v${}_x$' , `v${}_y$' , `v${}_z$' in a 3d model. Note that the data in the input files need to be sorted in a specific order: the first coordinate needs to ascend first, followed by the second and the third at last in order to assign the correct data to the prescribed coordinates. If you use a spherical model, then the data will still be handled as Cartesian, however the assumed grid changes. `x' will be replaced by the radial distance of the point to the bottom of the model, `y' by the azimuth angle and `z' by the polar angle measured positive from the north pole. The grid will be assumed to be a latitude-longitude grid. Note that the order of spherical coordinates is `r', `phi', `theta' and not `r', `theta', `phi', since this allows for dimension independent expressions.\n\n`circle': This value describes a vector field that rotates around the z-axis with constant angular velocity (i.e., with a velocity that increases with distance from the axis). The pressure is set to zero.\n\n`function': This plugin allows to prescribe the Stokes solution for the velocity and pressure field in terms of an explicit formula. The format of these functions follows the syntax understood by the muparser library, see {ref}`sec:run-aspect:parameters-overview:muparser-format`.",
            "pattern": "1162",
            "pattern_description": "[Selection ascii data|circle|function|unspecified ]"
        },
        "Ascii data model": {
            "Data directory": {
                "value": "$ASPECT_SOURCE_DIR\/data\/prescribed-stokes-solution\/",
                "default_value": "$ASPECT_SOURCE_DIR\/data\/prescribed-stokes-solution\/",
                "documentation": "The name of a directory that contains the model data. This path may either be absolute (if starting with a `\/') or relative to the current directory. The path may also include the special text `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the ASPECT source files were located when ASPECT was compiled. This interpretation allows, for example, to reference files located in the `data\/' subdirectory of ASPECT.",
                "pattern": "1178",
                "pattern_description": "[DirectoryName]"
            },
            "Data file name": {
                "value": "box_2d.txt",
                "default_value": "box_2d.txt",
                "documentation": "The file name of the model data.",
                "pattern": "1179",
                "pattern_description": "[Anything]"
            },
            "First point on slice": {
                "value": "0.0,1.0,0.0",
                "default_value": "0.0,1.0,0.0",
                "documentation": "Point that determines the plane in which the 2d slice lies in. This variable is only used if 'Slice dataset in 2d plane' is true. The slice will go through this point, the point defined by the parameter 'Second point on slice', and the center of the model domain. After the rotation, this first point will lie along the (0,1,0) axis of the coordinate system. The coordinates of the point have to be given in Cartesian coordinates.",
                "pattern": "1182",
                "pattern_description": "[Anything]"
            },
            "Scale factor": {
                "value": "1.",
                "default_value": "1.",
                "documentation": "Scalar factor, which is applied to the model data. You might want to use this to scale the input to a reference model. Another way to use this factor is to convert units of the input files. For instance, if you provide velocities in cm\/yr set this factor to 0.01.",
                "pattern": "1180",
                "pattern_description": "[Double -MAX_DOUBLE...MAX_DOUBLE (inclusive)]"
            },
            "Second point on slice": {
                "value": "1.0,0.0,0.0",
                "default_value": "1.0,0.0,0.0",
                "documentation": "Second point that determines the plane in which the 2d slice lies in. This variable is only used if 'Slice dataset in 2d plane' is true. The slice will go through this point, the point defined by the parameter 'First point on slice', and the center of the model domain. The coordinates of the point have to be given in Cartesian coordinates.",
                "pattern": "1183",
                "pattern_description": "[Anything]"
            },
            "Slice dataset in 2D plane": {
                "value": "false",
                "default_value": "false",
                "documentation": "Whether to use a 2d data slice of a 3d data file or the entire data file. Slicing a 3d dataset is only supported for 2d models.",
                "pattern": "1181",
                "pattern_description": "[Bool]"
            }
        },
        "Compaction pressure function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1174",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1173",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1172",
                "pattern_description": "[Anything]"
            }
        },
        "Fluid pressure function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1171",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1170",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1169",
                "pattern_description": "[Anything]"
            }
        },
        "Fluid velocity function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1177",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0; 0",
                "default_value": "0; 0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1176",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1175",
                "pattern_description": "[Anything]"
            }
        },
        "Pressure function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1168",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0",
                "default_value": "0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1167",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1166",
                "pattern_description": "[Anything]"
            }
        },
        "Velocity function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "1165",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "0; 0",
                "default_value": "0; 0",
                "documentation": "The formula that denotes the function you want to evaluate for particular values of the independent variables. This expression may contain any of the usual operations such as addition or multiplication, as well as all of the common functions such as `sin' or `cos'. In addition, it may contain expressions like `if(x>0, 1, -1)' where the expression evaluates to the second argument if the first argument is true, and to the third argument otherwise. For a full overview of possible expressions accepted see the documentation of the muparser library at http:\/\/muparser.beltoforion.de\/.\n\nIf the function you are describing represents a vector-valued function with multiple components, then separate the expressions for individual components by a semicolon.",
                "pattern": "1164",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "x,y,t",
                "default_value": "x,y,t",
                "documentation": "The names of the variables as they will be used in the function, separated by commas. By default, the names of variables at which the function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial coordinates and `t' for time. You can then use these variable names in your function expression and they will be replaced by the values of these variables at which the function is currently evaluated. However, you can also choose a different set of names for the independent variables at which to evaluate your function expression. For example, if you work in spherical coordinates, you may wish to set this input parameter to `r,phi,theta,t' and then use these variable names in your function expression.",
                "pattern": "1163",
                "pattern_description": "[Anything]"
            }
        }
    },
    "Solver parameters": {
        "Composition solver tolerance": {
            "value": "1e-12",
            "default_value": "1e-12",
            "documentation": "The relative tolerance up to which the linear system for the composition system gets solved. See `Stokes solver parameters\/Linear solver tolerance' for more details.",
            "pattern": "22",
            "pattern_description": "[Double 0...1 (inclusive)]"
        },
        "Temperature solver tolerance": {
            "value": "1e-12",
            "default_value": "1e-12",
            "documentation": "The relative tolerance up to which the linear system for the temperature system gets solved. See `Stokes solver parameters\/Linear solver tolerance' for more details.",
            "pattern": "21",
            "pattern_description": "[Double 0...1 (inclusive)]"
        },
        "AMG parameters": {
            "AMG aggregation threshold": {
                "value": "0.001",
                "default_value": "0.001",
                "documentation": "This threshold tells the AMG setup how the coarsening should be performed. In the AMG used by ML, all points that strongly couple with the tentative coarse-level point form one aggregate. The term strong coupling is controlled by the variable aggregation\\_threshold, meaning that all elements that are not smaller than aggregation\\_threshold times the diagonal element do couple strongly. The default is strongly recommended. There are indications that for the Newton solver a different value might be better. For extensive benchmarking of various settings of the AMG parameters in this section for the Stokes problem and others, see https:\/\/github.com\/geodynamics\/aspect\/pull\/234.",
                "pattern": "37",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "AMG output details": {
                "value": "false",
                "default_value": "false",
                "documentation": "Turns on extra information on the AMG solver. Note that this will generate much more output.",
                "pattern": "38",
                "pattern_description": "[Bool]"
            },
            "AMG smoother sweeps": {
                "value": "2",
                "default_value": "2",
                "documentation": "Determines how many sweeps of the smoother should be performed. When the flag elliptic is set to true, (which is true for ASPECT), the polynomial degree of the Chebyshev smoother is set to this value. The term sweeps refers to the number of matrix-vector products performed in the Chebyshev case. In the non-elliptic case, this parameter sets the number of SSOR relaxation sweeps for post-smoothing to be performed. The default is strongly recommended. There are indications that for the Newton solver a different value might be better. For extensive benchmarking of various settings of the AMG parameters in this section for the Stokes problem and others, see https:\/\/github.com\/geodynamics\/aspect\/pull\/234.",
                "pattern": "36",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "AMG smoother type": {
                "value": "Chebyshev",
                "default_value": "Chebyshev",
                "documentation": "This parameter sets the type of smoother for the AMG. The default is strongly recommended for any normal runs with ASPECT. There are some indications that the symmetric Gauss-Seidel might be better and more stable for the Newton solver. For extensive benchmarking of various settings of the AMG parameters in this section for the Stokes problem and others, see https:\/\/github.com\/geodynamics\/aspect\/pull\/234.",
                "pattern": "35",
                "pattern_description": "[Selection Chebyshev|symmetric Gauss-Seidel ]"
            }
        },
        "Advection solver parameters": {
            "GMRES solver restart length": {
                "value": "50",
                "default_value": "50",
                "documentation": "This is the number of iterations that define the GMRES solver restart length. Increasing this parameter makes the solver more robust and decreases the number of iterations. Be aware that increasing this number increases the memory usage of the advection solver, and makes individual iterations more expensive.",
                "pattern": "23",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            }
        },
        "Diffusion solver parameters": {
            "Diffusion length scale": {
                "value": "1.e4",
                "default_value": "1.e4",
                "documentation": "Set a length scale for the diffusion of advection fields if the ``prescribed field with diffusion'' method is selected for a field. More precisely, this length scale represents the square root of the product of diffusivity and time in the diffusion equation, and controls the distance over which features are diffused. Units: \\si{\\meter}.",
                "pattern": "41",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Matrix Free": {
            "Execute solver timings": {
                "value": "false",
                "default_value": "false",
                "documentation": "Executes different parts of the Stokes solver repeatedly and print timing information. This is for internal benchmarking purposes: It is useful if you want to see how the solver performs. Otherwise, you don't want to enable this, since it adds additional computational cost to get the timing information.",
                "pattern": "116",
                "pattern_description": "[Bool]"
            },
            "Output details": {
                "value": "false",
                "default_value": "false",
                "documentation": "Turns on extra information for the matrix free GMG solver to be printed.",
                "pattern": "115",
                "pattern_description": "[Bool]"
            }
        },
        "Newton solver parameters": {
            "Max Newton line search iterations": {
                "value": "5",
                "default_value": "5",
                "documentation": "The maximum number of line search iterations allowed. If the criterion is not reached after this number of iterations, we apply the scaled increment even though it does not satisfy the necessary criteria and simply continue with the next Newton iteration.",
                "pattern": "107",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Max pre-Newton nonlinear iterations": {
                "value": "10",
                "default_value": "10",
                "documentation": "If the 'Nonlinear Newton solver switch tolerance' is reached before the maximal number of Picard iterations, then the solver switches to Newton solves anyway.",
                "pattern": "106",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Maximum linear Stokes solver tolerance": {
                "value": "1e-2",
                "default_value": "1e-2",
                "documentation": "The linear Stokes solver tolerance is dynamically chosen for the Newton solver, based on the Eisenstat Walker (1994) paper (https:\/\/doi.org\/10.1137\/0917003), equation 2.2. Because this value can become larger than one, we limit this value by this parameter.",
                "pattern": "109",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "Nonlinear Newton solver switch tolerance": {
                "value": "1e-5",
                "default_value": "1e-5",
                "documentation": "A relative tolerance with respect to the residual of the first iteration, up to which the nonlinear Picard solver will iterate, before changing to the Newton solver.",
                "pattern": "105",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "SPD safety factor": {
                "value": "0.9",
                "default_value": "0.9",
                "documentation": "When stabilizing the Newton matrix, we can encounter situations where the coefficient inside the elliptic (top-left) block becomes negative or zero. This coefficient has the form $1+x$ where $x$ can sometimes be smaller than $-1$. In this case, the top-left block of the matrix is no longer positive definite, and both preconditioners and iterative solvers may fail. To prevent this, the stabilization computes an $\\alpha$ so that $1+\\alpha x$ is never negative. This $\\alpha$ is chosen as $1$ if $x\\ge -1$, and $\\alpha=-\\frac 1x$ otherwise. (Note that this always leads to $0\\le \\alpha \\le 1$.)  On the other hand, we also want to stay away from $1+\\alpha x=0$, and so modify the choice of $\\alpha$ to be $1$ if $x\\ge -c$, and $\\alpha=-\\frac cx$ with a $c$ between zero and one. This way, if $c<1$, we are assured that $1-\\alpha x>c$, i.e., bounded away from zero.",
                "pattern": "113",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "Stabilization preconditioner": {
                "value": "SPD",
                "default_value": "SPD",
                "documentation": "This parameters allows for the stabilization of the preconditioner. If one derives the Newton method without any modifications, the matrix created for the preconditioning is not necessarily Symmetric Positive Definite. This is problematic (see \\cite{FBTGS19}). When `none' is chosen, the preconditioner is not stabilized. The `symmetric' parameters symmetrizes the matrix, and `PD' makes the matrix Positive Definite. `SPD' is the full stabilization, where the matrix is guaranteed Symmetric Positive Definite.",
                "pattern": "110",
                "pattern_description": "[Selection SPD|PD|symmetric|none ]"
            },
            "Stabilization velocity block": {
                "value": "SPD",
                "default_value": "SPD",
                "documentation": "This parameters allows for the stabilization of the velocity block. If one derives the Newton method without any modifications, the matrix created for the velocity block is not necessarily Symmetric Positive Definite. This is problematic (see \\cite{FBTGS19}). When `none' is chosen, the velocity block is not stabilized. The `symmetric' parameters symmetrizes the matrix, and `PD' makes the matrix Positive Definite. `SPD' is the full stabilization, where the matrix is guaranteed Symmetric Positive Definite.",
                "pattern": "111",
                "pattern_description": "[Selection SPD|PD|symmetric|none ]"
            },
            "Use Eisenstat Walker method for Picard iterations": {
                "value": "false",
                "default_value": "false",
                "documentation": "If set to true, the Picard iteration uses the Eisenstat Walker method to determine how accurately linear systems need to be solved. The Picard iteration is used, for example, in the first few iterations of the Newton method before the matrix is built including derivatives of the model, since the Picard iteration generally converges even from points where Newton's method does not. \n\nOnce derivatives are used in a Newton method, \\aspect{} always uses the Eisenstat Walker method.",
                "pattern": "114",
                "pattern_description": "[Bool]"
            },
            "Use Newton failsafe": {
                "value": "false",
                "default_value": "false",
                "documentation": "When this parameter is true and the linear solver fails, we try again, but now with SPD stabilization for both the preconditioner and the velocity block. The SPD stabilization will remain active until the next timestep, when the default values are restored.",
                "pattern": "112",
                "pattern_description": "[Bool]"
            },
            "Use Newton residual scaling method": {
                "value": "false",
                "default_value": "false",
                "documentation": "This method allows to slowly introduce the derivatives based on the improvement of the residual. If set to false, the scaling factor for the Newton derivatives is set to one immediately when switching on the Newton solver. When this is set to true, the derivatives are slowly introduced by the following equation: $\\max(0.0, (1.0-(residual\/switch\\_initial\\_residual)))$, where switch\\_initial\\_residual is the residual at the time when the Newton solver is switched on.",
                "pattern": "108",
                "pattern_description": "[Bool]"
            }
        },
        "Operator splitting parameters": {
            "Reaction time step": {
                "value": "1000.0",
                "default_value": "1000.0",
                "documentation": "Set a time step size for computing reactions of compositional fields and the temperature field in case operator splitting is used. This is only used when the parameter ``Use operator splitting'' is set to true. The reaction time step must be greater than 0. If you want to prescribe the reaction time step only as a relative value compared to the advection time step as opposed to as an absolute value, you should use the parameter ``Reaction time steps per advection step'' and set this parameter to the same (or larger) value as the ``Maximum time step'' (which is 5.69e+300 by default). Units: Years or seconds, depending on the ``Use years in output instead of seconds'' parameter.",
                "pattern": "39",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Reaction time steps per advection step": {
                "value": "0",
                "default_value": "0",
                "documentation": "The number of reaction time steps done within one advection time step in case operator splitting is used. This is only used if the parameter ``Use operator splitting'' is set to true. If set to zero, this parameter is ignored. Otherwise, the reaction time step size is chosen according to this criterion and the ``Reaction time step'', whichever yields the smaller time step. Units: none.",
                "pattern": "40",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            }
        },
        "Stokes solver parameters": {
            "GMRES solver restart length": {
                "value": "50",
                "default_value": "50",
                "documentation": "This is the number of iterations that define the GMRES solver restart length. Increasing this parameter helps with convergence issues arising from high localized viscosity jumps in the domain. Be aware that increasing this number increases the memory usage of the Stokes solver, and makes individual Stokes iterations more expensive.",
                "pattern": "31",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "IDR(s) parameter": {
                "value": "2",
                "default_value": "2",
                "documentation": "This is the sole parameter for the IDR(s) Krylov solver and will dictate the number of matrix-vector products and preconditioner applications per iteration (s+1) and the total number of temporary vectors required (5+3*s). For s=1, this method is analogous to BiCGStab. As s is increased this method is expected to converge to GMRES in terms of matrix-vector\/preconditioner applications to solution.",
                "pattern": "27",
                "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
            },
            "Krylov method for cheap solver steps": {
                "value": "GMRES",
                "default_value": "GMRES",
                "documentation": "This is the Krylov method used to solve the Stokes system. Both options, GMRES and IDR(s), solve non-symmetric, indefinite systems. GMRES guarantees the residual will be reduced in each iteration while IDR(s) has no such property. On the other hand, the vector storage requirement for GMRES is dependent on the restart length and can be quite restrictive (since, for the matrix-free GMG solver, memory is dominated by these vectors) whereas IDR(s) has a short term recurrence. Note that the IDR(s) Krylov method is not available for the AMG solver since it is not a flexible method, i.e., it cannot handle a preconditioner which may change in each iteration (the AMG-based preconditioner contains a CG solve in the pressure space which may have different number of iterations each step).",
                "pattern": "26",
                "pattern_description": "[Selection GMRES|IDR(s) ]"
            },
            "Linear solver A block tolerance": {
                "value": "1e-2",
                "default_value": "1e-2",
                "documentation": "A relative tolerance up to which the approximate inverse of the $A$ block of the Stokes system is computed. This approximate $A$ is used in the preconditioning used in the GMRES solver. The exact definition of this block preconditioner for the Stokes equation can be found in \\cite{KHB12}.",
                "pattern": "32",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "Linear solver S block tolerance": {
                "value": "1e-6",
                "default_value": "1e-6",
                "documentation": "A relative tolerance up to which the approximate inverse of the $S$ block (i.e., the Schur complement matrix $S = BA^{-1}B^{T}$) of the Stokes system is computed. This approximate inverse of the $S$ block is used in the preconditioning used in the GMRES solver. The exact definition of this block preconditioner for the Stokes equation can be found in \\cite{KHB12}.",
                "pattern": "34",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "Linear solver tolerance": {
                "value": "1e-7",
                "default_value": "1e-7",
                "documentation": "A relative tolerance up to which the linear Stokes systems in each time or nonlinear step should be solved. The absolute tolerance will then be $\\| M x_0 - F \\| \\cdot \\text{tol}$, where $x_0 = (0,p_0)$ is the initial guess of the pressure, $M$ is the system matrix, $F$ is the right-hand side, and tol is the parameter specified here. We include the initial guess of the pressure to remove the dependency of the tolerance on the static pressure. A given tolerance value of 1 would mean that a zero solution vector is an acceptable solution since in that case the norm of the residual of the linear system equals the norm of the right hand side. A given tolerance of 0 would mean that the linear system has to be solved exactly, since this is the only way to obtain a zero residual.\n\nIn practice, you should choose the value of this parameter to be so that if you make it smaller the results of your simulation do not change any more (qualitatively) whereas if you make it larger, they do. For most cases, the default value should be sufficient. In fact, a tolerance of 1e-4 might be accurate enough.",
                "pattern": "28",
                "pattern_description": "[Double 0...1 (inclusive)]"
            },
            "Maximum number of expensive Stokes solver steps": {
                "value": "1000",
                "default_value": "1000",
                "documentation": "This sets the maximum number of iterations used in the expensive Stokes solver. If this value is set too low for the size of the problem, the Stokes solver will not converge and return an error message pointing out that the user didn't allow a sufficiently large number of iterations for the iterative solver to converge.",
                "pattern": "30",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Number of cheap Stokes solver steps": {
                "value": "200",
                "default_value": "200",
                "documentation": "As explained in the paper that describes ASPECT (Kronbichler, Heister, and Bangerth, 2012, see \\cite{KHB12}) we first try to solve the Stokes system in every time step using a GMRES iteration with a poor but cheap preconditioner. By default, we try whether we can converge the GMRES solver in 200 such iterations before deciding that we need a better preconditioner. This is sufficient for simple problems with variable viscosity and we never need the second phase with the more expensive preconditioner. On the other hand, for more complex problems, and in particular for problems with strongly nonlinear viscosity, the 200 cheap iterations don't actually do very much good and one might skip this part right away. In that case, this parameter can be set to zero, i.e., we immediately start with the better but more expensive preconditioner.",
                "pattern": "29",
                "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
            },
            "Stokes solver type": {
                "value": "block AMG",
                "default_value": "block AMG",
                "documentation": "This is the type of solver used on the Stokes system. The block geometric multigrid solver currently has a limited implementation and therefore may trigger Asserts in the code when used. If this is the case, please switch to 'block AMG'. Additionally, the block GMG solver requires using material model averaging.",
                "pattern": "24",
                "pattern_description": "[Selection block AMG|direct solver|block GMG ]"
            },
            "Use direct solver for Stokes system": {
                "value": "false",
                "default_value": "false",
                "documentation": "If set to true the linear system for the Stokes equation will be solved using Trilinos klu, otherwise an iterative Schur complement solver is used. The direct solver is only efficient for small problems.",
                "pattern": "25",
                "pattern_description": "[Bool]"
            },
            "Use full A block as preconditioner": {
                "value": "false",
                "default_value": "false",
                "documentation": "This parameter determines whether we use an simplified approximation of the $A$ block as preconditioner for the Stokes solver, or the full $A$ block. The simplified approximation only contains the terms that describe the coupling of identical components (plus boundary conditions) as described in \\cite{KHB12}. The full block is closer to the description in \\cite{rudi2017weighted}.\n\nThere is no clear way to determine which preconditioner performs better. The default value (simplified approximation) requires more outer GMRES iterations, but is faster to apply in each iteration. The full block needs less assembly time (because the block is available anyway), converges in less GMRES iterations, but requires more time per iteration. There are also differences in the amount of memory consumption between the two approaches.\n\nThe default value should be good for relatively simple models, but in particular for very strong viscosity contrasts the full $A$ block can be advantageous.",
                "pattern": "33",
                "pattern_description": "[Bool]"
            }
        }
    },
    "Temperature field": {
        "Temperature method": {
            "value": "field",
            "default_value": "field",
            "documentation": "A comma separated list denoting the solution method of the temperature field. Each entry of the list must be one of the currently implemented field types.\n\nThese choices correspond to the following methods by which the temperature field gains its values:\\begin{itemize}\\item ``field'': If the temperature is marked with this method, then its values are computed in each time step by solving the temperature advection-diffusion equation. In other words, this corresponds to the usual notion of a temperature. \n\\item ``prescribed field'': The value of the temperature is determined in each time step from the material model. If a compositional field is marked with this method, then the value of a specific additional material model output, called the `PrescribedTemperatureOutputs' is interpolated onto the temperature. This field does not change otherwise, it is not advected with the flow. \n\\item ``prescribed field with diffusion'': If the temperature field is marked this way, the value of a specific additional material model output, called the `PrescribedTemperatureOutputs' is interpolated onto the field, as in the ``prescribed field'' method. Afterwards, the field is diffused based on a solver parameter, the diffusion length scale, smoothing the field. Specifically, the field is updated by solving the equation $(I-l^2 \\Delta) T_\\text{smoothed} = T_\\text{prescribed}$, where $l$ is the diffusion length scale. Note that this means that the amount of diffusion is independent of the time step size, and that the field is not advected with the flow.\n\\item ``static'': If a temperature field is marked this way, then it does not evolve at all. Its values are simply set to the initial conditions, and will then never change.\\end{itemize}",
            "pattern": "87",
            "pattern_description": "[Selection field|prescribed field|prescribed field with diffusion|static ]"
        }
    },
    "Termination criteria": {
        "Checkpoint on termination": {
            "value": "false",
            "default_value": "false",
            "documentation": "Whether to checkpoint the simulation right before termination.",
            "pattern": "367",
            "pattern_description": "[Bool]"
        },
        "End step": {
            "value": "100",
            "default_value": "100",
            "documentation": "Terminate the simulation once the specified timestep has been reached.",
            "pattern": "366",
            "pattern_description": "[Integer range 0...2147483647 (inclusive)]"
        },
        "Termination criteria": {
            "value": "end time",
            "default_value": "end time",
            "documentation": "A comma separated list of termination criteria that will determine when the simulation should end. Whether explicitly stated or not, the ``end time'' termination criterion will always be used.The following termination criteria are available:\n\n`end step': Terminate the simulation once the specified timestep has been reached. \n\n`end time': Terminate the simulation once the end time specified in the input file has been reached. Unlike all other termination criteria, this criterion is \\textit{always} active, whether it has been explicitly selected or not in the input file (this is done to preserve historical behavior of \\aspect{}, but it also likely does not inconvenience anyone since it is what would be selected in most cases anyway).\n\n`steady state heat flux': A criterion that terminates the simulation when the integrated heat flux over a given list of boundaries stays within a certain range for a specified period of time.\n\nThe criterion considers the total heat flux over all boundaries listed by their boundary indicators, rather than each boundary separately. As a consequence, if the \\textit{sum} of heat fluxes over individual parts of the boundary no longer changes, then this criterion recommends termination, even if the heat flux over individual parts of the boundary continues to change.\n\n`steady state temperature': A criterion that terminates the simulation when the global integral of the temperature field stays within a certain range for a specified period of time.\n\n`steady state velocity': A criterion that terminates the simulation when the RMS of the velocity field stays within a certain range for a specified period of time.\n\n`user request': Terminate the simulation gracefully when a file with a specified name appears in the output directory. This allows the user to gracefully exit the simulation at any time by simply creating such a file using, for example, \\texttt{touch output\/terminate}. The file's location is chosen to be in the output directory, rather than in a generic location such as the ASPECT directory, so that one can run multiple simulations at the same time (which presumably write to different output directories) and can selectively terminate a particular one.\n\n`wall time': Terminate the simulation once the wall time limit has reached.",
            "pattern": "355",
            "pattern_description": "[MultipleSelection end step|end time|steady state heat flux|steady state temperature|steady state velocity|user request|wall time ]"
        },
        "Wall time": {
            "value": "24.",
            "default_value": "24.",
            "documentation": "The wall time of the simulation. Unit: hours.",
            "pattern": "357",
            "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
        },
        "Steady state heat flux": {
            "Boundary indicators": {
                "value": "",
                "default_value": "",
                "documentation": "A comma separated list of names denoting those boundaries that should be taken into account for integrating the heat flux. Note that the plugin will compute the integrated heat flux over these boundaries (instead of taking them into account individually).\n\nThe names of the boundaries listed here can either be numbers (in which case they correspond to the numerical boundary indicators assigned by the geometry object), or they can correspond to any of the symbolic names the geometry object may have provided for each part of the boundary. You may want to compare this with the documentation of the geometry model you use in your model.",
                "pattern": "360",
                "pattern_description": "[List of <[Anything]> of length 0...4294967295 (inclusive)]"
            },
            "Maximum relative deviation": {
                "value": "0.05",
                "default_value": "0.05",
                "documentation": "The maximum relative deviation of the heat flux in recent simulation time for the system to be considered in steady state. If the actual deviation is smaller than this number, then the simulation will be terminated.",
                "pattern": "358",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Time in steady state": {
                "value": "1e7",
                "default_value": "1e7",
                "documentation": "The minimum length of simulation time that the system should be in steady state before termination. Note that if the time step size is similar to or larger than this value, the termination criterion will only have very few (in the most extreme case, just two) heat flux values to check. To ensure that a larger number of time steps are included in the check for steady state, this value should be much larger than the time step size. Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "359",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Steady state temperature": {
            "Maximum relative deviation": {
                "value": "0.05",
                "default_value": "0.05",
                "documentation": "The maximum relative deviation of the temperature in recent simulation time for the system to be considered in steady state. If the actual deviation is smaller than this number, then the simulation will be terminated.",
                "pattern": "363",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Time in steady state": {
                "value": "1e7",
                "default_value": "1e7",
                "documentation": "The minimum length of simulation time that the system should be in steady state before termination.Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "364",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "Steady state velocity": {
            "Maximum relative deviation": {
                "value": "0.05",
                "default_value": "0.05",
                "documentation": "The maximum relative deviation of the RMS in recent simulation time for the system to be considered in steady state. If the actual deviation is smaller than this number, then the simulation will be terminated.",
                "pattern": "361",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Time in steady state": {
                "value": "1e7",
                "default_value": "1e7",
                "documentation": "The minimum length of simulation time that the system should be in steady state before termination.Units: years if the 'Use years in output instead of seconds' parameter is set; seconds otherwise.",
                "pattern": "362",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        },
        "User request": {
            "File name": {
                "value": "terminate-aspect",
                "default_value": "terminate-aspect",
                "documentation": "The name of a file that, if it exists in the output directory (whose name is also specified in the input file) will lead to termination of the simulation. The file's location is chosen to be in the output directory, rather than in a generic location such as the ASPECT directory, so that one can run multiple simulations at the same time (which presumably write to different output directories) and can selectively terminate a particular one.",
                "pattern": "365",
                "pattern_description": "[FileName (Type: input)]"
            }
        }
    },
    "Time stepping": {
        "List of model names": {
            "value": "",
            "default_value": "",
            "documentation": "A comma separated list of time stepping plugins that will be used to calculate the time step size. The minimum of the  result of each plugin will be used.\n\nThe following plugins are available:\n\n`conduction time step': This model computes the conduction time step as the minimum over all cells of $ CFL h^2 \\cdot \\rho C_p \/ k$, where k is the thermal conductivity. This plugin will always request advancing to the next time step.\n\n`convection time step': This model computes the convection time step as $ CFL \/ \\max \\| u \\| \/ h$ over all cells, where $u$ is the velocity and $h$ is the product of mesh size and temperature polynomial degree.\n\n`function': This model uses a time step specified in the parameter file specified as a function of time. This plugin will always request advancing to the next time step.\n\n`repeat on cutback': This time stepping plugin will detect a situation where the computed time step shrinks by more than a user-controlled factor. In that situation, the previous time step will be repeated with a smaller step size.\nA large reduction in time step size typically happens when velocities change abruptly. Repeating the time step ensure properly resolving this event. It is useful to consider setting the \"Maximum relative increase in time step\" option to avoid repeatedly repeating every other time step.",
            "pattern": "369",
            "pattern_description": "[MultipleSelection conduction time step|convection time step|function|repeat on cutback ]"
        },
        "Minimum time step size": {
            "value": "0.",
            "default_value": "0.",
            "documentation": "Specify a minimum time step size (or 0 to disable).",
            "pattern": "368",
            "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
        },
        "Function": {
            "Function constants": {
                "value": "",
                "default_value": "",
                "documentation": "Sometimes it is convenient to use symbolic constants in the expression that describes the function, rather than having to use its numeric value everywhere the constant appears. These values can be defined using this parameter, in the form `var1=value1, var2=value2, ...'.\n\nA typical example would be to set this runtime parameter to `pi=3.1415926536' and then use `pi' in the expression of the actual formula. (That said, for convenience this class actually defines both `pi' and `Pi' by default, but you get the idea.)",
                "pattern": "372",
                "pattern_description": "[Anything]"
            },
            "Function expression": {
                "value": "1.0",
                "default_value": "1.0",
                "documentation": "Expression for the time step size as a function of 'time'.",
                "pattern": "373",
                "pattern_description": "[Anything]"
            },
            "Variable names": {
                "value": "time",
                "default_value": "time",
                "documentation": "Name for the variable representing the current time.",
                "pattern": "374",
                "pattern_description": "[Anything]"
            }
        },
        "Repeat on cutback": {
            "Cut back amount": {
                "value": "0.5",
                "default_value": "0.5",
                "documentation": "A factor that controls the size of the time step when repeating. The default of 0.5 corresponds to 50\\% of the original step taken.",
                "pattern": "376",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            },
            "Relative repeat threshold": {
                "value": "0.2",
                "default_value": "0.2",
                "documentation": "A factor that controls when a step is going to be repeated. If the newly computed step size is smaller than the last step size multiplied by this factor, the step is repeated.",
                "pattern": "375",
                "pattern_description": "[Double 0...MAX_DOUBLE (inclusive)]"
            }
        }
    },
    "Volume of Fluid": {
        "Number initialization samples": {
            "value": "3",
            "default_value": "3",
            "documentation": "Number of divisions per dimension when computing the initial volume fractions.If set to the default of 3 for a 2d model, then initialization will be based on the initialization criterion at $3^2=9$ points within each cell. If the initialization based on a composition style initial condition, a larger value may be desired for better approximation of the initial fluid fractions. Smaller values will suffice in the case of level set initializations due to the presence of more information to better approximate the initial fluid fractions.",
            "pattern": "97",
            "pattern_description": "[Integer range 1...2147483647 (inclusive)]"
        },
        "Volume fraction threshold": {
            "value": "1e-6",
            "default_value": "1e-6",
            "documentation": "Minimum significant volume. Fluid fractions below this value are considered to be zero.",
            "pattern": "95",
            "pattern_description": "[Double 0...1 (inclusive)]"
        },
        "Volume of Fluid solver tolerance": {
            "value": "1e-12",
            "default_value": "1e-12",
            "documentation": "The relative tolerance up to which the linear system for the Volume of Fluid system gets solved. See 'Solver parameters\/Composition solver tolerance' for more details.",
            "pattern": "96",
            "pattern_description": "[Double 0...1 (inclusive)]"
        }
    }
}
